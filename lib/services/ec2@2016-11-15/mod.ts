// Autogenerated API client for: Amazon Elastic Compute Cloud

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}
function parseBlob(input: string | null | undefined) {
  if (input == null) return input;
  return Base64.decode(input);
}

export default class EC2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EC2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-11-15",
    "endpointPrefix": "ec2",
    "protocol": "ec2",
    "serviceAbbreviation": "Amazon EC2",
    "serviceFullName": "Amazon Elastic Compute Cloud",
    "serviceId": "EC2",
    "signatureVersion": "v4",
    "uid": "ec2-2016-11-15",
    "xmlNamespace": "http://ec2.amazonaws.com/doc/2016-11-15"
  };

  async acceptReservedInstancesExchangeQuote(
    {abortSignal, ...params}: RequestConfig & s.AcceptReservedInstancesExchangeQuoteRequest,
  ): Promise<s.AcceptReservedInstancesExchangeQuoteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstanceIds"]) qsP.appendList(body, prefix+"ReservedInstanceId", params["ReservedInstanceIds"], {"entryPrefix":"."})
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"TargetConfiguration", params["TargetConfigurations"], {"appender":TargetConfigurationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptReservedInstancesExchangeQuote",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExchangeId: xml.first("exchangeId", false, x => x.content ?? ''),
    };
  }

  async acceptTransitGatewayMulticastDomainAssociations(
    {abortSignal, ...params}: RequestConfig & s.AcceptTransitGatewayMulticastDomainAssociationsRequest = {},
  ): Promise<s.AcceptTransitGatewayMulticastDomainAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptTransitGatewayMulticastDomainAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async acceptTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & s.AcceptTransitGatewayPeeringAttachmentRequest,
  ): Promise<s.AcceptTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async acceptTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & s.AcceptTransitGatewayVpcAttachmentRequest,
  ): Promise<s.AcceptTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async acceptVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & s.AcceptVpcEndpointConnectionsRequest,
  ): Promise<s.AcceptVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async acceptVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.AcceptVpcPeeringConnectionRequest = {},
  ): Promise<s.AcceptVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnection: xml.first("vpcPeeringConnection", false, VpcPeeringConnection_Parse),
    };
  }

  async advertiseByoipCidr(
    {abortSignal, ...params}: RequestConfig & s.AdvertiseByoipCidrRequest,
  ): Promise<s.AdvertiseByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdvertiseByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async allocateAddress(
    {abortSignal, ...params}: RequestConfig & s.AllocateAddressRequest = {},
  ): Promise<s.AllocateAddressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("Address" in params) body.append(prefix+"Address", (params["Address"] ?? '').toString());
    if ("PublicIpv4Pool" in params) body.append(prefix+"PublicIpv4Pool", (params["PublicIpv4Pool"] ?? '').toString());
    if ("NetworkBorderGroup" in params) body.append(prefix+"NetworkBorderGroup", (params["NetworkBorderGroup"] ?? '').toString());
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateAddress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIp: xml.first("publicIp", false, x => x.content ?? ''),
      AllocationId: xml.first("allocationId", false, x => x.content ?? ''),
      PublicIpv4Pool: xml.first("publicIpv4Pool", false, x => x.content ?? ''),
      NetworkBorderGroup: xml.first("networkBorderGroup", false, x => x.content ?? ''),
      Domain: xml.first("domain", false, x => (x.content ?? '') as s.DomainType),
      CustomerOwnedIp: xml.first("customerOwnedIp", false, x => x.content ?? ''),
      CustomerOwnedIpv4Pool: xml.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
      CarrierIp: xml.first("carrierIp", false, x => x.content ?? ''),
    };
  }

  async allocateHosts(
    {abortSignal, ...params}: RequestConfig & s.AllocateHostsRequest,
  ): Promise<s.AllocateHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoPlacement" in params) body.append(prefix+"AutoPlacement", (params["AutoPlacement"] ?? '').toString());
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("InstanceFamily" in params) body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    body.append(prefix+"Quantity", (params["Quantity"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("HostRecovery" in params) body.append(prefix+"HostRecovery", (params["HostRecovery"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostIds: xml.getList("hostIdSet", "item").map(x => x.content ?? ''),
    };
  }

  async applySecurityGroupsToClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & s.ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  ): Promise<s.ApplySecurityGroupsToClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplySecurityGroupsToClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroupIds: xml.getList("securityGroupIds", "item").map(x => x.content ?? ''),
    };
  }

  async assignIpv6Addresses(
    {abortSignal, ...params}: RequestConfig & s.AssignIpv6AddressesRequest,
  ): Promise<s.AssignIpv6AddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignIpv6Addresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssignedIpv6Addresses: xml.getList("assignedIpv6Addresses", "item").map(x => x.content ?? ''),
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
    };
  }

  async assignPrivateIpAddresses(
    {abortSignal, ...params}: RequestConfig & s.AssignPrivateIpAddressesRequest,
  ): Promise<s.AssignPrivateIpAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllowReassignment" in params) body.append(prefix+"AllowReassignment", (params["AllowReassignment"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddress", params["PrivateIpAddresses"], {"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+"SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignPrivateIpAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      AssignedPrivateIpAddresses: xml.getList("assignedPrivateIpAddressesSet", "item").map(AssignedPrivateIpAddress_Parse),
    };
  }

  async associateAddress(
    {abortSignal, ...params}: RequestConfig & s.AssociateAddressRequest = {},
  ): Promise<s.AssociateAddressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllocationId" in params) body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("AllowReassociation" in params) body.append(prefix+"AllowReassociation", (params["AllowReassociation"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateAddress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
    };
  }

  async associateClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & s.AssociateClientVpnTargetNetworkRequest,
  ): Promise<s.AssociateClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, AssociationStatus_Parse),
    };
  }

  async associateDhcpOptions(
    {abortSignal, ...params}: RequestConfig & s.AssociateDhcpOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DhcpOptionsId", (params["DhcpOptionsId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateDhcpOptions",
    });
  }

  async associateEnclaveCertificateIamRole(
    {abortSignal, ...params}: RequestConfig & s.AssociateEnclaveCertificateIamRoleRequest = {},
  ): Promise<s.AssociateEnclaveCertificateIamRoleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateArn" in params) body.append(prefix+"CertificateArn", (params["CertificateArn"] ?? '').toString());
    if ("RoleArn" in params) body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateEnclaveCertificateIamRole",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CertificateS3BucketName: xml.first("certificateS3BucketName", false, x => x.content ?? ''),
      CertificateS3ObjectKey: xml.first("certificateS3ObjectKey", false, x => x.content ?? ''),
      EncryptionKmsKeyId: xml.first("encryptionKmsKeyId", false, x => x.content ?? ''),
    };
  }

  async associateIamInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.AssociateIamInstanceProfileRequest,
  ): Promise<s.AssociateIamInstanceProfileResult> {
    const body = new URLSearchParams;
    const prefix = '';
    IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateIamInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async associateRouteTable(
    {abortSignal, ...params}: RequestConfig & s.AssociateRouteTableRequest,
  ): Promise<s.AssociateRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      AssociationState: xml.first("associationState", false, RouteTableAssociationState_Parse),
    };
  }

  async associateSubnetCidrBlock(
    {abortSignal, ...params}: RequestConfig & s.AssociateSubnetCidrBlockRequest,
  ): Promise<s.AssociateSubnetCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateSubnetCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, SubnetIpv6CidrBlockAssociation_Parse),
      SubnetId: xml.first("subnetId", false, x => x.content ?? ''),
    };
  }

  async associateTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & s.AssociateTransitGatewayMulticastDomainRequest = {},
  ): Promise<s.AssociateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async associateTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & s.AssociateTransitGatewayRouteTableRequest,
  ): Promise<s.AssociateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Association: xml.first("association", false, TransitGatewayAssociation_Parse),
    };
  }

  async associateVpcCidrBlock(
    {abortSignal, ...params}: RequestConfig & s.AssociateVpcCidrBlockRequest,
  ): Promise<s.AssociateVpcCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AmazonProvidedIpv6CidrBlock" in params) body.append(prefix+"AmazonProvidedIpv6CidrBlock", (params["AmazonProvidedIpv6CidrBlock"] ?? '').toString());
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("Ipv6CidrBlockNetworkBorderGroup" in params) body.append(prefix+"Ipv6CidrBlockNetworkBorderGroup", (params["Ipv6CidrBlockNetworkBorderGroup"] ?? '').toString());
    if ("Ipv6Pool" in params) body.append(prefix+"Ipv6Pool", (params["Ipv6Pool"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateVpcCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, VpcIpv6CidrBlockAssociation_Parse),
      CidrBlockAssociation: xml.first("cidrBlockAssociation", false, VpcCidrBlockAssociation_Parse),
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
    };
  }

  async attachClassicLinkVpc(
    {abortSignal, ...params}: RequestConfig & s.AttachClassicLinkVpcRequest,
  ): Promise<s.AttachClassicLinkVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachClassicLinkVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async attachInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.AttachInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachInternetGateway",
    });
  }

  async attachNetworkInterface(
    {abortSignal, ...params}: RequestConfig & s.AttachNetworkInterfaceRequest,
  ): Promise<s.AttachNetworkInterfaceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("NetworkCardIndex" in params) body.append(prefix+"NetworkCardIndex", (params["NetworkCardIndex"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachNetworkInterface",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AttachmentId: xml.first("attachmentId", false, x => x.content ?? ''),
      NetworkCardIndex: xml.first("networkCardIndex", false, x => parseInt(x.content ?? '0')),
    };
  }

  async attachVolume(
    {abortSignal, ...params}: RequestConfig & s.AttachVolumeRequest,
  ): Promise<s.VolumeAttachment> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Device", (params["Device"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return VolumeAttachment_Parse(xml);
  }

  async attachVpnGateway(
    {abortSignal, ...params}: RequestConfig & s.AttachVpnGatewayRequest,
  ): Promise<s.AttachVpnGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVpnGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcAttachment: xml.first("attachment", false, VpcAttachment_Parse),
    };
  }

  async authorizeClientVpnIngress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeClientVpnIngressRequest,
  ): Promise<s.AuthorizeClientVpnIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"TargetNetworkCidr", (params["TargetNetworkCidr"] ?? '').toString());
    if ("AccessGroupId" in params) body.append(prefix+"AccessGroupId", (params["AccessGroupId"] ?? '').toString());
    if ("AuthorizeAllGroups" in params) body.append(prefix+"AuthorizeAllGroups", (params["AuthorizeAllGroups"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeClientVpnIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
    };
  }

  async authorizeSecurityGroupEgress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeSecurityGroupEgressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"ipPermissions", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSecurityGroupEgress",
    });
  }

  async authorizeSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeSecurityGroupIngressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSecurityGroupIngress",
    });
  }

  async bundleInstance(
    {abortSignal, ...params}: RequestConfig & s.BundleInstanceRequest,
  ): Promise<s.BundleInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    Storage_Serialize(body, prefix+"Storage", params["Storage"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BundleInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTask: xml.first("bundleInstanceTask", false, BundleTask_Parse),
    };
  }

  async cancelBundleTask(
    {abortSignal, ...params}: RequestConfig & s.CancelBundleTaskRequest,
  ): Promise<s.CancelBundleTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BundleId", (params["BundleId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelBundleTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTask: xml.first("bundleInstanceTask", false, BundleTask_Parse),
    };
  }

  async cancelCapacityReservation(
    {abortSignal, ...params}: RequestConfig & s.CancelCapacityReservationRequest,
  ): Promise<s.CancelCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async cancelConversionTask(
    {abortSignal, ...params}: RequestConfig & s.CancelConversionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConversionTaskId", (params["ConversionTaskId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ReasonMessage" in params) body.append(prefix+"ReasonMessage", (params["ReasonMessage"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelConversionTask",
    });
  }

  async cancelExportTask(
    {abortSignal, ...params}: RequestConfig & s.CancelExportTaskRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportTaskId", (params["ExportTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelExportTask",
    });
  }

  async cancelImportTask(
    {abortSignal, ...params}: RequestConfig & s.CancelImportTaskRequest = {},
  ): Promise<s.CancelImportTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CancelReason" in params) body.append(prefix+"CancelReason", (params["CancelReason"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ImportTaskId" in params) body.append(prefix+"ImportTaskId", (params["ImportTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelImportTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      PreviousState: xml.first("previousState", false, x => x.content ?? ''),
      State: xml.first("state", false, x => x.content ?? ''),
    };
  }

  async cancelReservedInstancesListing(
    {abortSignal, ...params}: RequestConfig & s.CancelReservedInstancesListingRequest,
  ): Promise<s.CancelReservedInstancesListingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedInstancesListingId", (params["ReservedInstancesListingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelReservedInstancesListing",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async cancelSpotFleetRequests(
    {abortSignal, ...params}: RequestConfig & s.CancelSpotFleetRequestsRequest,
  ): Promise<s.CancelSpotFleetRequestsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotFleetRequestIds"]) qsP.appendList(body, prefix+"spotFleetRequestId", params["SpotFleetRequestIds"], {"entryPrefix":"."})
    body.append(prefix+"TerminateInstances", (params["TerminateInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSpotFleetRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulFleetRequests: xml.getList("successfulFleetRequestSet", "item").map(CancelSpotFleetRequestsSuccessItem_Parse),
      UnsuccessfulFleetRequests: xml.getList("unsuccessfulFleetRequestSet", "item").map(CancelSpotFleetRequestsErrorItem_Parse),
    };
  }

  async cancelSpotInstanceRequests(
    {abortSignal, ...params}: RequestConfig & s.CancelSpotInstanceRequestsRequest,
  ): Promise<s.CancelSpotInstanceRequestsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotInstanceRequestIds"]) qsP.appendList(body, prefix+"SpotInstanceRequestId", params["SpotInstanceRequestIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSpotInstanceRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CancelledSpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(CancelledSpotInstanceRequest_Parse),
    };
  }

  async confirmProductInstance(
    {abortSignal, ...params}: RequestConfig & s.ConfirmProductInstanceRequest,
  ): Promise<s.ConfirmProductInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"ProductCode", (params["ProductCode"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmProductInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      OwnerId: xml.first("ownerId", false, x => x.content ?? ''),
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async copyFpgaImage(
    {abortSignal, ...params}: RequestConfig & s.CopyFpgaImageRequest,
  ): Promise<s.CopyFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"SourceFpgaImageId", (params["SourceFpgaImageId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageId: xml.first("fpgaImageId", false, x => x.content ?? ''),
    };
  }

  async copyImage(
    {abortSignal, ...params}: RequestConfig & s.CopyImageRequest,
  ): Promise<s.CopyImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    body.append(prefix+"SourceImageId", (params["SourceImageId"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    if ("DestinationOutpostArn" in params) body.append(prefix+"DestinationOutpostArn", (params["DestinationOutpostArn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async copySnapshot(
    {abortSignal, ...params}: RequestConfig & s.CopySnapshotRequest,
  ): Promise<s.CopySnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DestinationOutpostArn" in params) body.append(prefix+"DestinationOutpostArn", (params["DestinationOutpostArn"] ?? '').toString());
    if ("DestinationRegion" in params) body.append(prefix+"DestinationRegion", (params["DestinationRegion"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PresignedUrl" in params) body.append(prefix+"PresignedUrl", (params["PresignedUrl"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    body.append(prefix+"SourceSnapshotId", (params["SourceSnapshotId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopySnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SnapshotId: xml.first("snapshotId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createCapacityReservation(
    {abortSignal, ...params}: RequestConfig & s.CreateCapacityReservationRequest,
  ): Promise<s.CreateCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    body.append(prefix+"InstancePlatform", (params["InstancePlatform"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AvailabilityZoneId" in params) body.append(prefix+"AvailabilityZoneId", (params["AvailabilityZoneId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+"Tenancy", (params["Tenancy"] ?? '').toString());
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if ("EphemeralStorage" in params) body.append(prefix+"EphemeralStorage", (params["EphemeralStorage"] ?? '').toString());
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("EndDateType" in params) body.append(prefix+"EndDateType", (params["EndDateType"] ?? '').toString());
    if ("InstanceMatchCriteria" in params) body.append(prefix+"InstanceMatchCriteria", (params["InstanceMatchCriteria"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CapacityReservation: xml.first("capacityReservation", false, CapacityReservation_Parse),
    };
  }

  async createCarrierGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateCarrierGatewayRequest,
  ): Promise<s.CreateCarrierGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCarrierGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateway: xml.first("carrierGateway", false, CarrierGateway_Parse),
    };
  }

  async createClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateClientVpnEndpointRequest,
  ): Promise<s.CreateClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientCidrBlock", (params["ClientCidrBlock"] ?? '').toString());
    body.append(prefix+"ServerCertificateArn", (params["ServerCertificateArn"] ?? '').toString());
    if (params["AuthenticationOptions"]) qsP.appendList(body, prefix+"Authentication", params["AuthenticationOptions"], {"appender":ClientVpnAuthenticationRequest_Serialize,"entryPrefix":"."})
    ConnectionLogOptions_Serialize(body, prefix+"ConnectionLogOptions", params["ConnectionLogOptions"]);
    if (params["DnsServers"]) qsP.appendList(body, prefix+"item", params["DnsServers"], {"entryPrefix":"."})
    if ("TransportProtocol" in params) body.append(prefix+"TransportProtocol", (params["TransportProtocol"] ?? '').toString());
    if ("VpnPort" in params) body.append(prefix+"VpnPort", (params["VpnPort"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("SplitTunnel" in params) body.append(prefix+"SplitTunnel", (params["SplitTunnel"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("SelfServicePortal" in params) body.append(prefix+"SelfServicePortal", (params["SelfServicePortal"] ?? '').toString());
    if (params["ClientConnectOptions"] != null) ClientConnectOptions_Serialize(body, prefix+"ClientConnectOptions", params["ClientConnectOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpointId: xml.first("clientVpnEndpointId", false, x => x.content ?? ''),
      Status: xml.first("status", false, ClientVpnEndpointStatus_Parse),
      DnsName: xml.first("dnsName", false, x => x.content ?? ''),
    };
  }

  async createClientVpnRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateClientVpnRouteRequest,
  ): Promise<s.CreateClientVpnRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TargetVpcSubnetId", (params["TargetVpcSubnetId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClientVpnRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnRouteStatus_Parse),
    };
  }

  async createCustomerGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomerGatewayRequest,
  ): Promise<s.CreateCustomerGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BgpAsn", (params["BgpAsn"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"IpAddress", (params["PublicIp"] ?? '').toString());
    if ("CertificateArn" in params) body.append(prefix+"CertificateArn", (params["CertificateArn"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DeviceName" in params) body.append(prefix+"DeviceName", (params["DeviceName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomerGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CustomerGateway: xml.first("customerGateway", false, CustomerGateway_Parse),
    };
  }

  async createDefaultSubnet(
    {abortSignal, ...params}: RequestConfig & s.CreateDefaultSubnetRequest,
  ): Promise<s.CreateDefaultSubnetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDefaultSubnet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnet: xml.first("subnet", false, Subnet_Parse),
    };
  }

  async createDefaultVpc(
    {abortSignal, ...params}: RequestConfig & s.CreateDefaultVpcRequest = {},
  ): Promise<s.CreateDefaultVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDefaultVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpc: xml.first("vpc", false, Vpc_Parse),
    };
  }

  async createDhcpOptions(
    {abortSignal, ...params}: RequestConfig & s.CreateDhcpOptionsRequest,
  ): Promise<s.CreateDhcpOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DhcpConfigurations"]) qsP.appendList(body, prefix+"dhcpConfiguration", params["DhcpConfigurations"], {"appender":NewDhcpConfiguration_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDhcpOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DhcpOptions: xml.first("dhcpOptions", false, DhcpOptions_Parse),
    };
  }

  async createEgressOnlyInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateEgressOnlyInternetGatewayRequest,
  ): Promise<s.CreateEgressOnlyInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEgressOnlyInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      EgressOnlyInternetGateway: xml.first("egressOnlyInternetGateway", false, EgressOnlyInternetGateway_Parse),
    };
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & s.CreateFleetRequest,
  ): Promise<s.CreateFleetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["SpotOptions"] != null) SpotOptionsRequest_Serialize(body, prefix+"SpotOptions", params["SpotOptions"]);
    if (params["OnDemandOptions"] != null) OnDemandOptionsRequest_Serialize(body, prefix+"OnDemandOptions", params["OnDemandOptions"]);
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"item", params["LaunchTemplateConfigs"], {"appender":FleetLaunchTemplateConfigRequest_Serialize,"entryPrefix":"."})
    TargetCapacitySpecificationRequest_Serialize(body, prefix+"TargetCapacitySpecification", params["TargetCapacitySpecification"]);
    if ("TerminateInstancesWithExpiration" in params) body.append(prefix+"TerminateInstancesWithExpiration", (params["TerminateInstancesWithExpiration"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+"ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+"ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("ReplaceUnhealthyInstances" in params) body.append(prefix+"ReplaceUnhealthyInstances", (params["ReplaceUnhealthyInstances"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
      Errors: xml.getList("errorSet", "item").map(CreateFleetError_Parse),
      Instances: xml.getList("fleetInstanceSet", "item").map(CreateFleetInstance_Parse),
    };
  }

  async createFlowLogs(
    {abortSignal, ...params}: RequestConfig & s.CreateFlowLogsRequest,
  ): Promise<s.CreateFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DeliverLogsPermissionArn" in params) body.append(prefix+"DeliverLogsPermissionArn", (params["DeliverLogsPermissionArn"] ?? '').toString());
    if ("LogGroupName" in params) body.append(prefix+"LogGroupName", (params["LogGroupName"] ?? '').toString());
    if (params["ResourceIds"]) qsP.appendList(body, prefix+"ResourceId", params["ResourceIds"], {"entryPrefix":"."})
    body.append(prefix+"ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+"TrafficType", (params["TrafficType"] ?? '').toString());
    if ("LogDestinationType" in params) body.append(prefix+"LogDestinationType", (params["LogDestinationType"] ?? '').toString());
    if ("LogDestination" in params) body.append(prefix+"LogDestination", (params["LogDestination"] ?? '').toString());
    if ("LogFormat" in params) body.append(prefix+"LogFormat", (params["LogFormat"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("MaxAggregationInterval" in params) body.append(prefix+"MaxAggregationInterval", (params["MaxAggregationInterval"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      FlowLogIds: xml.getList("flowLogIdSet", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async createFpgaImage(
    {abortSignal, ...params}: RequestConfig & s.CreateFpgaImageRequest,
  ): Promise<s.CreateFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    StorageLocation_Serialize(body, prefix+"InputStorageLocation", params["InputStorageLocation"]);
    if (params["LogsStorageLocation"] != null) StorageLocation_Serialize(body, prefix+"LogsStorageLocation", params["LogsStorageLocation"]);
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageId: xml.first("fpgaImageId", false, x => x.content ?? ''),
      FpgaImageGlobalId: xml.first("fpgaImageGlobalId", false, x => x.content ?? ''),
    };
  }

  async createImage(
    {abortSignal, ...params}: RequestConfig & s.CreateImageRequest,
  ): Promise<s.CreateImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("NoReboot" in params) body.append(prefix+"NoReboot", (params["NoReboot"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async createInstanceExportTask(
    {abortSignal, ...params}: RequestConfig & s.CreateInstanceExportTaskRequest,
  ): Promise<s.CreateInstanceExportTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    ExportToS3TaskSpecification_Serialize(body, prefix+"ExportToS3", params["ExportToS3Task"]);
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"TargetEnvironment", (params["TargetEnvironment"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstanceExportTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportTask: xml.first("exportTask", false, ExportTask_Parse),
    };
  }

  async createInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateInternetGatewayRequest = {},
  ): Promise<s.CreateInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InternetGateway: xml.first("internetGateway", false, InternetGateway_Parse),
    };
  }

  async createKeyPair(
    {abortSignal, ...params}: RequestConfig & s.CreateKeyPairRequest,
  ): Promise<s.KeyPair> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeyPair",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyFingerprint: xml.first("keyFingerprint", false, x => x.content ?? ''),
      KeyMaterial: xml.first("keyMaterial", false, x => x.content ?? ''),
      KeyName: xml.first("keyName", false, x => x.content ?? ''),
      KeyPairId: xml.first("keyPairId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateLaunchTemplateRequest,
  ): Promise<s.CreateLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("VersionDescription" in params) body.append(prefix+"VersionDescription", (params["VersionDescription"] ?? '').toString());
    RequestLaunchTemplateData_Serialize(body, prefix+"LaunchTemplateData", params["LaunchTemplateData"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
      Warning: xml.first("warning", false, ValidationWarning_Parse),
    };
  }

  async createLaunchTemplateVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateLaunchTemplateVersionRequest,
  ): Promise<s.CreateLaunchTemplateVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("SourceVersion" in params) body.append(prefix+"SourceVersion", (params["SourceVersion"] ?? '').toString());
    if ("VersionDescription" in params) body.append(prefix+"VersionDescription", (params["VersionDescription"] ?? '').toString());
    RequestLaunchTemplateData_Serialize(body, prefix+"LaunchTemplateData", params["LaunchTemplateData"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchTemplateVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateVersion: xml.first("launchTemplateVersion", false, LaunchTemplateVersion_Parse),
      Warning: xml.first("warning", false, ValidationWarning_Parse),
    };
  }

  async createLocalGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateLocalGatewayRouteRequest,
  ): Promise<s.CreateLocalGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"LocalGatewayVirtualInterfaceGroupId", (params["LocalGatewayVirtualInterfaceGroupId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLocalGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, LocalGatewayRoute_Parse),
    };
  }

  async createLocalGatewayRouteTableVpcAssociation(
    {abortSignal, ...params}: RequestConfig & s.CreateLocalGatewayRouteTableVpcAssociationRequest,
  ): Promise<s.CreateLocalGatewayRouteTableVpcAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLocalGatewayRouteTableVpcAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociation: xml.first("localGatewayRouteTableVpcAssociation", false, LocalGatewayRouteTableVpcAssociation_Parse),
    };
  }

  async createManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & s.CreateManagedPrefixListRequest,
  ): Promise<s.CreateManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListName", (params["PrefixListName"] ?? '').toString());
    if (params["Entries"]) qsP.appendList(body, prefix+"Entry", params["Entries"], {"appender":AddPrefixListEntry_Serialize,"entryPrefix":"."})
    body.append(prefix+"MaxEntries", (params["MaxEntries"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    body.append(prefix+"AddressFamily", (params["AddressFamily"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async createNatGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateNatGatewayRequest,
  ): Promise<s.CreateNatGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNatGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      NatGateway: xml.first("natGateway", false, NatGateway_Parse),
    };
  }

  async createNetworkAcl(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkAclRequest,
  ): Promise<s.CreateNetworkAclResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkAcl",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkAcl: xml.first("networkAcl", false, NetworkAcl_Parse),
    };
  }

  async createNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    if (params["IcmpTypeCode"] != null) IcmpTypeCode_Serialize(body, prefix+"Icmp", params["IcmpTypeCode"]);
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    if (params["PortRange"] != null) PortRange_Serialize(body, prefix+"PortRange", params["PortRange"]);
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkAclEntry",
    });
  }

  async createNetworkInsightsPath(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkInsightsPathRequest,
  ): Promise<s.CreateNetworkInsightsPathResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIp" in params) body.append(prefix+"SourceIp", (params["SourceIp"] ?? '').toString());
    if ("DestinationIp" in params) body.append(prefix+"DestinationIp", (params["DestinationIp"] ?? '').toString());
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    body.append(prefix+"Destination", (params["Destination"] ?? '').toString());
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("DestinationPort" in params) body.append(prefix+"DestinationPort", (params["DestinationPort"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkInsightsPath",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsPath: xml.first("networkInsightsPath", false, NetworkInsightsPath_Parse),
    };
  }

  async createNetworkInterface(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkInterfaceRequest,
  ): Promise<s.CreateNetworkInterfaceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddresses", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+"SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("InterfaceType" in params) body.append(prefix+"InterfaceType", (params["InterfaceType"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkInterface",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterface: xml.first("networkInterface", false, NetworkInterface_Parse),
    };
  }

  async createNetworkInterfacePermission(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkInterfacePermissionRequest,
  ): Promise<s.CreateNetworkInterfacePermissionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("AwsAccountId" in params) body.append(prefix+"AwsAccountId", (params["AwsAccountId"] ?? '').toString());
    if ("AwsService" in params) body.append(prefix+"AwsService", (params["AwsService"] ?? '').toString());
    body.append(prefix+"Permission", (params["Permission"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkInterfacePermission",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InterfacePermission: xml.first("interfacePermission", false, NetworkInterfacePermission_Parse),
    };
  }

  async createPlacementGroup(
    {abortSignal, ...params}: RequestConfig & s.CreatePlacementGroupRequest = {},
  ): Promise<s.CreatePlacementGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Strategy" in params) body.append(prefix+"Strategy", (params["Strategy"] ?? '').toString());
    if ("PartitionCount" in params) body.append(prefix+"PartitionCount", (params["PartitionCount"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlacementGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PlacementGroup: xml.first("placementGroup", false, PlacementGroup_Parse),
    };
  }

  async createReservedInstancesListing(
    {abortSignal, ...params}: RequestConfig & s.CreateReservedInstancesListingRequest,
  ): Promise<s.CreateReservedInstancesListingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if (params["PriceSchedules"]) qsP.appendList(body, prefix+"priceSchedules", params["PriceSchedules"], {"appender":PriceScheduleSpecification_Serialize,"entryPrefix":"."})
    body.append(prefix+"ReservedInstancesId", (params["ReservedInstancesId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReservedInstancesListing",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async createRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateRouteRequest,
  ): Promise<s.CreateRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcEndpointId" in params) body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    if ("EgressOnlyInternetGatewayId" in params) body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("NatGatewayId" in params) body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("LocalGatewayId" in params) body.append(prefix+"LocalGatewayId", (params["LocalGatewayId"] ?? '').toString());
    if ("CarrierGatewayId" in params) body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async createRouteTable(
    {abortSignal, ...params}: RequestConfig & s.CreateRouteTableRequest,
  ): Promise<s.CreateRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RouteTable: xml.first("routeTable", false, RouteTable_Parse),
    };
  }

  async createSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateSecurityGroupRequest,
  ): Promise<s.CreateSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupDescription", (params["Description"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      GroupId: xml.first("groupId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotRequest,
  ): Promise<s.Snapshot> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Snapshot_Parse(xml);
  }

  async createSnapshots(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotsRequest,
  ): Promise<s.CreateSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    InstanceSpecification_Serialize(body, prefix+"InstanceSpecification", params["InstanceSpecification"]);
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("CopyTagsFromSource" in params) body.append(prefix+"CopyTagsFromSource", (params["CopyTagsFromSource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Snapshots: xml.getList("snapshotSet", "item").map(SnapshotInfo_Parse),
    };
  }

  async createSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateSpotDatafeedSubscriptionRequest,
  ): Promise<s.CreateSpotDatafeedSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Bucket", (params["Bucket"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Prefix" in params) body.append(prefix+"Prefix", (params["Prefix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSpotDatafeedSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotDatafeedSubscription: xml.first("spotDatafeedSubscription", false, SpotDatafeedSubscription_Parse),
    };
  }

  async createSubnet(
    {abortSignal, ...params}: RequestConfig & s.CreateSubnetRequest,
  ): Promise<s.CreateSubnetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AvailabilityZoneId" in params) body.append(prefix+"AvailabilityZoneId", (params["AvailabilityZoneId"] ?? '').toString());
    body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSubnet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnet: xml.first("subnet", false, Subnet_Parse),
    };
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & s.CreateTagsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"ResourceId", params["Resources"], {"entryPrefix":"."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
    });
  }

  async createTrafficMirrorFilter(
    {abortSignal, ...params}: RequestConfig & s.CreateTrafficMirrorFilterRequest = {},
  ): Promise<s.CreateTrafficMirrorFilterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorFilter",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilter: xml.first("trafficMirrorFilter", false, TrafficMirrorFilter_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & s.CreateTrafficMirrorFilterRuleRequest,
  ): Promise<s.CreateTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    body.append(prefix+"TrafficDirection", (params["TrafficDirection"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    if (params["DestinationPortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"DestinationPortRange", params["DestinationPortRange"]);
    if (params["SourcePortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"SourcePortRange", params["SourcePortRange"]);
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"SourceCidrBlock", (params["SourceCidrBlock"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRule: xml.first("trafficMirrorFilterRule", false, TrafficMirrorFilterRule_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & s.CreateTrafficMirrorSessionRequest,
  ): Promise<s.CreateTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("PacketLength" in params) body.append(prefix+"PacketLength", (params["PacketLength"] ?? '').toString());
    body.append(prefix+"SessionNumber", (params["SessionNumber"] ?? '').toString());
    if ("VirtualNetworkId" in params) body.append(prefix+"VirtualNetworkId", (params["VirtualNetworkId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSession: xml.first("trafficMirrorSession", false, TrafficMirrorSession_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorTarget(
    {abortSignal, ...params}: RequestConfig & s.CreateTrafficMirrorTargetRequest = {},
  ): Promise<s.CreateTrafficMirrorTargetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("NetworkLoadBalancerArn" in params) body.append(prefix+"NetworkLoadBalancerArn", (params["NetworkLoadBalancerArn"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorTarget",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTarget: xml.first("trafficMirrorTarget", false, TrafficMirrorTarget_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTransitGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayRequest = {},
  ): Promise<s.CreateTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Options"] != null) TransitGatewayRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async createTransitGatewayConnect(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayConnectRequest,
  ): Promise<s.CreateTransitGatewayConnectResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransportTransitGatewayAttachmentId", (params["TransportTransitGatewayAttachmentId"] ?? '').toString());
    CreateTransitGatewayConnectRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayConnect",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnect: xml.first("transitGatewayConnect", false, TransitGatewayConnect_Parse),
    };
  }

  async createTransitGatewayConnectPeer(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayConnectPeerRequest,
  ): Promise<s.CreateTransitGatewayConnectPeerResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("TransitGatewayAddress" in params) body.append(prefix+"TransitGatewayAddress", (params["TransitGatewayAddress"] ?? '').toString());
    body.append(prefix+"PeerAddress", (params["PeerAddress"] ?? '').toString());
    if (params["BgpOptions"] != null) TransitGatewayConnectRequestBgpOptions_Serialize(body, prefix+"BgpOptions", params["BgpOptions"]);
    if (params["InsideCidrBlocks"]) qsP.appendList(body, prefix+"item", params["InsideCidrBlocks"], {"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayConnectPeer",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnectPeer: xml.first("transitGatewayConnectPeer", false, TransitGatewayConnectPeer_Parse),
    };
  }

  async createTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayMulticastDomainRequest,
  ): Promise<s.CreateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if (params["Options"] != null) CreateTransitGatewayMulticastDomainRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomain: xml.first("transitGatewayMulticastDomain", false, TransitGatewayMulticastDomain_Parse),
    };
  }

  async createTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayPeeringAttachmentRequest,
  ): Promise<s.CreateTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    body.append(prefix+"PeerTransitGatewayId", (params["PeerTransitGatewayId"] ?? '').toString());
    body.append(prefix+"PeerAccountId", (params["PeerAccountId"] ?? '').toString());
    body.append(prefix+"PeerRegion", (params["PeerRegion"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async createTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayPrefixListReferenceRequest,
  ): Promise<s.CreateTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async createTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayRouteRequest,
  ): Promise<s.CreateTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async createTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayRouteTableRequest,
  ): Promise<s.CreateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTable: xml.first("transitGatewayRouteTable", false, TransitGatewayRouteTable_Parse),
    };
  }

  async createTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitGatewayVpcAttachmentRequest,
  ): Promise<s.CreateTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if (params["Options"] != null) CreateTransitGatewayVpcAttachmentRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async createVolume(
    {abortSignal, ...params}: RequestConfig & s.CreateVolumeRequest,
  ): Promise<s.Volume> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    if ("Size" in params) body.append(prefix+"Size", (params["Size"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+"VolumeType", (params["VolumeType"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("MultiAttachEnabled" in params) body.append(prefix+"MultiAttachEnabled", (params["MultiAttachEnabled"] ?? '').toString());
    if ("Throughput" in params) body.append(prefix+"Throughput", (params["Throughput"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Volume_Parse(xml);
  }

  async createVpc(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcRequest,
  ): Promise<s.CreateVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("AmazonProvidedIpv6CidrBlock" in params) body.append(prefix+"AmazonProvidedIpv6CidrBlock", (params["AmazonProvidedIpv6CidrBlock"] ?? '').toString());
    if ("Ipv6Pool" in params) body.append(prefix+"Ipv6Pool", (params["Ipv6Pool"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceTenancy" in params) body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("Ipv6CidrBlockNetworkBorderGroup" in params) body.append(prefix+"Ipv6CidrBlockNetworkBorderGroup", (params["Ipv6CidrBlockNetworkBorderGroup"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpc: xml.first("vpc", false, Vpc_Parse),
    };
  }

  async createVpcEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcEndpointRequest,
  ): Promise<s.CreateVpcEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcEndpointType" in params) body.append(prefix+"VpcEndpointType", (params["VpcEndpointType"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    if ("PolicyDocument" in params) body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if (params["RouteTableIds"]) qsP.appendList(body, prefix+"RouteTableId", params["RouteTableIds"], {"entryPrefix":"."})
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetId", params["SubnetIds"], {"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("PrivateDnsEnabled" in params) body.append(prefix+"PrivateDnsEnabled", (params["PrivateDnsEnabled"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpoint: xml.first("vpcEndpoint", false, VpcEndpoint_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcEndpointConnectionNotification(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcEndpointConnectionNotificationRequest,
  ): Promise<s.CreateVpcEndpointConnectionNotificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ServiceId" in params) body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if ("VpcEndpointId" in params) body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    body.append(prefix+"ConnectionNotificationArn", (params["ConnectionNotificationArn"] ?? '').toString());
    if (params["ConnectionEvents"]) qsP.appendList(body, prefix+"item", params["ConnectionEvents"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpointConnectionNotification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConnectionNotification: xml.first("connectionNotification", false, ConnectionNotification_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcEndpointServiceConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcEndpointServiceConfigurationRequest = {},
  ): Promise<s.CreateVpcEndpointServiceConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("AcceptanceRequired" in params) body.append(prefix+"AcceptanceRequired", (params["AcceptanceRequired"] ?? '').toString());
    if ("PrivateDnsName" in params) body.append(prefix+"PrivateDnsName", (params["PrivateDnsName"] ?? '').toString());
    if (params["NetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"NetworkLoadBalancerArn", params["NetworkLoadBalancerArns"], {"entryPrefix":"."})
    if (params["GatewayLoadBalancerArns"]) qsP.appendList(body, prefix+"GatewayLoadBalancerArn", params["GatewayLoadBalancerArns"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpointServiceConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceConfiguration: xml.first("serviceConfiguration", false, ServiceConfiguration_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcPeeringConnectionRequest = {},
  ): Promise<s.CreateVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("PeerOwnerId" in params) body.append(prefix+"PeerOwnerId", (params["PeerOwnerId"] ?? '').toString());
    if ("PeerVpcId" in params) body.append(prefix+"PeerVpcId", (params["PeerVpcId"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("PeerRegion" in params) body.append(prefix+"PeerRegion", (params["PeerRegion"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnection: xml.first("vpcPeeringConnection", false, VpcPeeringConnection_Parse),
    };
  }

  async createVpnConnection(
    {abortSignal, ...params}: RequestConfig & s.CreateVpnConnectionRequest,
  ): Promise<s.CreateVpnConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("VpnGatewayId" in params) body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Options"] != null) VpnConnectionOptionsSpecification_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async createVpnConnectionRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateVpnConnectionRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnConnectionRoute",
    });
  }

  async createVpnGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateVpnGatewayRequest,
  ): Promise<s.CreateVpnGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("AmazonSideAsn" in params) body.append(prefix+"AmazonSideAsn", (params["AmazonSideAsn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnGateway: xml.first("vpnGateway", false, VpnGateway_Parse),
    };
  }

  async deleteCarrierGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteCarrierGatewayRequest,
  ): Promise<s.DeleteCarrierGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCarrierGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateway: xml.first("carrierGateway", false, CarrierGateway_Parse),
    };
  }

  async deleteClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteClientVpnEndpointRequest,
  ): Promise<s.DeleteClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnEndpointStatus_Parse),
    };
  }

  async deleteClientVpnRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteClientVpnRouteRequest,
  ): Promise<s.DeleteClientVpnRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("TargetVpcSubnetId" in params) body.append(prefix+"TargetVpcSubnetId", (params["TargetVpcSubnetId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClientVpnRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnRouteStatus_Parse),
    };
  }

  async deleteCustomerGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomerGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomerGateway",
    });
  }

  async deleteDhcpOptions(
    {abortSignal, ...params}: RequestConfig & s.DeleteDhcpOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DhcpOptionsId", (params["DhcpOptionsId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDhcpOptions",
    });
  }

  async deleteEgressOnlyInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteEgressOnlyInternetGatewayRequest,
  ): Promise<s.DeleteEgressOnlyInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEgressOnlyInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnCode: xml.first("returnCode", false, x => x.content === 'true'),
    };
  }

  async deleteFleets(
    {abortSignal, ...params}: RequestConfig & s.DeleteFleetsRequest,
  ): Promise<s.DeleteFleetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FleetIds"]) qsP.appendList(body, prefix+"FleetId", params["FleetIds"], {"entryPrefix":"."})
    body.append(prefix+"TerminateInstances", (params["TerminateInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulFleetDeletions: xml.getList("successfulFleetDeletionSet", "item").map(DeleteFleetSuccessItem_Parse),
      UnsuccessfulFleetDeletions: xml.getList("unsuccessfulFleetDeletionSet", "item").map(DeleteFleetErrorItem_Parse),
    };
  }

  async deleteFlowLogs(
    {abortSignal, ...params}: RequestConfig & s.DeleteFlowLogsRequest,
  ): Promise<s.DeleteFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FlowLogIds"]) qsP.appendList(body, prefix+"FlowLogId", params["FlowLogIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteFpgaImage(
    {abortSignal, ...params}: RequestConfig & s.DeleteFpgaImageRequest,
  ): Promise<s.DeleteFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deleteInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInternetGateway",
    });
  }

  async deleteKeyPair(
    {abortSignal, ...params}: RequestConfig & s.DeleteKeyPairRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if ("KeyPairId" in params) body.append(prefix+"KeyPairId", (params["KeyPairId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteKeyPair",
    });
  }

  async deleteLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteLaunchTemplateRequest = {},
  ): Promise<s.DeleteLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
    };
  }

  async deleteLaunchTemplateVersions(
    {abortSignal, ...params}: RequestConfig & s.DeleteLaunchTemplateVersionsRequest,
  ): Promise<s.DeleteLaunchTemplateVersionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if (params["Versions"]) qsP.appendList(body, prefix+"LaunchTemplateVersion", params["Versions"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchTemplateVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfullyDeletedLaunchTemplateVersions: xml.getList("successfullyDeletedLaunchTemplateVersionSet", "item").map(DeleteLaunchTemplateVersionsResponseSuccessItem_Parse),
      UnsuccessfullyDeletedLaunchTemplateVersions: xml.getList("unsuccessfullyDeletedLaunchTemplateVersionSet", "item").map(DeleteLaunchTemplateVersionsResponseErrorItem_Parse),
    };
  }

  async deleteLocalGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteLocalGatewayRouteRequest,
  ): Promise<s.DeleteLocalGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLocalGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, LocalGatewayRoute_Parse),
    };
  }

  async deleteLocalGatewayRouteTableVpcAssociation(
    {abortSignal, ...params}: RequestConfig & s.DeleteLocalGatewayRouteTableVpcAssociationRequest,
  ): Promise<s.DeleteLocalGatewayRouteTableVpcAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableVpcAssociationId", (params["LocalGatewayRouteTableVpcAssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLocalGatewayRouteTableVpcAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociation: xml.first("localGatewayRouteTableVpcAssociation", false, LocalGatewayRouteTableVpcAssociation_Parse),
    };
  }

  async deleteManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & s.DeleteManagedPrefixListRequest,
  ): Promise<s.DeleteManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async deleteNatGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteNatGatewayRequest,
  ): Promise<s.DeleteNatGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNatGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NatGatewayId: xml.first("natGatewayId", false, x => x.content ?? ''),
    };
  }

  async deleteNetworkAcl(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkAclRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkAcl",
    });
  }

  async deleteNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkAclEntry",
    });
  }

  async deleteNetworkInsightsAnalysis(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkInsightsAnalysisRequest,
  ): Promise<s.DeleteNetworkInsightsAnalysisResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInsightsAnalysisId", (params["NetworkInsightsAnalysisId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInsightsAnalysis",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsAnalysisId: xml.first("networkInsightsAnalysisId", false, x => x.content ?? ''),
    };
  }

  async deleteNetworkInsightsPath(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkInsightsPathRequest,
  ): Promise<s.DeleteNetworkInsightsPathResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInsightsPathId", (params["NetworkInsightsPathId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInsightsPath",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsPathId: xml.first("networkInsightsPathId", false, x => x.content ?? ''),
    };
  }

  async deleteNetworkInterface(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkInterfaceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInterface",
    });
  }

  async deleteNetworkInterfacePermission(
    {abortSignal, ...params}: RequestConfig & s.DeleteNetworkInterfacePermissionRequest,
  ): Promise<s.DeleteNetworkInterfacePermissionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfacePermissionId", (params["NetworkInterfacePermissionId"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInterfacePermission",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deletePlacementGroup(
    {abortSignal, ...params}: RequestConfig & s.DeletePlacementGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePlacementGroup",
    });
  }

  async deleteQueuedReservedInstances(
    {abortSignal, ...params}: RequestConfig & s.DeleteQueuedReservedInstancesRequest,
  ): Promise<s.DeleteQueuedReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteQueuedReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulQueuedPurchaseDeletions: xml.getList("successfulQueuedPurchaseDeletionSet", "item").map(SuccessfulQueuedPurchaseDeletion_Parse),
      FailedQueuedPurchaseDeletions: xml.getList("failedQueuedPurchaseDeletionSet", "item").map(FailedQueuedPurchaseDeletion_Parse),
    };
  }

  async deleteRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRoute",
    });
  }

  async deleteRouteTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteTableRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRouteTable",
    });
  }

  async deleteSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteSecurityGroupRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityGroup",
    });
  }

  async deleteSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshot",
    });
  }

  async deleteSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteSpotDatafeedSubscriptionRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSpotDatafeedSubscription",
    });
  }

  async deleteSubnet(
    {abortSignal, ...params}: RequestConfig & s.DeleteSubnetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSubnet",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"resourceId", params["Resources"], {"entryPrefix":"."})
    if (params["Tags"]) qsP.appendList(body, prefix+"tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
  }

  async deleteTrafficMirrorFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrafficMirrorFilterRequest,
  ): Promise<s.DeleteTrafficMirrorFilterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorFilter",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterId: xml.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrafficMirrorFilterRuleRequest,
  ): Promise<s.DeleteTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterRuleId", (params["TrafficMirrorFilterRuleId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRuleId: xml.first("trafficMirrorFilterRuleId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrafficMirrorSessionRequest,
  ): Promise<s.DeleteTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorSessionId", (params["TrafficMirrorSessionId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSessionId: xml.first("trafficMirrorSessionId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorTarget(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrafficMirrorTargetRequest,
  ): Promise<s.DeleteTrafficMirrorTargetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorTarget",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTargetId: xml.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    };
  }

  async deleteTransitGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayRequest,
  ): Promise<s.DeleteTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async deleteTransitGatewayConnect(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayConnectRequest,
  ): Promise<s.DeleteTransitGatewayConnectResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayConnect",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnect: xml.first("transitGatewayConnect", false, TransitGatewayConnect_Parse),
    };
  }

  async deleteTransitGatewayConnectPeer(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayConnectPeerRequest,
  ): Promise<s.DeleteTransitGatewayConnectPeerResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayConnectPeerId", (params["TransitGatewayConnectPeerId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayConnectPeer",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnectPeer: xml.first("transitGatewayConnectPeer", false, TransitGatewayConnectPeer_Parse),
    };
  }

  async deleteTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayMulticastDomainRequest,
  ): Promise<s.DeleteTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomain: xml.first("transitGatewayMulticastDomain", false, TransitGatewayMulticastDomain_Parse),
    };
  }

  async deleteTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayPeeringAttachmentRequest,
  ): Promise<s.DeleteTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async deleteTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayPrefixListReferenceRequest,
  ): Promise<s.DeleteTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async deleteTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayRouteRequest,
  ): Promise<s.DeleteTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async deleteTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayRouteTableRequest,
  ): Promise<s.DeleteTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTable: xml.first("transitGatewayRouteTable", false, TransitGatewayRouteTable_Parse),
    };
  }

  async deleteTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & s.DeleteTransitGatewayVpcAttachmentRequest,
  ): Promise<s.DeleteTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async deleteVolume(
    {abortSignal, ...params}: RequestConfig & s.DeleteVolumeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVolume",
    });
  }

  async deleteVpc(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpc",
    });
  }

  async deleteVpcEndpointConnectionNotifications(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcEndpointConnectionNotificationsRequest,
  ): Promise<s.DeleteVpcEndpointConnectionNotificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ConnectionNotificationIds"]) qsP.appendList(body, prefix+"ConnectionNotificationId", params["ConnectionNotificationIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpointConnectionNotifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcEndpointServiceConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcEndpointServiceConfigurationsRequest,
  ): Promise<s.DeleteVpcEndpointServiceConfigurationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceIds"]) qsP.appendList(body, prefix+"ServiceId", params["ServiceIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpointServiceConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcEndpointsRequest,
  ): Promise<s.DeleteVpcEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcPeeringConnectionRequest,
  ): Promise<s.DeleteVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deleteVpnConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpnConnectionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnConnection",
    });
  }

  async deleteVpnConnectionRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpnConnectionRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnConnectionRoute",
    });
  }

  async deleteVpnGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpnGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnGateway",
    });
  }

  async deprovisionByoipCidr(
    {abortSignal, ...params}: RequestConfig & s.DeprovisionByoipCidrRequest,
  ): Promise<s.DeprovisionByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprovisionByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async deregisterImage(
    {abortSignal, ...params}: RequestConfig & s.DeregisterImageRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterImage",
    });
  }

  async deregisterInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & s.DeregisterInstanceEventNotificationAttributesRequest = {},
  ): Promise<s.DeregisterInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTagAttribute"] != null) DeregisterInstanceTagAttributeRequest_Serialize(body, prefix+"InstanceTagAttribute", params["InstanceTagAttribute"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async deregisterTransitGatewayMulticastGroupMembers(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTransitGatewayMulticastGroupMembersRequest = {},
  ): Promise<s.DeregisterTransitGatewayMulticastGroupMembersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTransitGatewayMulticastGroupMembers",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DeregisteredMulticastGroupMembers: xml.first("deregisteredMulticastGroupMembers", false, TransitGatewayMulticastDeregisteredGroupMembers_Parse),
    };
  }

  async deregisterTransitGatewayMulticastGroupSources(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTransitGatewayMulticastGroupSourcesRequest = {},
  ): Promise<s.DeregisterTransitGatewayMulticastGroupSourcesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTransitGatewayMulticastGroupSources",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DeregisteredMulticastGroupSources: xml.first("deregisteredMulticastGroupSources", false, TransitGatewayMulticastDeregisteredGroupSources_Parse),
    };
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountAttributesRequest = {},
  ): Promise<s.DescribeAccountAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"attributeName", params["AttributeNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AccountAttributes: xml.getList("accountAttributeSet", "item").map(AccountAttribute_Parse),
    };
  }

  async describeAddresses(
    {abortSignal, ...params}: RequestConfig & s.DescribeAddressesRequest = {},
  ): Promise<s.DescribeAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["PublicIps"]) qsP.appendList(body, prefix+"PublicIp", params["PublicIps"], {"entryPrefix":"."})
    if (params["AllocationIds"]) qsP.appendList(body, prefix+"AllocationId", params["AllocationIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Addresses: xml.getList("addressesSet", "item").map(Address_Parse),
    };
  }

  async describeAddressesAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeAddressesAttributeRequest = {},
  ): Promise<s.DescribeAddressesAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AllocationIds"]) qsP.appendList(body, prefix+"AllocationId", params["AllocationIds"], {"entryPrefix":"."})
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAddressesAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Addresses: xml.getList("addressSet", "item").map(AddressAttribute_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeAggregateIdFormat(
    {abortSignal, ...params}: RequestConfig & s.DescribeAggregateIdFormatRequest = {},
  ): Promise<s.DescribeAggregateIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAggregateIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      UseLongIdsAggregated: xml.first("useLongIdsAggregated", false, x => x.content === 'true'),
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeAvailabilityZones(
    {abortSignal, ...params}: RequestConfig & s.DescribeAvailabilityZonesRequest = {},
  ): Promise<s.DescribeAvailabilityZonesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ZoneNames"]) qsP.appendList(body, prefix+"ZoneName", params["ZoneNames"], {"entryPrefix":"."})
    if (params["ZoneIds"]) qsP.appendList(body, prefix+"ZoneId", params["ZoneIds"], {"entryPrefix":"."})
    if ("AllAvailabilityZones" in params) body.append(prefix+"AllAvailabilityZones", (params["AllAvailabilityZones"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityZones",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AvailabilityZones: xml.getList("availabilityZoneInfo", "item").map(AvailabilityZone_Parse),
    };
  }

  async describeBundleTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeBundleTasksRequest = {},
  ): Promise<s.DescribeBundleTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BundleIds"]) qsP.appendList(body, prefix+"BundleId", params["BundleIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBundleTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTasks: xml.getList("bundleInstanceTasksSet", "item").map(BundleTask_Parse),
    };
  }

  async describeByoipCidrs(
    {abortSignal, ...params}: RequestConfig & s.DescribeByoipCidrsRequest,
  ): Promise<s.DescribeByoipCidrsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeByoipCidrs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidrs: xml.getList("byoipCidrSet", "item").map(ByoipCidr_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeCapacityReservations(
    {abortSignal, ...params}: RequestConfig & s.DescribeCapacityReservationsRequest = {},
  ): Promise<s.DescribeCapacityReservationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CapacityReservationIds"]) qsP.appendList(body, prefix+"CapacityReservationId", params["CapacityReservationIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCapacityReservations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservations: xml.getList("capacityReservationSet", "item").map(CapacityReservation_Parse),
    };
  }

  async describeCarrierGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeCarrierGatewaysRequest = {},
  ): Promise<s.DescribeCarrierGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CarrierGatewayIds"]) qsP.appendList(body, prefix+"CarrierGatewayId", params["CarrierGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCarrierGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateways: xml.getList("carrierGatewaySet", "item").map(CarrierGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClassicLinkInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeClassicLinkInstancesRequest = {},
  ): Promise<s.DescribeClassicLinkInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClassicLinkInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Instances: xml.getList("instancesSet", "item").map(ClassicLinkInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnAuthorizationRules(
    {abortSignal, ...params}: RequestConfig & s.DescribeClientVpnAuthorizationRulesRequest,
  ): Promise<s.DescribeClientVpnAuthorizationRulesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnAuthorizationRules",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AuthorizationRules: xml.getList("authorizationRule", "item").map(AuthorizationRule_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeClientVpnConnectionsRequest,
  ): Promise<s.DescribeClientVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Connections: xml.getList("connections", "item").map(ClientVpnConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeClientVpnEndpointsRequest = {},
  ): Promise<s.DescribeClientVpnEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ClientVpnEndpointIds"]) qsP.appendList(body, prefix+"ClientVpnEndpointId", params["ClientVpnEndpointIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpoints: xml.getList("clientVpnEndpoint", "item").map(ClientVpnEndpoint_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnRoutes(
    {abortSignal, ...params}: RequestConfig & s.DescribeClientVpnRoutesRequest,
  ): Promise<s.DescribeClientVpnRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routes", "item").map(ClientVpnRoute_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnTargetNetworks(
    {abortSignal, ...params}: RequestConfig & s.DescribeClientVpnTargetNetworksRequest,
  ): Promise<s.DescribeClientVpnTargetNetworksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["AssociationIds"]) qsP.appendList(body, prefix+"item", params["AssociationIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnTargetNetworks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnTargetNetworks: xml.getList("clientVpnTargetNetworks", "item").map(TargetNetwork_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeCoipPools(
    {abortSignal, ...params}: RequestConfig & s.DescribeCoipPoolsRequest = {},
  ): Promise<s.DescribeCoipPoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCoipPools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CoipPools: xml.getList("coipPoolSet", "item").map(CoipPool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeConversionTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeConversionTasksRequest = {},
  ): Promise<s.DescribeConversionTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ConversionTaskIds"]) qsP.appendList(body, prefix+"conversionTaskId", params["ConversionTaskIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConversionTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTasks: xml.getList("conversionTasks", "item").map(ConversionTask_Parse),
    };
  }

  async describeCustomerGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeCustomerGatewaysRequest = {},
  ): Promise<s.DescribeCustomerGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CustomerGatewayIds"]) qsP.appendList(body, prefix+"CustomerGatewayId", params["CustomerGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCustomerGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CustomerGateways: xml.getList("customerGatewaySet", "item").map(CustomerGateway_Parse),
    };
  }

  async describeDhcpOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDhcpOptionsRequest = {},
  ): Promise<s.DescribeDhcpOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DhcpOptionsIds"]) qsP.appendList(body, prefix+"DhcpOptionsId", params["DhcpOptionsIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDhcpOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DhcpOptions: xml.getList("dhcpOptionsSet", "item").map(DhcpOptions_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeEgressOnlyInternetGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeEgressOnlyInternetGatewaysRequest = {},
  ): Promise<s.DescribeEgressOnlyInternetGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["EgressOnlyInternetGatewayIds"]) qsP.appendList(body, prefix+"EgressOnlyInternetGatewayId", params["EgressOnlyInternetGatewayIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEgressOnlyInternetGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EgressOnlyInternetGateways: xml.getList("egressOnlyInternetGatewaySet", "item").map(EgressOnlyInternetGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeElasticGpus(
    {abortSignal, ...params}: RequestConfig & s.DescribeElasticGpusRequest = {},
  ): Promise<s.DescribeElasticGpusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ElasticGpuIds"]) qsP.appendList(body, prefix+"ElasticGpuId", params["ElasticGpuIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticGpus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ElasticGpuSet: xml.getList("elasticGpuSet", "item").map(ElasticGpus_Parse),
      MaxResults: xml.first("maxResults", false, x => parseInt(x.content ?? '0')),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeExportImageTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportImageTasksRequest = {},
  ): Promise<s.DescribeExportImageTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ExportImageTaskIds"]) qsP.appendList(body, prefix+"ExportImageTaskId", params["ExportImageTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportImageTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportImageTasks: xml.getList("exportImageTaskSet", "item").map(ExportImageTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeExportTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportTasksRequest = {},
  ): Promise<s.DescribeExportTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ExportTaskIds"]) qsP.appendList(body, prefix+"exportTaskId", params["ExportTaskIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportTasks: xml.getList("exportTaskSet", "item").map(ExportTask_Parse),
    };
  }

  async describeFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & s.DescribeFastSnapshotRestoresRequest = {},
  ): Promise<s.DescribeFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FastSnapshotRestores: xml.getList("fastSnapshotRestoreSet", "item").map(DescribeFastSnapshotRestoreSuccessItem_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeFleetHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetHistoryRequest,
  ): Promise<s.DescribeFleetHistoryResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EventType" in params) body.append(prefix+"EventType", (params["EventType"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HistoryRecords: xml.getList("historyRecordSet", "item").map(HistoryRecordEntry_Parse),
      LastEvaluatedTime: xml.first("lastEvaluatedTime", false, x => xmlP.parseTimestamp(x.content)),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
      StartTime: xml.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeFleetInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetInstancesRequest,
  ): Promise<s.DescribeFleetInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ActiveInstances: xml.getList("activeInstanceSet", "item").map(ActiveInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
    };
  }

  async describeFleets(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetsRequest = {},
  ): Promise<s.DescribeFleetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["FleetIds"]) qsP.appendList(body, prefix+"FleetId", params["FleetIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Fleets: xml.getList("fleetSet", "item").map(FleetData_Parse),
    };
  }

  async describeFlowLogs(
    {abortSignal, ...params}: RequestConfig & s.DescribeFlowLogsRequest = {},
  ): Promise<s.DescribeFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["FlowLogIds"]) qsP.appendList(body, prefix+"FlowLogId", params["FlowLogIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FlowLogs: xml.getList("flowLogSet", "item").map(FlowLog_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeFpgaImageAttributeRequest,
  ): Promise<s.DescribeFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageAttribute: xml.first("fpgaImageAttribute", false, FpgaImageAttribute_Parse),
    };
  }

  async describeFpgaImages(
    {abortSignal, ...params}: RequestConfig & s.DescribeFpgaImagesRequest = {},
  ): Promise<s.DescribeFpgaImagesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FpgaImageIds"]) qsP.appendList(body, prefix+"FpgaImageId", params["FpgaImageIds"], {"entryPrefix":"."})
    if (params["Owners"]) qsP.appendList(body, prefix+"Owner", params["Owners"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFpgaImages",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImages: xml.getList("fpgaImageSet", "item").map(FpgaImage_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeHostReservationOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeHostReservationOfferingsRequest = {},
  ): Promise<s.DescribeHostReservationOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxDuration" in params) body.append(prefix+"MaxDuration", (params["MaxDuration"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("MinDuration" in params) body.append(prefix+"MinDuration", (params["MinDuration"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("OfferingId" in params) body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHostReservationOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      OfferingSet: xml.getList("offeringSet", "item").map(HostOffering_Parse),
    };
  }

  async describeHostReservations(
    {abortSignal, ...params}: RequestConfig & s.DescribeHostReservationsRequest = {},
  ): Promise<s.DescribeHostReservationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["HostReservationIdSet"]) qsP.appendList(body, prefix+"item", params["HostReservationIdSet"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHostReservations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostReservationSet: xml.getList("hostReservationSet", "item").map(HostReservation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeHosts(
    {abortSignal, ...params}: RequestConfig & s.DescribeHostsRequest = {},
  ): Promise<s.DescribeHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Hosts: xml.getList("hostSet", "item").map(Host_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIamInstanceProfileAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeIamInstanceProfileAssociationsRequest = {},
  ): Promise<s.DescribeIamInstanceProfileAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AssociationIds"]) qsP.appendList(body, prefix+"AssociationId", params["AssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIamInstanceProfileAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociations: xml.getList("iamInstanceProfileAssociationSet", "item").map(IamInstanceProfileAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIdFormat(
    {abortSignal, ...params}: RequestConfig & s.DescribeIdFormatRequest = {},
  ): Promise<s.DescribeIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Resource" in params) body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeIdentityIdFormat(
    {abortSignal, ...params}: RequestConfig & s.DescribeIdentityIdFormatRequest,
  ): Promise<s.DescribeIdentityIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PrincipalArn", (params["PrincipalArn"] ?? '').toString());
    if ("Resource" in params) body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIdentityIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeImageAttributeRequest,
  ): Promise<s.ImageAttribute> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BlockDeviceMappings: xml.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      LaunchPermissions: xml.getList("launchPermission", "item").map(LaunchPermission_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      Description: xml.first("description", false, AttributeValue_Parse),
      KernelId: xml.first("kernel", false, AttributeValue_Parse),
      RamdiskId: xml.first("ramdisk", false, AttributeValue_Parse),
      SriovNetSupport: xml.first("sriovNetSupport", false, AttributeValue_Parse),
    };
  }

  async describeImages(
    {abortSignal, ...params}: RequestConfig & s.DescribeImagesRequest = {},
  ): Promise<s.DescribeImagesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ExecutableUsers"]) qsP.appendList(body, prefix+"ExecutableBy", params["ExecutableUsers"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImageIds"]) qsP.appendList(body, prefix+"ImageId", params["ImageIds"], {"entryPrefix":"."})
    if (params["Owners"]) qsP.appendList(body, prefix+"Owner", params["Owners"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImages",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Images: xml.getList("imagesSet", "item").map(Image_Parse),
    };
  }

  async describeImportImageTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeImportImageTasksRequest = {},
  ): Promise<s.DescribeImportImageTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImportTaskIds"]) qsP.appendList(body, prefix+"ImportTaskId", params["ImportTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImportImageTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportImageTasks: xml.getList("importImageTaskSet", "item").map(ImportImageTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeImportSnapshotTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeImportSnapshotTasksRequest = {},
  ): Promise<s.DescribeImportSnapshotTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImportTaskIds"]) qsP.appendList(body, prefix+"ImportTaskId", params["ImportTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImportSnapshotTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportSnapshotTasks: xml.getList("importSnapshotTaskSet", "item").map(ImportSnapshotTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceAttributeRequest,
  ): Promise<s.InstanceAttribute> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Groups: xml.getList("groupSet", "item").map(GroupIdentifier_Parse),
      BlockDeviceMappings: xml.getList("blockDeviceMapping", "item").map(InstanceBlockDeviceMapping_Parse),
      DisableApiTermination: xml.first("disableApiTermination", false, AttributeBooleanValue_Parse),
      EnaSupport: xml.first("enaSupport", false, AttributeBooleanValue_Parse),
      EnclaveOptions: xml.first("enclaveOptions", false, EnclaveOptions_Parse),
      EbsOptimized: xml.first("ebsOptimized", false, AttributeBooleanValue_Parse),
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      InstanceInitiatedShutdownBehavior: xml.first("instanceInitiatedShutdownBehavior", false, AttributeValue_Parse),
      InstanceType: xml.first("instanceType", false, AttributeValue_Parse),
      KernelId: xml.first("kernel", false, AttributeValue_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      RamdiskId: xml.first("ramdisk", false, AttributeValue_Parse),
      RootDeviceName: xml.first("rootDeviceName", false, AttributeValue_Parse),
      SourceDestCheck: xml.first("sourceDestCheck", false, AttributeBooleanValue_Parse),
      SriovNetSupport: xml.first("sriovNetSupport", false, AttributeValue_Parse),
      UserData: xml.first("userData", false, AttributeValue_Parse),
    };
  }

  async describeInstanceCreditSpecifications(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceCreditSpecificationsRequest = {},
  ): Promise<s.DescribeInstanceCreditSpecificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceCreditSpecifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceCreditSpecifications: xml.getList("instanceCreditSpecificationSet", "item").map(InstanceCreditSpecification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceEventNotificationAttributesRequest = {},
  ): Promise<s.DescribeInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async describeInstanceStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceStatusRequest = {},
  ): Promise<s.DescribeInstanceStatusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("IncludeAllInstances" in params) body.append(prefix+"IncludeAllInstances", (params["IncludeAllInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceStatuses: xml.getList("instanceStatusSet", "item").map(InstanceStatus_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceTypeOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceTypeOfferingsRequest = {},
  ): Promise<s.DescribeInstanceTypeOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LocationType" in params) body.append(prefix+"LocationType", (params["LocationType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceTypeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTypeOfferings: xml.getList("instanceTypeOfferingSet", "item").map(InstanceTypeOffering_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceTypes(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceTypesRequest = {},
  ): Promise<s.DescribeInstanceTypesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTypes"]) qsP.appendList(body, prefix+"InstanceType", params["InstanceTypes"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTypes: xml.getList("instanceTypeSet", "item").map(InstanceTypeInfo_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancesRequest = {},
  ): Promise<s.DescribeInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Reservations: xml.getList("reservationSet", "item").map(Reservation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInternetGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeInternetGatewaysRequest = {},
  ): Promise<s.DescribeInternetGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InternetGatewayIds"]) qsP.appendList(body, prefix+"internetGatewayId", params["InternetGatewayIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInternetGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InternetGateways: xml.getList("internetGatewaySet", "item").map(InternetGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIpv6Pools(
    {abortSignal, ...params}: RequestConfig & s.DescribeIpv6PoolsRequest = {},
  ): Promise<s.DescribeIpv6PoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIpv6Pools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6Pools: xml.getList("ipv6PoolSet", "item").map(Ipv6Pool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeKeyPairs(
    {abortSignal, ...params}: RequestConfig & s.DescribeKeyPairsRequest = {},
  ): Promise<s.DescribeKeyPairsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["KeyNames"]) qsP.appendList(body, prefix+"KeyName", params["KeyNames"], {"entryPrefix":"."})
    if (params["KeyPairIds"]) qsP.appendList(body, prefix+"KeyPairId", params["KeyPairIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKeyPairs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyPairs: xml.getList("keySet", "item").map(KeyPairInfo_Parse),
    };
  }

  async describeLaunchTemplateVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeLaunchTemplateVersionsRequest = {},
  ): Promise<s.DescribeLaunchTemplateVersionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if (params["Versions"]) qsP.appendList(body, prefix+"LaunchTemplateVersion", params["Versions"], {"entryPrefix":"."})
    if ("MinVersion" in params) body.append(prefix+"MinVersion", (params["MinVersion"] ?? '').toString());
    if ("MaxVersion" in params) body.append(prefix+"MaxVersion", (params["MaxVersion"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchTemplateVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateVersions: xml.getList("launchTemplateVersionSet", "item").map(LaunchTemplateVersion_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLaunchTemplates(
    {abortSignal, ...params}: RequestConfig & s.DescribeLaunchTemplatesRequest = {},
  ): Promise<s.DescribeLaunchTemplatesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LaunchTemplateIds"]) qsP.appendList(body, prefix+"LaunchTemplateId", params["LaunchTemplateIds"], {"entryPrefix":"."})
    if (params["LaunchTemplateNames"]) qsP.appendList(body, prefix+"LaunchTemplateName", params["LaunchTemplateNames"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchTemplates",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplates: xml.getList("launchTemplates", "item").map(LaunchTemplate_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = {},
  ): Promise<s.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableVirtualInterfaceGroupAssociationId", params["LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVirtualInterfaceGroupAssociations: xml.getList("localGatewayRouteTableVirtualInterfaceGroupAssociationSet", "item").map(LocalGatewayRouteTableVirtualInterfaceGroupAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTableVpcAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewayRouteTableVpcAssociationsRequest = {},
  ): Promise<s.DescribeLocalGatewayRouteTableVpcAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableVpcAssociationIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableVpcAssociationId", params["LocalGatewayRouteTableVpcAssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTableVpcAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociations: xml.getList("localGatewayRouteTableVpcAssociationSet", "item").map(LocalGatewayRouteTableVpcAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTables(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewayRouteTablesRequest = {},
  ): Promise<s.DescribeLocalGatewayRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableId", params["LocalGatewayRouteTableIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTables: xml.getList("localGatewayRouteTableSet", "item").map(LocalGatewayRouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayVirtualInterfaceGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewayVirtualInterfaceGroupsRequest = {},
  ): Promise<s.DescribeLocalGatewayVirtualInterfaceGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayVirtualInterfaceGroupIds"]) qsP.appendList(body, prefix+"LocalGatewayVirtualInterfaceGroupId", params["LocalGatewayVirtualInterfaceGroupIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayVirtualInterfaceGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayVirtualInterfaceGroups: xml.getList("localGatewayVirtualInterfaceGroupSet", "item").map(LocalGatewayVirtualInterfaceGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayVirtualInterfaces(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewayVirtualInterfacesRequest = {},
  ): Promise<s.DescribeLocalGatewayVirtualInterfacesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayVirtualInterfaceIds"]) qsP.appendList(body, prefix+"LocalGatewayVirtualInterfaceId", params["LocalGatewayVirtualInterfaceIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayVirtualInterfaces",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayVirtualInterfaces: xml.getList("localGatewayVirtualInterfaceSet", "item").map(LocalGatewayVirtualInterface_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeLocalGatewaysRequest = {},
  ): Promise<s.DescribeLocalGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayIds"]) qsP.appendList(body, prefix+"LocalGatewayId", params["LocalGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGateways: xml.getList("localGatewaySet", "item").map(LocalGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeManagedPrefixLists(
    {abortSignal, ...params}: RequestConfig & s.DescribeManagedPrefixListsRequest = {},
  ): Promise<s.DescribeManagedPrefixListsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+"PrefixListId", params["PrefixListIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeManagedPrefixLists",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      PrefixLists: xml.getList("prefixListSet", "item").map(ManagedPrefixList_Parse),
    };
  }

  async describeMovingAddresses(
    {abortSignal, ...params}: RequestConfig & s.DescribeMovingAddressesRequest = {},
  ): Promise<s.DescribeMovingAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PublicIps"]) qsP.appendList(body, prefix+"publicIp", params["PublicIps"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMovingAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MovingAddressStatuses: xml.getList("movingAddressStatusSet", "item").map(MovingAddressStatus_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNatGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeNatGatewaysRequest = {},
  ): Promise<s.DescribeNatGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["NatGatewayIds"]) qsP.appendList(body, prefix+"NatGatewayId", params["NatGatewayIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNatGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NatGateways: xml.getList("natGatewaySet", "item").map(NatGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkAcls(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkAclsRequest = {},
  ): Promise<s.DescribeNetworkAclsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["NetworkAclIds"]) qsP.appendList(body, prefix+"NetworkAclId", params["NetworkAclIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkAcls",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkAcls: xml.getList("networkAclSet", "item").map(NetworkAcl_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInsightsAnalyses(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkInsightsAnalysesRequest = {},
  ): Promise<s.DescribeNetworkInsightsAnalysesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["NetworkInsightsAnalysisIds"]) qsP.appendList(body, prefix+"NetworkInsightsAnalysisId", params["NetworkInsightsAnalysisIds"], {"entryPrefix":"."})
    if ("NetworkInsightsPathId" in params) body.append(prefix+"NetworkInsightsPathId", (params["NetworkInsightsPathId"] ?? '').toString());
    if ("AnalysisStartTime" in params) body.append(prefix+"AnalysisStartTime", qsP.encodeDate_iso8601(params["AnalysisStartTime"]));
    if ("AnalysisEndTime" in params) body.append(prefix+"AnalysisEndTime", qsP.encodeDate_iso8601(params["AnalysisEndTime"]));
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInsightsAnalyses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsAnalyses: xml.getList("networkInsightsAnalysisSet", "item").map(NetworkInsightsAnalysis_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInsightsPaths(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkInsightsPathsRequest = {},
  ): Promise<s.DescribeNetworkInsightsPathsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["NetworkInsightsPathIds"]) qsP.appendList(body, prefix+"NetworkInsightsPathId", params["NetworkInsightsPathIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInsightsPaths",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsPaths: xml.getList("networkInsightsPathSet", "item").map(NetworkInsightsPath_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkInterfaceAttributeRequest,
  ): Promise<s.DescribeNetworkInterfaceAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfaceAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Attachment: xml.first("attachment", false, NetworkInterfaceAttachment_Parse),
      Description: xml.first("description", false, AttributeValue_Parse),
      Groups: xml.getList("groupSet", "item").map(GroupIdentifier_Parse),
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      SourceDestCheck: xml.first("sourceDestCheck", false, AttributeBooleanValue_Parse),
    };
  }

  async describeNetworkInterfacePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkInterfacePermissionsRequest = {},
  ): Promise<s.DescribeNetworkInterfacePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["NetworkInterfacePermissionIds"]) qsP.appendList(body, prefix+"NetworkInterfacePermissionId", params["NetworkInterfacePermissionIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfacePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfacePermissions: xml.getList("networkInterfacePermissions", "item").map(NetworkInterfacePermission_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInterfaces(
    {abortSignal, ...params}: RequestConfig & s.DescribeNetworkInterfacesRequest = {},
  ): Promise<s.DescribeNetworkInterfacesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"NetworkInterfaceId", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfaces",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaces: xml.getList("networkInterfaceSet", "item").map(NetworkInterface_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describePlacementGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribePlacementGroupsRequest = {},
  ): Promise<s.DescribePlacementGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["GroupNames"]) qsP.appendList(body, prefix+"groupName", params["GroupNames"], {"entryPrefix":"."})
    if (params["GroupIds"]) qsP.appendList(body, prefix+"GroupId", params["GroupIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePlacementGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PlacementGroups: xml.getList("placementGroupSet", "item").map(PlacementGroup_Parse),
    };
  }

  async describePrefixLists(
    {abortSignal, ...params}: RequestConfig & s.DescribePrefixListsRequest = {},
  ): Promise<s.DescribePrefixListsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+"PrefixListId", params["PrefixListIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePrefixLists",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      PrefixLists: xml.getList("prefixListSet", "item").map(PrefixList_Parse),
    };
  }

  async describePrincipalIdFormat(
    {abortSignal, ...params}: RequestConfig & s.DescribePrincipalIdFormatRequest = {},
  ): Promise<s.DescribePrincipalIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"Resource", params["Resources"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePrincipalIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Principals: xml.getList("principalSet", "item").map(PrincipalIdFormat_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describePublicIpv4Pools(
    {abortSignal, ...params}: RequestConfig & s.DescribePublicIpv4PoolsRequest = {},
  ): Promise<s.DescribePublicIpv4PoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePublicIpv4Pools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIpv4Pools: xml.getList("publicIpv4PoolSet", "item").map(PublicIpv4Pool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeRegions(
    {abortSignal, ...params}: RequestConfig & s.DescribeRegionsRequest = {},
  ): Promise<s.DescribeRegionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["RegionNames"]) qsP.appendList(body, prefix+"RegionName", params["RegionNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("AllRegions" in params) body.append(prefix+"AllRegions", (params["AllRegions"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRegions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Regions: xml.getList("regionInfo", "item").map(Region_Parse),
    };
  }

  async describeReservedInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedInstancesRequest = {},
  ): Promise<s.DescribeReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("OfferingClass" in params) body.append(prefix+"OfferingClass", (params["OfferingClass"] ?? '').toString());
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstances: xml.getList("reservedInstancesSet", "item").map(ReservedInstances_Parse),
    };
  }

  async describeReservedInstancesListings(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedInstancesListingsRequest = {},
  ): Promise<s.DescribeReservedInstancesListingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("ReservedInstancesId" in params) body.append(prefix+"ReservedInstancesId", (params["ReservedInstancesId"] ?? '').toString());
    if ("ReservedInstancesListingId" in params) body.append(prefix+"ReservedInstancesListingId", (params["ReservedInstancesListingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesListings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async describeReservedInstancesModifications(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedInstancesModificationsRequest = {},
  ): Promise<s.DescribeReservedInstancesModificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ReservedInstancesModificationIds"]) qsP.appendList(body, prefix+"ReservedInstancesModificationId", params["ReservedInstancesModificationIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ReservedInstancesModifications: xml.getList("reservedInstancesModificationsSet", "item").map(ReservedInstancesModification_Parse),
    };
  }

  async describeReservedInstancesOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedInstancesOfferingsRequest = {},
  ): Promise<s.DescribeReservedInstancesOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("IncludeMarketplace" in params) body.append(prefix+"IncludeMarketplace", (params["IncludeMarketplace"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("MaxDuration" in params) body.append(prefix+"MaxDuration", (params["MaxDuration"] ?? '').toString());
    if ("MaxInstanceCount" in params) body.append(prefix+"MaxInstanceCount", (params["MaxInstanceCount"] ?? '').toString());
    if ("MinDuration" in params) body.append(prefix+"MinDuration", (params["MinDuration"] ?? '').toString());
    if ("OfferingClass" in params) body.append(prefix+"OfferingClass", (params["OfferingClass"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if (params["ReservedInstancesOfferingIds"]) qsP.appendList(body, prefix+"ReservedInstancesOfferingId", params["ReservedInstancesOfferingIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceTenancy" in params) body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesOfferings: xml.getList("reservedInstancesOfferingsSet", "item").map(ReservedInstancesOffering_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeRouteTables(
    {abortSignal, ...params}: RequestConfig & s.DescribeRouteTablesRequest = {},
  ): Promise<s.DescribeRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["RouteTableIds"]) qsP.appendList(body, prefix+"RouteTableId", params["RouteTableIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RouteTables: xml.getList("routeTableSet", "item").map(RouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeScheduledInstanceAvailability(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduledInstanceAvailabilityRequest,
  ): Promise<s.DescribeScheduledInstanceAvailabilityResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    SlotDateTimeRangeRequest_Serialize(body, prefix+"FirstSlotStartTimeRange", params["FirstSlotStartTimeRange"]);
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("MaxSlotDurationInHours" in params) body.append(prefix+"MaxSlotDurationInHours", (params["MaxSlotDurationInHours"] ?? '').toString());
    if ("MinSlotDurationInHours" in params) body.append(prefix+"MinSlotDurationInHours", (params["MinSlotDurationInHours"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    ScheduledInstanceRecurrenceRequest_Serialize(body, prefix+"Recurrence", params["Recurrence"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledInstanceAvailability",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ScheduledInstanceAvailabilitySet: xml.getList("scheduledInstanceAvailabilitySet", "item").map(ScheduledInstanceAvailability_Parse),
    };
  }

  async describeScheduledInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduledInstancesRequest = {},
  ): Promise<s.DescribeScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["ScheduledInstanceIds"]) qsP.appendList(body, prefix+"ScheduledInstanceId", params["ScheduledInstanceIds"], {"entryPrefix":"."})
    if (params["SlotStartTimeRange"] != null) SlotStartTimeRangeRequest_Serialize(body, prefix+"SlotStartTimeRange", params["SlotStartTimeRange"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ScheduledInstanceSet: xml.getList("scheduledInstanceSet", "item").map(ScheduledInstance_Parse),
    };
  }

  async describeSecurityGroupReferences(
    {abortSignal, ...params}: RequestConfig & s.DescribeSecurityGroupReferencesRequest,
  ): Promise<s.DescribeSecurityGroupReferencesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["GroupId"]) qsP.appendList(body, prefix+"item", params["GroupId"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityGroupReferences",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroupReferenceSet: xml.getList("securityGroupReferenceSet", "item").map(SecurityGroupReference_Parse),
    };
  }

  async describeSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeSecurityGroupsRequest = {},
  ): Promise<s.DescribeSecurityGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["GroupIds"]) qsP.appendList(body, prefix+"GroupId", params["GroupIds"], {"entryPrefix":"."})
    if (params["GroupNames"]) qsP.appendList(body, prefix+"GroupName", params["GroupNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroups: xml.getList("securityGroupInfo", "item").map(SecurityGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotAttributeRequest,
  ): Promise<s.DescribeSnapshotAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CreateVolumePermissions: xml.getList("createVolumePermission", "item").map(CreateVolumePermission_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      SnapshotId: xml.first("snapshotId", false, x => x.content ?? ''),
    };
  }

  async describeSnapshots(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotsRequest = {},
  ): Promise<s.DescribeSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["OwnerIds"]) qsP.appendList(body, prefix+"Owner", params["OwnerIds"], {"entryPrefix":"."})
    if (params["RestorableByUserIds"]) qsP.appendList(body, prefix+"RestorableBy", params["RestorableByUserIds"], {"entryPrefix":"."})
    if (params["SnapshotIds"]) qsP.appendList(body, prefix+"SnapshotId", params["SnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Snapshots: xml.getList("snapshotSet", "item").map(Snapshot_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotDatafeedSubscriptionRequest = {},
  ): Promise<s.DescribeSpotDatafeedSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotDatafeedSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotDatafeedSubscription: xml.first("spotDatafeedSubscription", false, SpotDatafeedSubscription_Parse),
    };
  }

  async describeSpotFleetInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotFleetInstancesRequest,
  ): Promise<s.DescribeSpotFleetInstancesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ActiveInstances: xml.getList("activeInstanceSet", "item").map(ActiveInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
    };
  }

  async describeSpotFleetRequestHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotFleetRequestHistoryRequest,
  ): Promise<s.DescribeSpotFleetRequestHistoryResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EventType" in params) body.append(prefix+"EventType", (params["EventType"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetRequestHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HistoryRecords: xml.getList("historyRecordSet", "item").map(HistoryRecord_Parse),
      LastEvaluatedTime: xml.first("lastEvaluatedTime", false, x => xmlP.parseTimestamp(x.content)),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
      StartTime: xml.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeSpotFleetRequests(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotFleetRequestsRequest = {},
  ): Promise<s.DescribeSpotFleetRequestsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["SpotFleetRequestIds"]) qsP.appendList(body, prefix+"spotFleetRequestId", params["SpotFleetRequestIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestConfigs: xml.getList("spotFleetRequestConfigSet", "item").map(SpotFleetRequestConfig_Parse),
    };
  }

  async describeSpotInstanceRequests(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotInstanceRequestsRequest = {},
  ): Promise<s.DescribeSpotInstanceRequestsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotInstanceRequestIds"]) qsP.appendList(body, prefix+"SpotInstanceRequestId", params["SpotInstanceRequestIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotInstanceRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(SpotInstanceRequest_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSpotPriceHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeSpotPriceHistoryRequest = {},
  ): Promise<s.DescribeSpotPriceHistoryResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if (params["InstanceTypes"]) qsP.appendList(body, prefix+"InstanceType", params["InstanceTypes"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["ProductDescriptions"]) qsP.appendList(body, prefix+"ProductDescription", params["ProductDescriptions"], {"entryPrefix":"."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotPriceHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotPriceHistory: xml.getList("spotPriceHistorySet", "item").map(SpotPrice_Parse),
    };
  }

  async describeStaleSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeStaleSecurityGroupsRequest,
  ): Promise<s.DescribeStaleSecurityGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStaleSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      StaleSecurityGroupSet: xml.getList("staleSecurityGroupSet", "item").map(StaleSecurityGroup_Parse),
    };
  }

  async describeSubnets(
    {abortSignal, ...params}: RequestConfig & s.DescribeSubnetsRequest = {},
  ): Promise<s.DescribeSubnetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetId", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubnets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnets: xml.getList("subnetSet", "item").map(Subnet_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsRequest = {},
  ): Promise<s.DescribeTagsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(TagDescription_Parse),
    };
  }

  async describeTrafficMirrorFilters(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrafficMirrorFiltersRequest = {},
  ): Promise<s.DescribeTrafficMirrorFiltersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorFilterIds"]) qsP.appendList(body, prefix+"TrafficMirrorFilterId", params["TrafficMirrorFilterIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorFilters",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilters: xml.getList("trafficMirrorFilterSet", "item").map(TrafficMirrorFilter_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTrafficMirrorSessions(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrafficMirrorSessionsRequest = {},
  ): Promise<s.DescribeTrafficMirrorSessionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorSessionIds"]) qsP.appendList(body, prefix+"TrafficMirrorSessionId", params["TrafficMirrorSessionIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorSessions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSessions: xml.getList("trafficMirrorSessionSet", "item").map(TrafficMirrorSession_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTrafficMirrorTargets(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrafficMirrorTargetsRequest = {},
  ): Promise<s.DescribeTrafficMirrorTargetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorTargetIds"]) qsP.appendList(body, prefix+"TrafficMirrorTargetId", params["TrafficMirrorTargetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorTargets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTargets: xml.getList("trafficMirrorTargetSet", "item").map(TrafficMirrorTarget_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayAttachments(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayAttachmentsRequest = {},
  ): Promise<s.DescribeTransitGatewayAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayAttachments: xml.getList("transitGatewayAttachments", "item").map(TransitGatewayAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayConnectPeers(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayConnectPeersRequest = {},
  ): Promise<s.DescribeTransitGatewayConnectPeersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayConnectPeerIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayConnectPeerIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayConnectPeers",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnectPeers: xml.getList("transitGatewayConnectPeerSet", "item").map(TransitGatewayConnectPeer_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayConnects(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayConnectsRequest = {},
  ): Promise<s.DescribeTransitGatewayConnectsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayConnects",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayConnects: xml.getList("transitGatewayConnectSet", "item").map(TransitGatewayConnect_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayMulticastDomains(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayMulticastDomainsRequest = {},
  ): Promise<s.DescribeTransitGatewayMulticastDomainsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayMulticastDomainIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayMulticastDomainIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayMulticastDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomains: xml.getList("transitGatewayMulticastDomains", "item").map(TransitGatewayMulticastDomain_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayPeeringAttachments(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayPeeringAttachmentsRequest = {},
  ): Promise<s.DescribeTransitGatewayPeeringAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayPeeringAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachments: xml.getList("transitGatewayPeeringAttachments", "item").map(TransitGatewayPeeringAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayRouteTables(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayRouteTablesRequest = {},
  ): Promise<s.DescribeTransitGatewayRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayRouteTableIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayRouteTableIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTables: xml.getList("transitGatewayRouteTables", "item").map(TransitGatewayRouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayVpcAttachments(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewayVpcAttachmentsRequest = {},
  ): Promise<s.DescribeTransitGatewayVpcAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayVpcAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachments: xml.getList("transitGatewayVpcAttachments", "item").map(TransitGatewayVpcAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransitGatewaysRequest = {},
  ): Promise<s.DescribeTransitGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateways: xml.getList("transitGatewaySet", "item").map(TransitGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVolumeAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeVolumeAttributeRequest,
  ): Promise<s.DescribeVolumeAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumeAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AutoEnableIO: xml.first("autoEnableIO", false, AttributeBooleanValue_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      VolumeId: xml.first("volumeId", false, x => x.content ?? ''),
    };
  }

  async describeVolumeStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeVolumeStatusRequest = {},
  ): Promise<s.DescribeVolumeStatusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumeStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      VolumeStatuses: xml.getList("volumeStatusSet", "item").map(VolumeStatusItem_Parse),
    };
  }

  async describeVolumes(
    {abortSignal, ...params}: RequestConfig & s.DescribeVolumesRequest = {},
  ): Promise<s.DescribeVolumesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Volumes: xml.getList("volumeSet", "item").map(Volume_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVolumesModifications(
    {abortSignal, ...params}: RequestConfig & s.DescribeVolumesModificationsRequest = {},
  ): Promise<s.DescribeVolumesModificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumesModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VolumesModifications: xml.getList("volumeModificationSet", "item").map(VolumeModification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcAttribute(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcAttributeRequest,
  ): Promise<s.DescribeVpcAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
      EnableDnsHostnames: xml.first("enableDnsHostnames", false, AttributeBooleanValue_Parse),
      EnableDnsSupport: xml.first("enableDnsSupport", false, AttributeBooleanValue_Parse),
    };
  }

  async describeVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcClassicLinkRequest = {},
  ): Promise<s.DescribeVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpcs: xml.getList("vpcSet", "item").map(VpcClassicLink_Parse),
    };
  }

  async describeVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcClassicLinkDnsSupportRequest = {},
  ): Promise<s.DescribeVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Vpcs: xml.getList("vpcs", "item").map(ClassicLinkDnsSupport_Parse),
    };
  }

  async describeVpcEndpointConnectionNotifications(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointConnectionNotificationsRequest = {},
  ): Promise<s.DescribeVpcEndpointConnectionNotificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ConnectionNotificationId" in params) body.append(prefix+"ConnectionNotificationId", (params["ConnectionNotificationId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointConnectionNotifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConnectionNotificationSet: xml.getList("connectionNotificationSet", "item").map(ConnectionNotification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointConnectionsRequest = {},
  ): Promise<s.DescribeVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpointConnections: xml.getList("vpcEndpointConnectionSet", "item").map(VpcEndpointConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServiceConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointServiceConfigurationsRequest = {},
  ): Promise<s.DescribeVpcEndpointServiceConfigurationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceIds"]) qsP.appendList(body, prefix+"ServiceId", params["ServiceIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServiceConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceConfigurations: xml.getList("serviceConfigurationSet", "item").map(ServiceConfiguration_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServicePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointServicePermissionsRequest,
  ): Promise<s.DescribeVpcEndpointServicePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServicePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AllowedPrincipals: xml.getList("allowedPrincipals", "item").map(AllowedPrincipal_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServices(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointServicesRequest = {},
  ): Promise<s.DescribeVpcEndpointServicesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceNames"]) qsP.appendList(body, prefix+"ServiceName", params["ServiceNames"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServices",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceNames: xml.getList("serviceNameSet", "item").map(x => x.content ?? ''),
      ServiceDetails: xml.getList("serviceDetailSet", "item").map(ServiceDetail_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcEndpointsRequest = {},
  ): Promise<s.DescribeVpcEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpoints: xml.getList("vpcEndpointSet", "item").map(VpcEndpoint_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcPeeringConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcPeeringConnectionsRequest = {},
  ): Promise<s.DescribeVpcPeeringConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcPeeringConnectionIds"]) qsP.appendList(body, prefix+"VpcPeeringConnectionId", params["VpcPeeringConnectionIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnections: xml.getList("vpcPeeringConnectionSet", "item").map(VpcPeeringConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcs(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcsRequest = {},
  ): Promise<s.DescribeVpcsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpcs: xml.getList("vpcSet", "item").map(Vpc_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpnConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpnConnectionsRequest = {},
  ): Promise<s.DescribeVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpnConnectionIds"]) qsP.appendList(body, prefix+"VpnConnectionId", params["VpnConnectionIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnections: xml.getList("vpnConnectionSet", "item").map(VpnConnection_Parse),
    };
  }

  async describeVpnGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpnGatewaysRequest = {},
  ): Promise<s.DescribeVpnGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpnGatewayIds"]) qsP.appendList(body, prefix+"VpnGatewayId", params["VpnGatewayIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpnGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnGateways: xml.getList("vpnGatewaySet", "item").map(VpnGateway_Parse),
    };
  }

  async detachClassicLinkVpc(
    {abortSignal, ...params}: RequestConfig & s.DetachClassicLinkVpcRequest,
  ): Promise<s.DetachClassicLinkVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachClassicLinkVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async detachInternetGateway(
    {abortSignal, ...params}: RequestConfig & s.DetachInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachInternetGateway",
    });
  }

  async detachNetworkInterface(
    {abortSignal, ...params}: RequestConfig & s.DetachNetworkInterfaceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AttachmentId", (params["AttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachNetworkInterface",
    });
  }

  async detachVolume(
    {abortSignal, ...params}: RequestConfig & s.DetachVolumeRequest,
  ): Promise<s.VolumeAttachment> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Device" in params) body.append(prefix+"Device", (params["Device"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return VolumeAttachment_Parse(xml);
  }

  async detachVpnGateway(
    {abortSignal, ...params}: RequestConfig & s.DetachVpnGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVpnGateway",
    });
  }

  async disableEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & s.DisableEbsEncryptionByDefaultRequest = {},
  ): Promise<s.DisableEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async disableFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & s.DisableFastSnapshotRestoresRequest,
  ): Promise<s.DisableFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZone", params["AvailabilityZones"], {"entryPrefix":"."})
    if (params["SourceSnapshotIds"]) qsP.appendList(body, prefix+"SourceSnapshotId", params["SourceSnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(DisableFastSnapshotRestoreSuccessItem_Parse),
      Unsuccessful: xml.getList("unsuccessful", "item").map(DisableFastSnapshotRestoreErrorItem_Parse),
    };
  }

  async disableTransitGatewayRouteTablePropagation(
    {abortSignal, ...params}: RequestConfig & s.DisableTransitGatewayRouteTablePropagationRequest,
  ): Promise<s.DisableTransitGatewayRouteTablePropagationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableTransitGatewayRouteTablePropagation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Propagation: xml.first("propagation", false, TransitGatewayPropagation_Parse),
    };
  }

  async disableVgwRoutePropagation(
    {abortSignal, ...params}: RequestConfig & s.DisableVgwRoutePropagationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVgwRoutePropagation",
    });
  }

  async disableVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & s.DisableVpcClassicLinkRequest,
  ): Promise<s.DisableVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async disableVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & s.DisableVpcClassicLinkDnsSupportRequest = {},
  ): Promise<s.DisableVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async disassociateAddress(
    {abortSignal, ...params}: RequestConfig & s.DisassociateAddressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AssociationId" in params) body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateAddress",
    });
  }

  async disassociateClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & s.DisassociateClientVpnTargetNetworkRequest,
  ): Promise<s.DisassociateClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, AssociationStatus_Parse),
    };
  }

  async disassociateEnclaveCertificateIamRole(
    {abortSignal, ...params}: RequestConfig & s.DisassociateEnclaveCertificateIamRoleRequest = {},
  ): Promise<s.DisassociateEnclaveCertificateIamRoleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateArn" in params) body.append(prefix+"CertificateArn", (params["CertificateArn"] ?? '').toString());
    if ("RoleArn" in params) body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateEnclaveCertificateIamRole",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async disassociateIamInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.DisassociateIamInstanceProfileRequest,
  ): Promise<s.DisassociateIamInstanceProfileResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateIamInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async disassociateRouteTable(
    {abortSignal, ...params}: RequestConfig & s.DisassociateRouteTableRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateRouteTable",
    });
  }

  async disassociateSubnetCidrBlock(
    {abortSignal, ...params}: RequestConfig & s.DisassociateSubnetCidrBlockRequest,
  ): Promise<s.DisassociateSubnetCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateSubnetCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, SubnetIpv6CidrBlockAssociation_Parse),
      SubnetId: xml.first("subnetId", false, x => x.content ?? ''),
    };
  }

  async disassociateTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & s.DisassociateTransitGatewayMulticastDomainRequest = {},
  ): Promise<s.DisassociateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async disassociateTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & s.DisassociateTransitGatewayRouteTableRequest,
  ): Promise<s.DisassociateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Association: xml.first("association", false, TransitGatewayAssociation_Parse),
    };
  }

  async disassociateVpcCidrBlock(
    {abortSignal, ...params}: RequestConfig & s.DisassociateVpcCidrBlockRequest,
  ): Promise<s.DisassociateVpcCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateVpcCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, VpcIpv6CidrBlockAssociation_Parse),
      CidrBlockAssociation: xml.first("cidrBlockAssociation", false, VpcCidrBlockAssociation_Parse),
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
    };
  }

  async enableEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & s.EnableEbsEncryptionByDefaultRequest = {},
  ): Promise<s.EnableEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async enableFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & s.EnableFastSnapshotRestoresRequest,
  ): Promise<s.EnableFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZone", params["AvailabilityZones"], {"entryPrefix":"."})
    if (params["SourceSnapshotIds"]) qsP.appendList(body, prefix+"SourceSnapshotId", params["SourceSnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(EnableFastSnapshotRestoreSuccessItem_Parse),
      Unsuccessful: xml.getList("unsuccessful", "item").map(EnableFastSnapshotRestoreErrorItem_Parse),
    };
  }

  async enableTransitGatewayRouteTablePropagation(
    {abortSignal, ...params}: RequestConfig & s.EnableTransitGatewayRouteTablePropagationRequest,
  ): Promise<s.EnableTransitGatewayRouteTablePropagationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableTransitGatewayRouteTablePropagation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Propagation: xml.first("propagation", false, TransitGatewayPropagation_Parse),
    };
  }

  async enableVgwRoutePropagation(
    {abortSignal, ...params}: RequestConfig & s.EnableVgwRoutePropagationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVgwRoutePropagation",
    });
  }

  async enableVolumeIO(
    {abortSignal, ...params}: RequestConfig & s.EnableVolumeIORequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVolumeIO",
    });
  }

  async enableVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & s.EnableVpcClassicLinkRequest,
  ): Promise<s.EnableVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async enableVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & s.EnableVpcClassicLinkDnsSupportRequest = {},
  ): Promise<s.EnableVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async exportClientVpnClientCertificateRevocationList(
    {abortSignal, ...params}: RequestConfig & s.ExportClientVpnClientCertificateRevocationListRequest,
  ): Promise<s.ExportClientVpnClientCertificateRevocationListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportClientVpnClientCertificateRevocationList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CertificateRevocationList: xml.first("certificateRevocationList", false, x => x.content ?? ''),
      Status: xml.first("status", false, ClientCertificateRevocationListStatus_Parse),
    };
  }

  async exportClientVpnClientConfiguration(
    {abortSignal, ...params}: RequestConfig & s.ExportClientVpnClientConfigurationRequest,
  ): Promise<s.ExportClientVpnClientConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportClientVpnClientConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientConfiguration: xml.first("clientConfiguration", false, x => x.content ?? ''),
    };
  }

  async exportImage(
    {abortSignal, ...params}: RequestConfig & s.ExportImageRequest,
  ): Promise<s.ExportImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"DiskImageFormat", (params["DiskImageFormat"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    ExportTaskS3LocationRequest_Serialize(body, prefix+"S3ExportLocation", params["S3ExportLocation"]);
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Description: xml.first("description", false, x => x.content ?? ''),
      DiskImageFormat: xml.first("diskImageFormat", false, x => (x.content ?? '') as s.DiskImageFormat),
      ExportImageTaskId: xml.first("exportImageTaskId", false, x => x.content ?? ''),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      RoleName: xml.first("roleName", false, x => x.content ?? ''),
      Progress: xml.first("progress", false, x => x.content ?? ''),
      S3ExportLocation: xml.first("s3ExportLocation", false, ExportTaskS3Location_Parse),
      Status: xml.first("status", false, x => x.content ?? ''),
      StatusMessage: xml.first("statusMessage", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async exportTransitGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & s.ExportTransitGatewayRoutesRequest,
  ): Promise<s.ExportTransitGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    body.append(prefix+"S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportTransitGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      S3Location: xml.first("s3Location", false, x => x.content ?? ''),
    };
  }

  async getAssociatedEnclaveCertificateIamRoles(
    {abortSignal, ...params}: RequestConfig & s.GetAssociatedEnclaveCertificateIamRolesRequest = {},
  ): Promise<s.GetAssociatedEnclaveCertificateIamRolesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateArn" in params) body.append(prefix+"CertificateArn", (params["CertificateArn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAssociatedEnclaveCertificateIamRoles",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociatedRoles: xml.getList("associatedRoleSet", "item").map(AssociatedRole_Parse),
    };
  }

  async getAssociatedIpv6PoolCidrs(
    {abortSignal, ...params}: RequestConfig & s.GetAssociatedIpv6PoolCidrsRequest,
  ): Promise<s.GetAssociatedIpv6PoolCidrsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PoolId", (params["PoolId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAssociatedIpv6PoolCidrs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrAssociations: xml.getList("ipv6CidrAssociationSet", "item").map(Ipv6CidrAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getCapacityReservationUsage(
    {abortSignal, ...params}: RequestConfig & s.GetCapacityReservationUsageRequest,
  ): Promise<s.GetCapacityReservationUsageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCapacityReservationUsage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservationId: xml.first("capacityReservationId", false, x => x.content ?? ''),
      InstanceType: xml.first("instanceType", false, x => x.content ?? ''),
      TotalInstanceCount: xml.first("totalInstanceCount", false, x => parseInt(x.content ?? '0')),
      AvailableInstanceCount: xml.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
      State: xml.first("state", false, x => (x.content ?? '') as s.CapacityReservationState),
      InstanceUsages: xml.getList("instanceUsageSet", "item").map(InstanceUsage_Parse),
    };
  }

  async getCoipPoolUsage(
    {abortSignal, ...params}: RequestConfig & s.GetCoipPoolUsageRequest,
  ): Promise<s.GetCoipPoolUsageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PoolId", (params["PoolId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCoipPoolUsage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CoipPoolId: xml.first("coipPoolId", false, x => x.content ?? ''),
      CoipAddressUsages: xml.getList("coipAddressUsageSet", "item").map(CoipAddressUsage_Parse),
      LocalGatewayRouteTableId: xml.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    };
  }

  async getConsoleOutput(
    {abortSignal, ...params}: RequestConfig & s.GetConsoleOutputRequest,
  ): Promise<s.GetConsoleOutputResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Latest" in params) body.append(prefix+"Latest", (params["Latest"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConsoleOutput",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      Output: xml.first("output", false, x => x.content ?? ''),
      Timestamp: xml.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getConsoleScreenshot(
    {abortSignal, ...params}: RequestConfig & s.GetConsoleScreenshotRequest,
  ): Promise<s.GetConsoleScreenshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("WakeUp" in params) body.append(prefix+"WakeUp", (params["WakeUp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConsoleScreenshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageData: xml.first("imageData", false, x => x.content ?? ''),
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
    };
  }

  async getDefaultCreditSpecification(
    {abortSignal, ...params}: RequestConfig & s.GetDefaultCreditSpecificationRequest,
  ): Promise<s.GetDefaultCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDefaultCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceFamilyCreditSpecification: xml.first("instanceFamilyCreditSpecification", false, InstanceFamilyCreditSpecification_Parse),
    };
  }

  async getEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & s.GetEbsDefaultKmsKeyIdRequest = {},
  ): Promise<s.GetEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async getEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & s.GetEbsEncryptionByDefaultRequest = {},
  ): Promise<s.GetEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async getGroupsForCapacityReservation(
    {abortSignal, ...params}: RequestConfig & s.GetGroupsForCapacityReservationRequest,
  ): Promise<s.GetGroupsForCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroupsForCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservationGroups: xml.getList("capacityReservationGroupSet", "item").map(CapacityReservationGroup_Parse),
    };
  }

  async getHostReservationPurchasePreview(
    {abortSignal, ...params}: RequestConfig & s.GetHostReservationPurchasePreviewRequest,
  ): Promise<s.GetHostReservationPurchasePreviewResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["HostIdSet"]) qsP.appendList(body, prefix+"item", params["HostIdSet"], {"entryPrefix":"."})
    body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHostReservationPurchasePreview",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CurrencyCode: xml.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
      Purchase: xml.getList("purchase", "item").map(Purchase_Parse),
      TotalHourlyPrice: xml.first("totalHourlyPrice", false, x => x.content ?? ''),
      TotalUpfrontPrice: xml.first("totalUpfrontPrice", false, x => x.content ?? ''),
    };
  }

  async getLaunchTemplateData(
    {abortSignal, ...params}: RequestConfig & s.GetLaunchTemplateDataRequest,
  ): Promise<s.GetLaunchTemplateDataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLaunchTemplateData",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateData: xml.first("launchTemplateData", false, ResponseLaunchTemplateData_Parse),
    };
  }

  async getManagedPrefixListAssociations(
    {abortSignal, ...params}: RequestConfig & s.GetManagedPrefixListAssociationsRequest,
  ): Promise<s.GetManagedPrefixListAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedPrefixListAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixListAssociations: xml.getList("prefixListAssociationSet", "item").map(PrefixListAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getManagedPrefixListEntries(
    {abortSignal, ...params}: RequestConfig & s.GetManagedPrefixListEntriesRequest,
  ): Promise<s.GetManagedPrefixListEntriesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TargetVersion" in params) body.append(prefix+"TargetVersion", (params["TargetVersion"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedPrefixListEntries",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Entries: xml.getList("entrySet", "item").map(PrefixListEntry_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getPasswordData(
    {abortSignal, ...params}: RequestConfig & s.GetPasswordDataRequest,
  ): Promise<s.GetPasswordDataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPasswordData",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      PasswordData: xml.first("passwordData", false, x => x.content ?? ''),
      Timestamp: xml.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getReservedInstancesExchangeQuote(
    {abortSignal, ...params}: RequestConfig & s.GetReservedInstancesExchangeQuoteRequest,
  ): Promise<s.GetReservedInstancesExchangeQuoteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstanceIds"]) qsP.appendList(body, prefix+"ReservedInstanceId", params["ReservedInstanceIds"], {"entryPrefix":"."})
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"TargetConfiguration", params["TargetConfigurations"], {"appender":TargetConfigurationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservedInstancesExchangeQuote",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CurrencyCode: xml.first("currencyCode", false, x => x.content ?? ''),
      IsValidExchange: xml.first("isValidExchange", false, x => x.content === 'true'),
      OutputReservedInstancesWillExpireAt: xml.first("outputReservedInstancesWillExpireAt", false, x => xmlP.parseTimestamp(x.content)),
      PaymentDue: xml.first("paymentDue", false, x => x.content ?? ''),
      ReservedInstanceValueRollup: xml.first("reservedInstanceValueRollup", false, ReservationValue_Parse),
      ReservedInstanceValueSet: xml.getList("reservedInstanceValueSet", "item").map(ReservedInstanceReservationValue_Parse),
      TargetConfigurationValueRollup: xml.first("targetConfigurationValueRollup", false, ReservationValue_Parse),
      TargetConfigurationValueSet: xml.getList("targetConfigurationValueSet", "item").map(TargetReservationValue_Parse),
      ValidationFailureReason: xml.first("validationFailureReason", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayAttachmentPropagations(
    {abortSignal, ...params}: RequestConfig & s.GetTransitGatewayAttachmentPropagationsRequest,
  ): Promise<s.GetTransitGatewayAttachmentPropagationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayAttachmentPropagations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayAttachmentPropagations: xml.getList("transitGatewayAttachmentPropagations", "item").map(TransitGatewayAttachmentPropagation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayMulticastDomainAssociations(
    {abortSignal, ...params}: RequestConfig & s.GetTransitGatewayMulticastDomainAssociationsRequest = {},
  ): Promise<s.GetTransitGatewayMulticastDomainAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayMulticastDomainAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MulticastDomainAssociations: xml.getList("multicastDomainAssociations", "item").map(TransitGatewayMulticastDomainAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayPrefixListReferences(
    {abortSignal, ...params}: RequestConfig & s.GetTransitGatewayPrefixListReferencesRequest,
  ): Promise<s.GetTransitGatewayPrefixListReferencesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayPrefixListReferences",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReferences: xml.getList("transitGatewayPrefixListReferenceSet", "item").map(TransitGatewayPrefixListReference_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayRouteTableAssociations(
    {abortSignal, ...params}: RequestConfig & s.GetTransitGatewayRouteTableAssociationsRequest,
  ): Promise<s.GetTransitGatewayRouteTableAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayRouteTableAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.getList("associations", "item").map(TransitGatewayRouteTableAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayRouteTablePropagations(
    {abortSignal, ...params}: RequestConfig & s.GetTransitGatewayRouteTablePropagationsRequest,
  ): Promise<s.GetTransitGatewayRouteTablePropagationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayRouteTablePropagations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTablePropagations: xml.getList("transitGatewayRouteTablePropagations", "item").map(TransitGatewayRouteTablePropagation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async importClientVpnClientCertificateRevocationList(
    {abortSignal, ...params}: RequestConfig & s.ImportClientVpnClientCertificateRevocationListRequest,
  ): Promise<s.ImportClientVpnClientCertificateRevocationListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"CertificateRevocationList", (params["CertificateRevocationList"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportClientVpnClientCertificateRevocationList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async importImage(
    {abortSignal, ...params}: RequestConfig & s.ImportImageRequest = {},
  ): Promise<s.ImportImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Architecture" in params) body.append(prefix+"Architecture", (params["Architecture"] ?? '').toString());
    if (params["ClientData"] != null) ClientData_Serialize(body, prefix+"ClientData", params["ClientData"]);
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskContainers"]) qsP.appendList(body, prefix+"DiskContainer", params["DiskContainers"], {"appender":ImageDiskContainer_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Hypervisor" in params) body.append(prefix+"Hypervisor", (params["Hypervisor"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("LicenseType" in params) body.append(prefix+"LicenseType", (params["LicenseType"] ?? '').toString());
    if ("Platform" in params) body.append(prefix+"Platform", (params["Platform"] ?? '').toString());
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+"item", params["LicenseSpecifications"], {"appender":ImportImageLicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Architecture: xml.first("architecture", false, x => x.content ?? ''),
      Description: xml.first("description", false, x => x.content ?? ''),
      Encrypted: xml.first("encrypted", false, x => x.content === 'true'),
      Hypervisor: xml.first("hypervisor", false, x => x.content ?? ''),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
      LicenseType: xml.first("licenseType", false, x => x.content ?? ''),
      Platform: xml.first("platform", false, x => x.content ?? ''),
      Progress: xml.first("progress", false, x => x.content ?? ''),
      SnapshotDetails: xml.getList("snapshotDetailSet", "item").map(SnapshotDetail_Parse),
      Status: xml.first("status", false, x => x.content ?? ''),
      StatusMessage: xml.first("statusMessage", false, x => x.content ?? ''),
      LicenseSpecifications: xml.getList("licenseSpecifications", "item").map(ImportImageLicenseConfigurationResponse_Parse),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importInstance(
    {abortSignal, ...params}: RequestConfig & s.ImportInstanceRequest,
  ): Promise<s.ImportInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskImages"]) qsP.appendList(body, prefix+"diskImage", params["DiskImages"], {"appender":DiskImage_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LaunchSpecification"] != null) ImportInstanceLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    body.append(prefix+"Platform", (params["Platform"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTask: xml.first("conversionTask", false, ConversionTask_Parse),
    };
  }

  async importKeyPair(
    {abortSignal, ...params}: RequestConfig & s.ImportKeyPairRequest,
  ): Promise<s.ImportKeyPairResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    body.append(prefix+"PublicKeyMaterial", serializeBlob(params["PublicKeyMaterial"]) ?? '');
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportKeyPair",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyFingerprint: xml.first("keyFingerprint", false, x => x.content ?? ''),
      KeyName: xml.first("keyName", false, x => x.content ?? ''),
      KeyPairId: xml.first("keyPairId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importSnapshot(
    {abortSignal, ...params}: RequestConfig & s.ImportSnapshotRequest = {},
  ): Promise<s.ImportSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ClientData"] != null) ClientData_Serialize(body, prefix+"ClientData", params["ClientData"]);
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskContainer"] != null) SnapshotDiskContainer_Serialize(body, prefix+"DiskContainer", params["DiskContainer"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Description: xml.first("description", false, x => x.content ?? ''),
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      SnapshotTaskDetail: xml.first("snapshotTaskDetail", false, SnapshotTaskDetail_Parse),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importVolume(
    {abortSignal, ...params}: RequestConfig & s.ImportVolumeRequest,
  ): Promise<s.ImportVolumeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    DiskImageDetail_Serialize(body, prefix+"Image", params["Image"]);
    VolumeDetail_Serialize(body, prefix+"Volume", params["Volume"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTask: xml.first("conversionTask", false, ConversionTask_Parse),
    };
  }

  async modifyAddressAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyAddressAttributeRequest,
  ): Promise<s.ModifyAddressAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    if ("DomainName" in params) body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyAddressAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Address: xml.first("address", false, AddressAttribute_Parse),
    };
  }

  async modifyAvailabilityZoneGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyAvailabilityZoneGroupRequest,
  ): Promise<s.ModifyAvailabilityZoneGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"OptInStatus", (params["OptInStatus"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyAvailabilityZoneGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyCapacityReservation(
    {abortSignal, ...params}: RequestConfig & s.ModifyCapacityReservationRequest,
  ): Promise<s.ModifyCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("EndDateType" in params) body.append(prefix+"EndDateType", (params["EndDateType"] ?? '').toString());
    if ("Accept" in params) body.append(prefix+"Accept", (params["Accept"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & s.ModifyClientVpnEndpointRequest,
  ): Promise<s.ModifyClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("ServerCertificateArn" in params) body.append(prefix+"ServerCertificateArn", (params["ServerCertificateArn"] ?? '').toString());
    if (params["ConnectionLogOptions"] != null) ConnectionLogOptions_Serialize(body, prefix+"ConnectionLogOptions", params["ConnectionLogOptions"]);
    if (params["DnsServers"] != null) DnsServersOptionsModifyStructure_Serialize(body, prefix+"DnsServers", params["DnsServers"]);
    if ("VpnPort" in params) body.append(prefix+"VpnPort", (params["VpnPort"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("SplitTunnel" in params) body.append(prefix+"SplitTunnel", (params["SplitTunnel"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("SelfServicePortal" in params) body.append(prefix+"SelfServicePortal", (params["SelfServicePortal"] ?? '').toString());
    if (params["ClientConnectOptions"] != null) ClientConnectOptions_Serialize(body, prefix+"ClientConnectOptions", params["ClientConnectOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyDefaultCreditSpecification(
    {abortSignal, ...params}: RequestConfig & s.ModifyDefaultCreditSpecificationRequest,
  ): Promise<s.ModifyDefaultCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    body.append(prefix+"CpuCredits", (params["CpuCredits"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDefaultCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceFamilyCreditSpecification: xml.first("instanceFamilyCreditSpecification", false, InstanceFamilyCreditSpecification_Parse),
    };
  }

  async modifyEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & s.ModifyEbsDefaultKmsKeyIdRequest,
  ): Promise<s.ModifyEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async modifyFleet(
    {abortSignal, ...params}: RequestConfig & s.ModifyFleetRequest,
  ): Promise<s.ModifyFleetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"LaunchTemplateConfig", params["LaunchTemplateConfigs"], {"appender":FleetLaunchTemplateConfigRequest_Serialize,"entryPrefix":"."})
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    if (params["TargetCapacitySpecification"] != null) TargetCapacitySpecificationRequest_Serialize(body, prefix+"TargetCapacitySpecification", params["TargetCapacitySpecification"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyFpgaImageAttributeRequest,
  ): Promise<s.ModifyFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if (params["UserGroups"]) qsP.appendList(body, prefix+"UserGroup", params["UserGroups"], {"entryPrefix":"."})
    if (params["ProductCodes"]) qsP.appendList(body, prefix+"ProductCode", params["ProductCodes"], {"entryPrefix":"."})
    if (params["LoadPermission"] != null) LoadPermissionModifications_Serialize(body, prefix+"LoadPermission", params["LoadPermission"]);
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageAttribute: xml.first("fpgaImageAttribute", false, FpgaImageAttribute_Parse),
    };
  }

  async modifyHosts(
    {abortSignal, ...params}: RequestConfig & s.ModifyHostsRequest,
  ): Promise<s.ModifyHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoPlacement" in params) body.append(prefix+"AutoPlacement", (params["AutoPlacement"] ?? '').toString());
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    if ("HostRecovery" in params) body.append(prefix+"HostRecovery", (params["HostRecovery"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("InstanceFamily" in params) body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async modifyIdFormat(
    {abortSignal, ...params}: RequestConfig & s.ModifyIdFormatRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    body.append(prefix+"UseLongIds", (params["UseLongIds"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyIdFormat",
    });
  }

  async modifyIdentityIdFormat(
    {abortSignal, ...params}: RequestConfig & s.ModifyIdentityIdFormatRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PrincipalArn", (params["PrincipalArn"] ?? '').toString());
    body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    body.append(prefix+"UseLongIds", (params["UseLongIds"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyIdentityIdFormat",
    });
  }

  async modifyImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyImageAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["Description"] != null) AttributeValue_Serialize(body, prefix+"Description", params["Description"]);
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if (params["LaunchPermission"] != null) LaunchPermissionModifications_Serialize(body, prefix+"LaunchPermission", params["LaunchPermission"]);
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    if (params["ProductCodes"]) qsP.appendList(body, prefix+"ProductCode", params["ProductCodes"], {"entryPrefix":"."})
    if (params["UserGroups"]) qsP.appendList(body, prefix+"UserGroup", params["UserGroups"], {"entryPrefix":"."})
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if ("Value" in params) body.append(prefix+"Value", (params["Value"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyImageAttribute",
    });
  }

  async modifyInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["SourceDestCheck"] != null) AttributeBooleanValue_Serialize(body, prefix+"SourceDestCheck", params["SourceDestCheck"]);
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"blockDeviceMapping", params["BlockDeviceMappings"], {"appender":InstanceBlockDeviceMappingSpecification_Serialize,"entryPrefix":"."})
    if (params["DisableApiTermination"] != null) AttributeBooleanValue_Serialize(body, prefix+"DisableApiTermination", params["DisableApiTermination"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["EbsOptimized"] != null) AttributeBooleanValue_Serialize(body, prefix+"EbsOptimized", params["EbsOptimized"]);
    if (params["EnaSupport"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnaSupport", params["EnaSupport"]);
    if (params["Groups"]) qsP.appendList(body, prefix+"GroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if (params["InstanceInitiatedShutdownBehavior"] != null) AttributeValue_Serialize(body, prefix+"InstanceInitiatedShutdownBehavior", params["InstanceInitiatedShutdownBehavior"]);
    if (params["InstanceType"] != null) AttributeValue_Serialize(body, prefix+"InstanceType", params["InstanceType"]);
    if (params["Kernel"] != null) AttributeValue_Serialize(body, prefix+"Kernel", params["Kernel"]);
    if (params["Ramdisk"] != null) AttributeValue_Serialize(body, prefix+"Ramdisk", params["Ramdisk"]);
    if (params["SriovNetSupport"] != null) AttributeValue_Serialize(body, prefix+"SriovNetSupport", params["SriovNetSupport"]);
    if (params["UserData"] != null) BlobAttributeValue_Serialize(body, prefix+"UserData", params["UserData"]);
    if ("Value" in params) body.append(prefix+"Value", (params["Value"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceAttribute",
    });
  }

  async modifyInstanceCapacityReservationAttributes(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceCapacityReservationAttributesRequest,
  ): Promise<s.ModifyInstanceCapacityReservationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    CapacityReservationSpecification_Serialize(body, prefix+"CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceCapacityReservationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyInstanceCreditSpecification(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceCreditSpecificationRequest,
  ): Promise<s.ModifyInstanceCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["InstanceCreditSpecifications"]) qsP.appendList(body, prefix+"InstanceCreditSpecification", params["InstanceCreditSpecifications"], {"appender":InstanceCreditSpecificationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulInstanceCreditSpecifications: xml.getList("successfulInstanceCreditSpecificationSet", "item").map(SuccessfulInstanceCreditSpecificationItem_Parse),
      UnsuccessfulInstanceCreditSpecifications: xml.getList("unsuccessfulInstanceCreditSpecificationSet", "item").map(UnsuccessfulInstanceCreditSpecificationItem_Parse),
    };
  }

  async modifyInstanceEventStartTime(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceEventStartTimeRequest,
  ): Promise<s.ModifyInstanceEventStartTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"InstanceEventId", (params["InstanceEventId"] ?? '').toString());
    body.append(prefix+"NotBefore", qsP.encodeDate_iso8601(params["NotBefore"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceEventStartTime",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Event: xml.first("event", false, InstanceStatusEvent_Parse),
    };
  }

  async modifyInstanceMetadataOptions(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceMetadataOptionsRequest,
  ): Promise<s.ModifyInstanceMetadataOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("HttpTokens" in params) body.append(prefix+"HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+"HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+"HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceMetadataOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      InstanceMetadataOptions: xml.first("instanceMetadataOptions", false, InstanceMetadataOptionsResponse_Parse),
    };
  }

  async modifyInstancePlacement(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstancePlacementRequest,
  ): Promise<s.ModifyInstancePlacementResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Affinity" in params) body.append(prefix+"Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+"HostId", (params["HostId"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+"Tenancy", (params["Tenancy"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+"PartitionNumber", (params["PartitionNumber"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+"HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstancePlacement",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & s.ModifyLaunchTemplateRequest = {},
  ): Promise<s.ModifyLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("DefaultVersion" in params) body.append(prefix+"SetDefaultVersion", (params["DefaultVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
    };
  }

  async modifyManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & s.ModifyManagedPrefixListRequest,
  ): Promise<s.ModifyManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("CurrentVersion" in params) body.append(prefix+"CurrentVersion", (params["CurrentVersion"] ?? '').toString());
    if ("PrefixListName" in params) body.append(prefix+"PrefixListName", (params["PrefixListName"] ?? '').toString());
    if (params["AddEntries"]) qsP.appendList(body, prefix+"AddEntry", params["AddEntries"], {"appender":AddPrefixListEntry_Serialize,"entryPrefix":"."})
    if (params["RemoveEntries"]) qsP.appendList(body, prefix+"RemoveEntry", params["RemoveEntries"], {"appender":RemovePrefixListEntry_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async modifyNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyNetworkInterfaceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Attachment"] != null) NetworkInterfaceAttachmentChanges_Serialize(body, prefix+"Attachment", params["Attachment"]);
    if (params["Description"] != null) AttributeValue_Serialize(body, prefix+"Description", params["Description"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["SourceDestCheck"] != null) AttributeBooleanValue_Serialize(body, prefix+"SourceDestCheck", params["SourceDestCheck"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyNetworkInterfaceAttribute",
    });
  }

  async modifyReservedInstances(
    {abortSignal, ...params}: RequestConfig & s.ModifyReservedInstancesRequest,
  ): Promise<s.ModifyReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"ReservedInstancesConfigurationSetItemType", params["TargetConfigurations"], {"appender":ReservedInstancesConfiguration_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesModificationId: xml.first("reservedInstancesModificationId", false, x => x.content ?? ''),
    };
  }

  async modifySnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifySnapshotAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["CreateVolumePermission"] != null) CreateVolumePermissionModifications_Serialize(body, prefix+"CreateVolumePermission", params["CreateVolumePermission"]);
    if (params["GroupNames"]) qsP.appendList(body, prefix+"UserGroup", params["GroupNames"], {"entryPrefix":"."})
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotAttribute",
    });
  }

  async modifySpotFleetRequest(
    {abortSignal, ...params}: RequestConfig & s.ModifySpotFleetRequestRequest,
  ): Promise<s.ModifySpotFleetRequestResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"LaunchTemplateConfig", params["LaunchTemplateConfigs"], {"appender":LaunchTemplateConfig_Serialize,"entryPrefix":"."})
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    if ("TargetCapacity" in params) body.append(prefix+"TargetCapacity", (params["TargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+"OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySpotFleetRequest",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifySubnetAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifySubnetAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AssignIpv6AddressOnCreation"] != null) AttributeBooleanValue_Serialize(body, prefix+"AssignIpv6AddressOnCreation", params["AssignIpv6AddressOnCreation"]);
    if (params["MapPublicIpOnLaunch"] != null) AttributeBooleanValue_Serialize(body, prefix+"MapPublicIpOnLaunch", params["MapPublicIpOnLaunch"]);
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["MapCustomerOwnedIpOnLaunch"] != null) AttributeBooleanValue_Serialize(body, prefix+"MapCustomerOwnedIpOnLaunch", params["MapCustomerOwnedIpOnLaunch"]);
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySubnetAttribute",
    });
  }

  async modifyTrafficMirrorFilterNetworkServices(
    {abortSignal, ...params}: RequestConfig & s.ModifyTrafficMirrorFilterNetworkServicesRequest,
  ): Promise<s.ModifyTrafficMirrorFilterNetworkServicesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if (params["AddNetworkServices"]) qsP.appendList(body, prefix+"AddNetworkService", params["AddNetworkServices"], {"entryPrefix":"."})
    if (params["RemoveNetworkServices"]) qsP.appendList(body, prefix+"RemoveNetworkService", params["RemoveNetworkServices"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorFilterNetworkServices",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilter: xml.first("trafficMirrorFilter", false, TrafficMirrorFilter_Parse),
    };
  }

  async modifyTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & s.ModifyTrafficMirrorFilterRuleRequest,
  ): Promise<s.ModifyTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterRuleId", (params["TrafficMirrorFilterRuleId"] ?? '').toString());
    if ("TrafficDirection" in params) body.append(prefix+"TrafficDirection", (params["TrafficDirection"] ?? '').toString());
    if ("RuleNumber" in params) body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    if ("RuleAction" in params) body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    if (params["DestinationPortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"DestinationPortRange", params["DestinationPortRange"]);
    if (params["SourcePortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"SourcePortRange", params["SourcePortRange"]);
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("SourceCidrBlock" in params) body.append(prefix+"SourceCidrBlock", (params["SourceCidrBlock"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["RemoveFields"]) qsP.appendList(body, prefix+"RemoveField", params["RemoveFields"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRule: xml.first("trafficMirrorFilterRule", false, TrafficMirrorFilterRule_Parse),
    };
  }

  async modifyTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & s.ModifyTrafficMirrorSessionRequest,
  ): Promise<s.ModifyTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorSessionId", (params["TrafficMirrorSessionId"] ?? '').toString());
    if ("TrafficMirrorTargetId" in params) body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    if ("TrafficMirrorFilterId" in params) body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("PacketLength" in params) body.append(prefix+"PacketLength", (params["PacketLength"] ?? '').toString());
    if ("SessionNumber" in params) body.append(prefix+"SessionNumber", (params["SessionNumber"] ?? '').toString());
    if ("VirtualNetworkId" in params) body.append(prefix+"VirtualNetworkId", (params["VirtualNetworkId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["RemoveFields"]) qsP.appendList(body, prefix+"RemoveField", params["RemoveFields"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSession: xml.first("trafficMirrorSession", false, TrafficMirrorSession_Parse),
    };
  }

  async modifyTransitGateway(
    {abortSignal, ...params}: RequestConfig & s.ModifyTransitGatewayRequest,
  ): Promise<s.ModifyTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Options"] != null) ModifyTransitGatewayOptions_Serialize(body, prefix+"Options", params["Options"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async modifyTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & s.ModifyTransitGatewayPrefixListReferenceRequest,
  ): Promise<s.ModifyTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async modifyTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & s.ModifyTransitGatewayVpcAttachmentRequest,
  ): Promise<s.ModifyTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["AddSubnetIds"]) qsP.appendList(body, prefix+"item", params["AddSubnetIds"], {"entryPrefix":"."})
    if (params["RemoveSubnetIds"]) qsP.appendList(body, prefix+"item", params["RemoveSubnetIds"], {"entryPrefix":"."})
    if (params["Options"] != null) ModifyTransitGatewayVpcAttachmentRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async modifyVolume(
    {abortSignal, ...params}: RequestConfig & s.ModifyVolumeRequest,
  ): Promise<s.ModifyVolumeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("Size" in params) body.append(prefix+"Size", (params["Size"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+"VolumeType", (params["VolumeType"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("Throughput" in params) body.append(prefix+"Throughput", (params["Throughput"] ?? '').toString());
    if ("MultiAttachEnabled" in params) body.append(prefix+"MultiAttachEnabled", (params["MultiAttachEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VolumeModification: xml.first("volumeModification", false, VolumeModification_Parse),
    };
  }

  async modifyVolumeAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyVolumeAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoEnableIO"] != null) AttributeBooleanValue_Serialize(body, prefix+"AutoEnableIO", params["AutoEnableIO"]);
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVolumeAttribute",
    });
  }

  async modifyVpcAttribute(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["EnableDnsHostnames"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnableDnsHostnames", params["EnableDnsHostnames"]);
    if (params["EnableDnsSupport"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnableDnsSupport", params["EnableDnsSupport"]);
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcAttribute",
    });
  }

  async modifyVpcEndpoint(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcEndpointRequest,
  ): Promise<s.ModifyVpcEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    if ("ResetPolicy" in params) body.append(prefix+"ResetPolicy", (params["ResetPolicy"] ?? '').toString());
    if ("PolicyDocument" in params) body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if (params["AddRouteTableIds"]) qsP.appendList(body, prefix+"AddRouteTableId", params["AddRouteTableIds"], {"entryPrefix":"."})
    if (params["RemoveRouteTableIds"]) qsP.appendList(body, prefix+"RemoveRouteTableId", params["RemoveRouteTableIds"], {"entryPrefix":"."})
    if (params["AddSubnetIds"]) qsP.appendList(body, prefix+"AddSubnetId", params["AddSubnetIds"], {"entryPrefix":"."})
    if (params["RemoveSubnetIds"]) qsP.appendList(body, prefix+"RemoveSubnetId", params["RemoveSubnetIds"], {"entryPrefix":"."})
    if (params["AddSecurityGroupIds"]) qsP.appendList(body, prefix+"AddSecurityGroupId", params["AddSecurityGroupIds"], {"entryPrefix":"."})
    if (params["RemoveSecurityGroupIds"]) qsP.appendList(body, prefix+"RemoveSecurityGroupId", params["RemoveSecurityGroupIds"], {"entryPrefix":"."})
    if ("PrivateDnsEnabled" in params) body.append(prefix+"PrivateDnsEnabled", (params["PrivateDnsEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointConnectionNotification(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcEndpointConnectionNotificationRequest,
  ): Promise<s.ModifyVpcEndpointConnectionNotificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ConnectionNotificationId", (params["ConnectionNotificationId"] ?? '').toString());
    if ("ConnectionNotificationArn" in params) body.append(prefix+"ConnectionNotificationArn", (params["ConnectionNotificationArn"] ?? '').toString());
    if (params["ConnectionEvents"]) qsP.appendList(body, prefix+"item", params["ConnectionEvents"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointConnectionNotification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointServiceConfiguration(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcEndpointServiceConfigurationRequest,
  ): Promise<s.ModifyVpcEndpointServiceConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if ("PrivateDnsName" in params) body.append(prefix+"PrivateDnsName", (params["PrivateDnsName"] ?? '').toString());
    if ("RemovePrivateDnsName" in params) body.append(prefix+"RemovePrivateDnsName", (params["RemovePrivateDnsName"] ?? '').toString());
    if ("AcceptanceRequired" in params) body.append(prefix+"AcceptanceRequired", (params["AcceptanceRequired"] ?? '').toString());
    if (params["AddNetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"AddNetworkLoadBalancerArn", params["AddNetworkLoadBalancerArns"], {"entryPrefix":"."})
    if (params["RemoveNetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"RemoveNetworkLoadBalancerArn", params["RemoveNetworkLoadBalancerArns"], {"entryPrefix":"."})
    if (params["AddGatewayLoadBalancerArns"]) qsP.appendList(body, prefix+"AddGatewayLoadBalancerArn", params["AddGatewayLoadBalancerArns"], {"entryPrefix":"."})
    if (params["RemoveGatewayLoadBalancerArns"]) qsP.appendList(body, prefix+"RemoveGatewayLoadBalancerArn", params["RemoveGatewayLoadBalancerArns"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointServiceConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointServicePermissions(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcEndpointServicePermissionsRequest,
  ): Promise<s.ModifyVpcEndpointServicePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["AddAllowedPrincipals"]) qsP.appendList(body, prefix+"item", params["AddAllowedPrincipals"], {"entryPrefix":"."})
    if (params["RemoveAllowedPrincipals"]) qsP.appendList(body, prefix+"item", params["RemoveAllowedPrincipals"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointServicePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcPeeringConnectionOptions(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcPeeringConnectionOptionsRequest,
  ): Promise<s.ModifyVpcPeeringConnectionOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AccepterPeeringConnectionOptions"] != null) PeeringConnectionOptionsRequest_Serialize(body, prefix+"AccepterPeeringConnectionOptions", params["AccepterPeeringConnectionOptions"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["RequesterPeeringConnectionOptions"] != null) PeeringConnectionOptionsRequest_Serialize(body, prefix+"RequesterPeeringConnectionOptions", params["RequesterPeeringConnectionOptions"]);
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcPeeringConnectionOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AccepterPeeringConnectionOptions: xml.first("accepterPeeringConnectionOptions", false, PeeringConnectionOptions_Parse),
      RequesterPeeringConnectionOptions: xml.first("requesterPeeringConnectionOptions", false, PeeringConnectionOptions_Parse),
    };
  }

  async modifyVpcTenancy(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpcTenancyRequest,
  ): Promise<s.ModifyVpcTenancyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcTenancy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpnConnection(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpnConnectionRequest,
  ): Promise<s.ModifyVpnConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("CustomerGatewayId" in params) body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    if ("VpnGatewayId" in params) body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnConnectionOptions(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpnConnectionOptionsRequest,
  ): Promise<s.ModifyVpnConnectionOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("LocalIpv4NetworkCidr" in params) body.append(prefix+"LocalIpv4NetworkCidr", (params["LocalIpv4NetworkCidr"] ?? '').toString());
    if ("RemoteIpv4NetworkCidr" in params) body.append(prefix+"RemoteIpv4NetworkCidr", (params["RemoteIpv4NetworkCidr"] ?? '').toString());
    if ("LocalIpv6NetworkCidr" in params) body.append(prefix+"LocalIpv6NetworkCidr", (params["LocalIpv6NetworkCidr"] ?? '').toString());
    if ("RemoteIpv6NetworkCidr" in params) body.append(prefix+"RemoteIpv6NetworkCidr", (params["RemoteIpv6NetworkCidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnConnectionOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnTunnelCertificate(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpnTunnelCertificateRequest,
  ): Promise<s.ModifyVpnTunnelCertificateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    body.append(prefix+"VpnTunnelOutsideIpAddress", (params["VpnTunnelOutsideIpAddress"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnTunnelCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnTunnelOptions(
    {abortSignal, ...params}: RequestConfig & s.ModifyVpnTunnelOptionsRequest,
  ): Promise<s.ModifyVpnTunnelOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    body.append(prefix+"VpnTunnelOutsideIpAddress", (params["VpnTunnelOutsideIpAddress"] ?? '').toString());
    ModifyVpnTunnelOptionsSpecification_Serialize(body, prefix+"TunnelOptions", params["TunnelOptions"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnTunnelOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async monitorInstances(
    {abortSignal, ...params}: RequestConfig & s.MonitorInstancesRequest,
  ): Promise<s.MonitorInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MonitorInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceMonitorings: xml.getList("instancesSet", "item").map(InstanceMonitoring_Parse),
    };
  }

  async moveAddressToVpc(
    {abortSignal, ...params}: RequestConfig & s.MoveAddressToVpcRequest,
  ): Promise<s.MoveAddressToVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MoveAddressToVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AllocationId: xml.first("allocationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, x => (x.content ?? '') as s.Status),
    };
  }

  async provisionByoipCidr(
    {abortSignal, ...params}: RequestConfig & s.ProvisionByoipCidrRequest,
  ): Promise<s.ProvisionByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if (params["CidrAuthorizationContext"] != null) CidrAuthorizationContext_Serialize(body, prefix+"CidrAuthorizationContext", params["CidrAuthorizationContext"]);
    if ("PubliclyAdvertisable" in params) body.append(prefix+"PubliclyAdvertisable", (params["PubliclyAdvertisable"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["PoolTagSpecifications"]) qsP.appendList(body, prefix+"PoolTagSpecification", params["PoolTagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ProvisionByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async purchaseHostReservation(
    {abortSignal, ...params}: RequestConfig & s.PurchaseHostReservationRequest,
  ): Promise<s.PurchaseHostReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("CurrencyCode" in params) body.append(prefix+"CurrencyCode", (params["CurrencyCode"] ?? '').toString());
    if (params["HostIdSet"]) qsP.appendList(body, prefix+"item", params["HostIdSet"], {"entryPrefix":"."})
    if ("LimitPrice" in params) body.append(prefix+"LimitPrice", (params["LimitPrice"] ?? '').toString());
    body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseHostReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      CurrencyCode: xml.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
      Purchase: xml.getList("purchase", "item").map(Purchase_Parse),
      TotalHourlyPrice: xml.first("totalHourlyPrice", false, x => x.content ?? ''),
      TotalUpfrontPrice: xml.first("totalUpfrontPrice", false, x => x.content ?? ''),
    };
  }

  async purchaseReservedInstancesOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseReservedInstancesOfferingRequest,
  ): Promise<s.PurchaseReservedInstancesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+"ReservedInstancesOfferingId", (params["ReservedInstancesOfferingId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LimitPrice"] != null) ReservedInstanceLimitPrice_Serialize(body, prefix+"LimitPrice", params["LimitPrice"]);
    if ("PurchaseTime" in params) body.append(prefix+"PurchaseTime", qsP.encodeDate_iso8601(params["PurchaseTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedInstancesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesId: xml.first("reservedInstancesId", false, x => x.content ?? ''),
    };
  }

  async purchaseScheduledInstances(
    {abortSignal, ...params}: RequestConfig & s.PurchaseScheduledInstancesRequest,
  ): Promise<s.PurchaseScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["PurchaseRequests"]) qsP.appendList(body, prefix+"PurchaseRequest", params["PurchaseRequests"], {"appender":PurchaseRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ScheduledInstanceSet: xml.getList("scheduledInstanceSet", "item").map(ScheduledInstance_Parse),
    };
  }

  async rebootInstances(
    {abortSignal, ...params}: RequestConfig & s.RebootInstancesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootInstances",
    });
  }

  async registerImage(
    {abortSignal, ...params}: RequestConfig & s.RegisterImageRequest,
  ): Promise<s.RegisterImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ImageLocation" in params) body.append(prefix+"ImageLocation", (params["ImageLocation"] ?? '').toString());
    if ("Architecture" in params) body.append(prefix+"Architecture", (params["Architecture"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EnaSupport" in params) body.append(prefix+"EnaSupport", (params["EnaSupport"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if (params["BillingProducts"]) qsP.appendList(body, prefix+"BillingProduct", params["BillingProducts"], {"entryPrefix":"."})
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("RootDeviceName" in params) body.append(prefix+"RootDeviceName", (params["RootDeviceName"] ?? '').toString());
    if ("SriovNetSupport" in params) body.append(prefix+"SriovNetSupport", (params["SriovNetSupport"] ?? '').toString());
    if ("VirtualizationType" in params) body.append(prefix+"VirtualizationType", (params["VirtualizationType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async registerInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & s.RegisterInstanceEventNotificationAttributesRequest = {},
  ): Promise<s.RegisterInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTagAttribute"] != null) RegisterInstanceTagAttributeRequest_Serialize(body, prefix+"InstanceTagAttribute", params["InstanceTagAttribute"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async registerTransitGatewayMulticastGroupMembers(
    {abortSignal, ...params}: RequestConfig & s.RegisterTransitGatewayMulticastGroupMembersRequest = {},
  ): Promise<s.RegisterTransitGatewayMulticastGroupMembersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTransitGatewayMulticastGroupMembers",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RegisteredMulticastGroupMembers: xml.first("registeredMulticastGroupMembers", false, TransitGatewayMulticastRegisteredGroupMembers_Parse),
    };
  }

  async registerTransitGatewayMulticastGroupSources(
    {abortSignal, ...params}: RequestConfig & s.RegisterTransitGatewayMulticastGroupSourcesRequest = {},
  ): Promise<s.RegisterTransitGatewayMulticastGroupSourcesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTransitGatewayMulticastGroupSources",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RegisteredMulticastGroupSources: xml.first("registeredMulticastGroupSources", false, TransitGatewayMulticastRegisteredGroupSources_Parse),
    };
  }

  async rejectTransitGatewayMulticastDomainAssociations(
    {abortSignal, ...params}: RequestConfig & s.RejectTransitGatewayMulticastDomainAssociationsRequest = {},
  ): Promise<s.RejectTransitGatewayMulticastDomainAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectTransitGatewayMulticastDomainAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async rejectTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & s.RejectTransitGatewayPeeringAttachmentRequest,
  ): Promise<s.RejectTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async rejectTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & s.RejectTransitGatewayVpcAttachmentRequest,
  ): Promise<s.RejectTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async rejectVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & s.RejectVpcEndpointConnectionsRequest,
  ): Promise<s.RejectVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async rejectVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.RejectVpcPeeringConnectionRequest,
  ): Promise<s.RejectVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async releaseAddress(
    {abortSignal, ...params}: RequestConfig & s.ReleaseAddressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllocationId" in params) body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("NetworkBorderGroup" in params) body.append(prefix+"NetworkBorderGroup", (params["NetworkBorderGroup"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReleaseAddress",
    });
  }

  async releaseHosts(
    {abortSignal, ...params}: RequestConfig & s.ReleaseHostsRequest,
  ): Promise<s.ReleaseHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReleaseHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async replaceIamInstanceProfileAssociation(
    {abortSignal, ...params}: RequestConfig & s.ReplaceIamInstanceProfileAssociationRequest,
  ): Promise<s.ReplaceIamInstanceProfileAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceIamInstanceProfileAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async replaceNetworkAclAssociation(
    {abortSignal, ...params}: RequestConfig & s.ReplaceNetworkAclAssociationRequest,
  ): Promise<s.ReplaceNetworkAclAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceNetworkAclAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NewAssociationId: xml.first("newAssociationId", false, x => x.content ?? ''),
    };
  }

  async replaceNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & s.ReplaceNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    if (params["IcmpTypeCode"] != null) IcmpTypeCode_Serialize(body, prefix+"Icmp", params["IcmpTypeCode"]);
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    if (params["PortRange"] != null) PortRange_Serialize(body, prefix+"PortRange", params["PortRange"]);
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceNetworkAclEntry",
    });
  }

  async replaceRoute(
    {abortSignal, ...params}: RequestConfig & s.ReplaceRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcEndpointId" in params) body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    if ("EgressOnlyInternetGatewayId" in params) body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("LocalTarget" in params) body.append(prefix+"LocalTarget", (params["LocalTarget"] ?? '').toString());
    if ("NatGatewayId" in params) body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("LocalGatewayId" in params) body.append(prefix+"LocalGatewayId", (params["LocalGatewayId"] ?? '').toString());
    if ("CarrierGatewayId" in params) body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceRoute",
    });
  }

  async replaceRouteTableAssociation(
    {abortSignal, ...params}: RequestConfig & s.ReplaceRouteTableAssociationRequest,
  ): Promise<s.ReplaceRouteTableAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceRouteTableAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NewAssociationId: xml.first("newAssociationId", false, x => x.content ?? ''),
      AssociationState: xml.first("associationState", false, RouteTableAssociationState_Parse),
    };
  }

  async replaceTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.ReplaceTransitGatewayRouteRequest,
  ): Promise<s.ReplaceTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async reportInstanceStatus(
    {abortSignal, ...params}: RequestConfig & s.ReportInstanceStatusRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if (params["Instances"]) qsP.appendList(body, prefix+"instanceId", params["Instances"], {"entryPrefix":"."})
    if (params["ReasonCodes"]) qsP.appendList(body, prefix+"reasonCode", params["ReasonCodes"], {"entryPrefix":"."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReportInstanceStatus",
    });
  }

  async requestSpotFleet(
    {abortSignal, ...params}: RequestConfig & s.RequestSpotFleetRequest,
  ): Promise<s.RequestSpotFleetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    SpotFleetRequestConfigData_Serialize(body, prefix+"SpotFleetRequestConfig", params["SpotFleetRequestConfig"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestSpotFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
    };
  }

  async requestSpotInstances(
    {abortSignal, ...params}: RequestConfig & s.RequestSpotInstancesRequest = {},
  ): Promise<s.RequestSpotInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZoneGroup" in params) body.append(prefix+"AvailabilityZoneGroup", (params["AvailabilityZoneGroup"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+"BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("LaunchGroup" in params) body.append(prefix+"LaunchGroup", (params["LaunchGroup"] ?? '').toString());
    if (params["LaunchSpecification"] != null) RequestSpotLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    if ("SpotPrice" in params) body.append(prefix+"SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+"ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+"ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+"InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestSpotInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(SpotInstanceRequest_Parse),
    };
  }

  async resetAddressAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetAddressAttributeRequest,
  ): Promise<s.ResetAddressAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetAddressAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Address: xml.first("address", false, AddressAttribute_Parse),
    };
  }

  async resetEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & s.ResetEbsDefaultKmsKeyIdRequest = {},
  ): Promise<s.ResetEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async resetFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetFpgaImageAttributeRequest,
  ): Promise<s.ResetFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async resetImageAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetImageAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetImageAttribute",
    });
  }

  async resetInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetInstanceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetInstanceAttribute",
    });
  }

  async resetNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetNetworkInterfaceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("SourceDestCheck" in params) body.append(prefix+"SourceDestCheck", (params["SourceDestCheck"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetNetworkInterfaceAttribute",
    });
  }

  async resetSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & s.ResetSnapshotAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetSnapshotAttribute",
    });
  }

  async restoreAddressToClassic(
    {abortSignal, ...params}: RequestConfig & s.RestoreAddressToClassicRequest,
  ): Promise<s.RestoreAddressToClassicResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreAddressToClassic",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIp: xml.first("publicIp", false, x => x.content ?? ''),
      Status: xml.first("status", false, x => (x.content ?? '') as s.Status),
    };
  }

  async restoreManagedPrefixListVersion(
    {abortSignal, ...params}: RequestConfig & s.RestoreManagedPrefixListVersionRequest,
  ): Promise<s.RestoreManagedPrefixListVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    body.append(prefix+"PreviousVersion", (params["PreviousVersion"] ?? '').toString());
    body.append(prefix+"CurrentVersion", (params["CurrentVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreManagedPrefixListVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async revokeClientVpnIngress(
    {abortSignal, ...params}: RequestConfig & s.RevokeClientVpnIngressRequest,
  ): Promise<s.RevokeClientVpnIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"TargetNetworkCidr", (params["TargetNetworkCidr"] ?? '').toString());
    if ("AccessGroupId" in params) body.append(prefix+"AccessGroupId", (params["AccessGroupId"] ?? '').toString());
    if ("RevokeAllGroups" in params) body.append(prefix+"RevokeAllGroups", (params["RevokeAllGroups"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeClientVpnIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
    };
  }

  async revokeSecurityGroupEgress(
    {abortSignal, ...params}: RequestConfig & s.RevokeSecurityGroupEgressRequest,
  ): Promise<s.RevokeSecurityGroupEgressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"ipPermissions", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSecurityGroupEgress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
      UnknownIpPermissions: xml.getList("unknownIpPermissionSet", "item").map(IpPermission_Parse),
    };
  }

  async revokeSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.RevokeSecurityGroupIngressRequest = {},
  ): Promise<s.RevokeSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
      UnknownIpPermissions: xml.getList("unknownIpPermissionSet", "item").map(IpPermission_Parse),
    };
  }

  async runInstances(
    {abortSignal, ...params}: RequestConfig & s.RunInstancesRequest,
  ): Promise<s.Reservation> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("ImageId" in params) body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"Ipv6Address", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    body.append(prefix+"MaxCount", (params["MaxCount"] ?? '').toString());
    body.append(prefix+"MinCount", (params["MinCount"] ?? '').toString());
    if (params["Monitoring"] != null) RunInstancesMonitoringEnabled_Serialize(body, prefix+"Monitoring", params["Monitoring"]);
    if (params["Placement"] != null) Placement_Serialize(body, prefix+"Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if ("SubnetId" in params) body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+"UserData", (params["UserData"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DisableApiTermination" in params) body.append(prefix+"DisableApiTermination", (params["DisableApiTermination"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+"InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+"networkInterface", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["ElasticGpuSpecification"]) qsP.appendList(body, prefix+"item", params["ElasticGpuSpecification"], {"appender":ElasticGpuSpecification_Serialize,"entryPrefix":"."})
    if (params["ElasticInferenceAccelerators"]) qsP.appendList(body, prefix+"ElasticInferenceAccelerator", params["ElasticInferenceAccelerators"], {"appender":ElasticInferenceAccelerator_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["InstanceMarketOptions"] != null) InstanceMarketOptionsRequest_Serialize(body, prefix+"InstanceMarketOptions", params["InstanceMarketOptions"]);
    if (params["CreditSpecification"] != null) CreditSpecificationRequest_Serialize(body, prefix+"CreditSpecification", params["CreditSpecification"]);
    if (params["CpuOptions"] != null) CpuOptionsRequest_Serialize(body, prefix+"CpuOptions", params["CpuOptions"]);
    if (params["CapacityReservationSpecification"] != null) CapacityReservationSpecification_Serialize(body, prefix+"CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if (params["HibernationOptions"] != null) HibernationOptionsRequest_Serialize(body, prefix+"HibernationOptions", params["HibernationOptions"]);
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+"LicenseSpecification", params["LicenseSpecifications"], {"appender":LicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["MetadataOptions"] != null) InstanceMetadataOptionsRequest_Serialize(body, prefix+"MetadataOptions", params["MetadataOptions"]);
    if (params["EnclaveOptions"] != null) EnclaveOptionsRequest_Serialize(body, prefix+"EnclaveOptions", params["EnclaveOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Reservation_Parse(xml);
  }

  async runScheduledInstances(
    {abortSignal, ...params}: RequestConfig & s.RunScheduledInstancesRequest,
  ): Promise<s.RunScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    ScheduledInstancesLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    body.append(prefix+"ScheduledInstanceId", (params["ScheduledInstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceIdSet: xml.getList("instanceIdSet", "item").map(x => x.content ?? ''),
    };
  }

  async searchLocalGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & s.SearchLocalGatewayRoutesRequest,
  ): Promise<s.SearchLocalGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchLocalGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routeSet", "item").map(LocalGatewayRoute_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async searchTransitGatewayMulticastGroups(
    {abortSignal, ...params}: RequestConfig & s.SearchTransitGatewayMulticastGroupsRequest = {},
  ): Promise<s.SearchTransitGatewayMulticastGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTransitGatewayMulticastGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MulticastGroups: xml.getList("multicastGroups", "item").map(TransitGatewayMulticastGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async searchTransitGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & s.SearchTransitGatewayRoutesRequest,
  ): Promise<s.SearchTransitGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTransitGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routeSet", "item").map(TransitGatewayRoute_Parse),
      AdditionalRoutesAvailable: xml.first("additionalRoutesAvailable", false, x => x.content === 'true'),
    };
  }

  async sendDiagnosticInterrupt(
    {abortSignal, ...params}: RequestConfig & s.SendDiagnosticInterruptRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendDiagnosticInterrupt",
    });
  }

  async startInstances(
    {abortSignal, ...params}: RequestConfig & s.StartInstancesRequest,
  ): Promise<s.StartInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      StartingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async startNetworkInsightsAnalysis(
    {abortSignal, ...params}: RequestConfig & s.StartNetworkInsightsAnalysisRequest,
  ): Promise<s.StartNetworkInsightsAnalysisResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInsightsPathId", (params["NetworkInsightsPathId"] ?? '').toString());
    if (params["FilterInArns"]) qsP.appendList(body, prefix+"FilterInArn", params["FilterInArns"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNetworkInsightsAnalysis",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInsightsAnalysis: xml.first("networkInsightsAnalysis", false, NetworkInsightsAnalysis_Parse),
    };
  }

  async startVpcEndpointServicePrivateDnsVerification(
    {abortSignal, ...params}: RequestConfig & s.StartVpcEndpointServicePrivateDnsVerificationRequest,
  ): Promise<s.StartVpcEndpointServicePrivateDnsVerificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartVpcEndpointServicePrivateDnsVerification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async stopInstances(
    {abortSignal, ...params}: RequestConfig & s.StopInstancesRequest,
  ): Promise<s.StopInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("Hibernate" in params) body.append(prefix+"Hibernate", (params["Hibernate"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      StoppingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async terminateClientVpnConnections(
    {abortSignal, ...params}: RequestConfig & s.TerminateClientVpnConnectionsRequest,
  ): Promise<s.TerminateClientVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("ConnectionId" in params) body.append(prefix+"ConnectionId", (params["ConnectionId"] ?? '').toString());
    if ("Username" in params) body.append(prefix+"Username", (params["Username"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateClientVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpointId: xml.first("clientVpnEndpointId", false, x => x.content ?? ''),
      Username: xml.first("username", false, x => x.content ?? ''),
      ConnectionStatuses: xml.getList("connectionStatuses", "item").map(TerminateConnectionStatus_Parse),
    };
  }

  async terminateInstances(
    {abortSignal, ...params}: RequestConfig & s.TerminateInstancesRequest,
  ): Promise<s.TerminateInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TerminatingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async unassignIpv6Addresses(
    {abortSignal, ...params}: RequestConfig & s.UnassignIpv6AddressesRequest,
  ): Promise<s.UnassignIpv6AddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignIpv6Addresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      UnassignedIpv6Addresses: xml.getList("unassignedIpv6Addresses", "item").map(x => x.content ?? ''),
    };
  }

  async unassignPrivateIpAddresses(
    {abortSignal, ...params}: RequestConfig & s.UnassignPrivateIpAddressesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddress", params["PrivateIpAddresses"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignPrivateIpAddresses",
    });
  }

  async unmonitorInstances(
    {abortSignal, ...params}: RequestConfig & s.UnmonitorInstancesRequest,
  ): Promise<s.UnmonitorInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnmonitorInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceMonitorings: xml.getList("instancesSet", "item").map(InstanceMonitoring_Parse),
    };
  }

  async updateSecurityGroupRuleDescriptionsEgress(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecurityGroupRuleDescriptionsEgressRequest,
  ): Promise<s.UpdateSecurityGroupRuleDescriptionsEgressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecurityGroupRuleDescriptionsEgress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async updateSecurityGroupRuleDescriptionsIngress(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecurityGroupRuleDescriptionsIngressRequest,
  ): Promise<s.UpdateSecurityGroupRuleDescriptionsIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecurityGroupRuleDescriptionsIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async withdrawByoipCidr(
    {abortSignal, ...params}: RequestConfig & s.WithdrawByoipCidrRequest,
  ): Promise<s.WithdrawByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "WithdrawByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForInstanceExists(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        if ((resp?.Reservations || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForBundleTaskComplete(
    params: RequestConfig & s.DescribeBundleTasksRequest,
  ): Promise<s.DescribeBundleTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BundleTaskComplete';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeBundleTasks(params);
      const field = resp?.BundleTasks?.flatMap(x => x?.State);
      if (field?.every(x => x === "complete")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForConversionTaskCancelled(
    params: RequestConfig & s.DescribeConversionTasksRequest,
  ): Promise<s.DescribeConversionTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConversionTaskCancelled';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeConversionTasks(params);
      if (resp?.ConversionTasks?.flatMap(x => x?.State)?.every(x => x === "cancelled")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForConversionTaskCompleted(
    params: RequestConfig & s.DescribeConversionTasksRequest,
  ): Promise<s.DescribeConversionTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConversionTaskCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeConversionTasks(params);
      const field = resp?.ConversionTasks?.flatMap(x => x?.State);
      if (field?.every(x => x === "completed")) return resp;
      if (field?.some(x => x === "cancelled")) throw new Error(errMessage);
      if (field?.some(x => x === "cancelling")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForCustomerGatewayAvailable(
    params: RequestConfig & s.DescribeCustomerGatewaysRequest,
  ): Promise<s.DescribeCustomerGatewaysResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CustomerGatewayAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCustomerGateways(params);
      const field = resp?.CustomerGateways?.flatMap(x => x?.State);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForExportTaskCancelled(
    params: RequestConfig & s.DescribeExportTasksRequest,
  ): Promise<s.DescribeExportTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ExportTaskCancelled';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeExportTasks(params);
      if (resp?.ExportTasks?.flatMap(x => x?.State)?.every(x => x === "cancelled")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForExportTaskCompleted(
    params: RequestConfig & s.DescribeExportTasksRequest,
  ): Promise<s.DescribeExportTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ExportTaskCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeExportTasks(params);
      if (resp?.ExportTasks?.flatMap(x => x?.State)?.every(x => x === "completed")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForImageExists(
    params: RequestConfig & s.DescribeImagesRequest,
  ): Promise<s.DescribeImagesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeImages(params);
        if ((resp?.Images || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidAMIID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForImageAvailable(
    params: RequestConfig & s.DescribeImagesRequest,
  ): Promise<s.DescribeImagesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeImages(params);
      const field = resp?.Images?.flatMap(x => x?.State);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceRunning(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceRunning';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
        if (field?.every(x => x === "running")) return resp;
        if (field?.some(x => x === "shutting-down")) throw new Error(errMessage);
        if (field?.some(x => x === "terminated")) throw new Error(errMessage);
        if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceStatusOk(
    params: RequestConfig & s.DescribeInstanceStatusRequest,
  ): Promise<s.DescribeInstanceStatusResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStatusOk';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstanceStatus(params);
        if (resp?.InstanceStatuses?.flatMap(x => x?.InstanceStatus?.Status)?.every(x => x === "ok")) return resp;
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceStopped(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStopped';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
      if (field?.every(x => x === "stopped")) return resp;
      if (field?.some(x => x === "pending")) throw new Error(errMessage);
      if (field?.some(x => x === "terminated")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceTerminated(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceTerminated';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
      if (field?.every(x => x === "terminated")) return resp;
      if (field?.some(x => x === "pending")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 6 times, 5 seconds apart (about 1 minutes max wait time). */
  async waitForKeyPairExists(
    params: RequestConfig & s.DescribeKeyPairsRequest,
  ): Promise<s.DescribeKeyPairsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state KeyPairExists';
    for (let i = 0; i < 6; i++) {
      try {
        const resp = await this.describeKeyPairs(params);
        if ((resp?.KeyPairs?.flatMap(x => x?.KeyName) || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidKeyPair.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForNatGatewayAvailable(
    params: RequestConfig & s.DescribeNatGatewaysRequest,
  ): Promise<s.DescribeNatGatewaysResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NatGatewayAvailable';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeNatGateways(params);
        const field = resp?.NatGateways?.flatMap(x => x?.State);
        if (field?.every(x => x === "available")) return resp;
        if (field?.some(x => x === "failed")) throw new Error(errMessage);
        if (field?.some(x => x === "deleting")) throw new Error(errMessage);
        if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      } catch (err) {
        if (!["NatGatewayNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 10 times, 20 seconds apart (about 4 minutes max wait time). */
  async waitForNetworkInterfaceAvailable(
    params: RequestConfig & s.DescribeNetworkInterfacesRequest,
  ): Promise<s.DescribeNetworkInterfacesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NetworkInterfaceAvailable';
    for (let i = 0; i < 10; i++) {
      try {
        const resp = await this.describeNetworkInterfaces(params);
        if (resp?.NetworkInterfaces?.flatMap(x => x?.Status)?.every(x => x === "available")) return resp;
      } catch (err) {
        if (["InvalidNetworkInterfaceID.NotFound"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForPasswordDataAvailable(
    params: RequestConfig & s.GetPasswordDataRequest,
  ): Promise<s.GetPasswordDataResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state PasswordDataAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.getPasswordData(params);
      if ((resp?.PasswordData || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSnapshotCompleted(
    params: RequestConfig & s.DescribeSnapshotsRequest,
  ): Promise<s.DescribeSnapshotsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SnapshotCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeSnapshots(params);
      if (resp?.Snapshots?.flatMap(x => x?.State)?.every(x => x === "completed")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 6 times, 5 seconds apart (about 1 minutes max wait time). */
  async waitForSecurityGroupExists(
    params: RequestConfig & s.DescribeSecurityGroupsRequest,
  ): Promise<s.DescribeSecurityGroupsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SecurityGroupExists';
    for (let i = 0; i < 6; i++) {
      try {
        const resp = await this.describeSecurityGroups(params);
        if ((resp?.SecurityGroups?.flatMap(x => x?.GroupId) || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidGroupNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSpotInstanceRequestFulfilled(
    params: RequestConfig & s.DescribeSpotInstanceRequestsRequest,
  ): Promise<s.DescribeSpotInstanceRequestsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SpotInstanceRequestFulfilled';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeSpotInstanceRequests(params);
        const field = resp?.SpotInstanceRequests?.flatMap(x => x?.Status?.Code);
        if (field?.every(x => x === "fulfilled")) return resp;
        if (field?.every(x => x === "request-canceled-and-instance-running")) return resp;
        if (field?.some(x => x === "schedule-expired")) throw new Error(errMessage);
        if (field?.some(x => x === "canceled-before-fulfillment")) throw new Error(errMessage);
        if (field?.some(x => x === "bad-parameters")) throw new Error(errMessage);
        if (field?.some(x => x === "system-error")) throw new Error(errMessage);
      } catch (err) {
        if (!["InvalidSpotInstanceRequestID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSubnetAvailable(
    params: RequestConfig & s.DescribeSubnetsRequest,
  ): Promise<s.DescribeSubnetsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SubnetAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeSubnets(params);
      if (resp?.Subnets?.flatMap(x => x?.State)?.every(x => x === "available")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSystemStatusOk(
    params: RequestConfig & s.DescribeInstanceStatusRequest,
  ): Promise<s.DescribeInstanceStatusResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SystemStatusOk';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstanceStatus(params);
      if (resp?.InstanceStatuses?.flatMap(x => x?.SystemStatus?.Status)?.every(x => x === "ok")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeAvailable(
    params: RequestConfig & s.DescribeVolumesRequest,
  ): Promise<s.DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVolumes(params);
      const field = resp?.Volumes?.flatMap(x => x?.State);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeDeleted(
    params: RequestConfig & s.DescribeVolumesRequest,
  ): Promise<Error | s.DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVolumes(params);
        if (resp?.Volumes?.flatMap(x => x?.State)?.every(x => x === "deleted")) return resp;
      } catch (err) {
        if (["InvalidVolume.NotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeInUse(
    params: RequestConfig & s.DescribeVolumesRequest,
  ): Promise<s.DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeInUse';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVolumes(params);
      const field = resp?.Volumes?.flatMap(x => x?.State);
      if (field?.every(x => x === "in-use")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcAvailable(
    params: RequestConfig & s.DescribeVpcsRequest,
  ): Promise<s.DescribeVpcsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpcs(params);
      if (resp?.Vpcs?.flatMap(x => x?.State)?.every(x => x === "available")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 5 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForVpcExists(
    params: RequestConfig & s.DescribeVpcsRequest,
  ): Promise<s.DescribeVpcsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcExists';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeVpcs(params);
        return resp; // for status 200
      } catch (err) {
        if (!["InvalidVpcID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpnConnectionAvailable(
    params: RequestConfig & s.DescribeVpnConnectionsRequest,
  ): Promise<s.DescribeVpnConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpnConnectionAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpnConnections(params);
      const field = resp?.VpnConnections?.flatMap(x => x?.State);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpnConnectionDeleted(
    params: RequestConfig & s.DescribeVpnConnectionsRequest,
  ): Promise<s.DescribeVpnConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpnConnectionDeleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpnConnections(params);
      const field = resp?.VpnConnections?.flatMap(x => x?.State);
      if (field?.every(x => x === "deleted")) return resp;
      if (field?.some(x => x === "pending")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcPeeringConnectionExists(
    params: RequestConfig & s.DescribeVpcPeeringConnectionsRequest,
  ): Promise<s.DescribeVpcPeeringConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcPeeringConnectionExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVpcPeeringConnections(params);
        return resp; // for status 200
      } catch (err) {
        if (!["InvalidVpcPeeringConnectionID.NotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcPeeringConnectionDeleted(
    params: RequestConfig & s.DescribeVpcPeeringConnectionsRequest,
  ): Promise<Error | s.DescribeVpcPeeringConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcPeeringConnectionDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVpcPeeringConnections(params);
        if (resp?.VpcPeeringConnections?.flatMap(x => x?.Status?.Code)?.every(x => x === "deleted")) return resp;
      } catch (err) {
        if (["InvalidVpcPeeringConnectionID.NotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 15 times, 60 seconds apart (about 15 minutes max wait time). */
  async waitForConsoleOutputAvailable(
    params: RequestConfig & s.GetConsoleOutputRequest,
  ): Promise<s.GetConsoleOutputResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConsoleOutputAvailable';
    for (let i = 0; i < 15; i++) {
      const resp = await this.getConsoleOutput(params);
      if ((resp?.Output || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

function VolumeAttachment_Parse(node: xmlP.XmlNode): s.VolumeAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    Device: node.first("device", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    State: node.first("status", false, x => (x.content ?? '') as s.VolumeAttachmentState),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
  };
}

function Snapshot_Parse(node: xmlP.XmlNode): s.Snapshot {
  return {
    DataEncryptionKeyId: node.first("dataEncryptionKeyId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("status", false, x => (x.content ?? '') as s.SnapshotState),
    StateMessage: node.first("statusMessage", false, x => x.content ?? ''),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function Volume_Parse(node: xmlP.XmlNode): s.Volume {
  return {
    Attachments: node.getList("attachmentSet", "item").map(VolumeAttachment_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    State: node.first("status", false, x => (x.content ?? '') as s.VolumeState),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as s.VolumeType),
    FastRestored: node.first("fastRestored", false, x => x.content === 'true'),
    MultiAttachEnabled: node.first("multiAttachEnabled", false, x => x.content === 'true'),
    Throughput: node.first("throughput", false, x => parseInt(x.content ?? '0')),
  };
}

function Reservation_Parse(node: xmlP.XmlNode): s.Reservation {
  return {
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    Instances: node.getList("instancesSet", "item").map(Instance_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    RequesterId: node.first("requesterId", false, x => x.content ?? ''),
    ReservationId: node.first("reservationId", false, x => x.content ?? ''),
  };
}

function TargetConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.TargetConfigurationRequest) {
    if ("InstanceCount" in params) body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+".OfferingId", (params["OfferingId"] ?? '').toString());
}

function TagSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.TagSpecification) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}
function TagSpecification_Parse(node: xmlP.XmlNode): s.TagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.ResourceType),
    Tags: node.getList("Tag", "item").map(Tag_Parse),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function IamInstanceProfileSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.IamInstanceProfileSpecification) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function IamInstanceProfileSpecification_Parse(node: xmlP.XmlNode): s.IamInstanceProfileSpecification {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

function IpPermission_Serialize(body: URLSearchParams, prefix: string, params: s.IpPermission) {
    if ("FromPort" in params) body.append(prefix+".FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+".IpProtocol", (params["IpProtocol"] ?? '').toString());
    if (params["IpRanges"]) qsP.appendList(body, prefix+".ipRanges", params["IpRanges"], {"appender":IpRange_Serialize,"entryPrefix":"."})
    if (params["Ipv6Ranges"]) qsP.appendList(body, prefix+".ipv6Ranges", params["Ipv6Ranges"], {"appender":Ipv6Range_Serialize,"entryPrefix":"."})
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+".prefixListIds", params["PrefixListIds"], {"appender":PrefixListId_Serialize,"entryPrefix":"."})
    if ("ToPort" in params) body.append(prefix+".ToPort", (params["ToPort"] ?? '').toString());
    if (params["UserIdGroupPairs"]) qsP.appendList(body, prefix+".groups", params["UserIdGroupPairs"], {"appender":UserIdGroupPair_Serialize,"entryPrefix":"."})
}
function IpPermission_Parse(node: xmlP.XmlNode): s.IpPermission {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    IpProtocol: node.first("ipProtocol", false, x => x.content ?? ''),
    IpRanges: node.getList("ipRanges", "item").map(IpRange_Parse),
    Ipv6Ranges: node.getList("ipv6Ranges", "item").map(Ipv6Range_Parse),
    PrefixListIds: node.getList("prefixListIds", "item").map(PrefixListId_Parse),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
    UserIdGroupPairs: node.getList("groups", "item").map(UserIdGroupPair_Parse),
  };
}

function IpRange_Serialize(body: URLSearchParams, prefix: string, params: s.IpRange) {
    if ("CidrIp" in params) body.append(prefix+".CidrIp", (params["CidrIp"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}
function IpRange_Parse(node: xmlP.XmlNode): s.IpRange {
  return {
    CidrIp: node.first("cidrIp", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

function Ipv6Range_Serialize(body: URLSearchParams, prefix: string, params: s.Ipv6Range) {
    if ("CidrIpv6" in params) body.append(prefix+".CidrIpv6", (params["CidrIpv6"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}
function Ipv6Range_Parse(node: xmlP.XmlNode): s.Ipv6Range {
  return {
    CidrIpv6: node.first("cidrIpv6", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

function PrefixListId_Serialize(body: URLSearchParams, prefix: string, params: s.PrefixListId) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("PrefixListId" in params) body.append(prefix+".PrefixListId", (params["PrefixListId"] ?? '').toString());
}
function PrefixListId_Parse(node: xmlP.XmlNode): s.PrefixListId {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
  };
}

function UserIdGroupPair_Serialize(body: URLSearchParams, prefix: string, params: s.UserIdGroupPair) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+".GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("PeeringStatus" in params) body.append(prefix+".PeeringStatus", (params["PeeringStatus"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+".VpcId", (params["VpcId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+".VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
}
function UserIdGroupPair_Parse(node: xmlP.XmlNode): s.UserIdGroupPair {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    PeeringStatus: node.first("peeringStatus", false, x => x.content ?? ''),
    UserId: node.first("userId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

function Storage_Serialize(body: URLSearchParams, prefix: string, params: s.Storage) {
    if (params["S3"] != null) S3Storage_Serialize(body, prefix+".S3", params["S3"]);
}
function Storage_Parse(node: xmlP.XmlNode): s.Storage {
  return {
    S3: node.first("S3", false, S3Storage_Parse),
  };
}

function S3Storage_Serialize(body: URLSearchParams, prefix: string, params: s.S3Storage) {
    if ("AWSAccessKeyId" in params) body.append(prefix+".AWSAccessKeyId", (params["AWSAccessKeyId"] ?? '').toString());
    if ("Bucket" in params) body.append(prefix+".Bucket", (params["Bucket"] ?? '').toString());
    if ("Prefix" in params) body.append(prefix+".Prefix", (params["Prefix"] ?? '').toString());
    if ("UploadPolicy" in params) body.append(prefix+".UploadPolicy", serializeBlob(params["UploadPolicy"]) ?? '');
    if ("UploadPolicySignature" in params) body.append(prefix+".UploadPolicySignature", (params["UploadPolicySignature"] ?? '').toString());
}
function S3Storage_Parse(node: xmlP.XmlNode): s.S3Storage {
  return {
    ...node.strings({
      optional: {"AWSAccessKeyId":true},
    }),
    Bucket: node.first("bucket", false, x => x.content ?? ''),
    Prefix: node.first("prefix", false, x => x.content ?? ''),
    UploadPolicy: node.first("uploadPolicy", false, x => parseBlob(x.content) ?? ''),
    UploadPolicySignature: node.first("uploadPolicySignature", false, x => x.content ?? ''),
  };
}

function ClientVpnAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.ClientVpnAuthenticationRequest) {
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if (params["ActiveDirectory"] != null) DirectoryServiceAuthenticationRequest_Serialize(body, prefix+".ActiveDirectory", params["ActiveDirectory"]);
    if (params["MutualAuthentication"] != null) CertificateAuthenticationRequest_Serialize(body, prefix+".MutualAuthentication", params["MutualAuthentication"]);
    if (params["FederatedAuthentication"] != null) FederatedAuthenticationRequest_Serialize(body, prefix+".FederatedAuthentication", params["FederatedAuthentication"]);
}

function DirectoryServiceAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.DirectoryServiceAuthenticationRequest) {
    if ("DirectoryId" in params) body.append(prefix+".DirectoryId", (params["DirectoryId"] ?? '').toString());
}

function CertificateAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.CertificateAuthenticationRequest) {
    if ("ClientRootCertificateChainArn" in params) body.append(prefix+".ClientRootCertificateChainArn", (params["ClientRootCertificateChainArn"] ?? '').toString());
}

function FederatedAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FederatedAuthenticationRequest) {
    if ("SAMLProviderArn" in params) body.append(prefix+".SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    if ("SelfServiceSAMLProviderArn" in params) body.append(prefix+".SelfServiceSAMLProviderArn", (params["SelfServiceSAMLProviderArn"] ?? '').toString());
}

function ConnectionLogOptions_Serialize(body: URLSearchParams, prefix: string, params: s.ConnectionLogOptions) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("CloudwatchLogGroup" in params) body.append(prefix+".CloudwatchLogGroup", (params["CloudwatchLogGroup"] ?? '').toString());
    if ("CloudwatchLogStream" in params) body.append(prefix+".CloudwatchLogStream", (params["CloudwatchLogStream"] ?? '').toString());
}

function ClientConnectOptions_Serialize(body: URLSearchParams, prefix: string, params: s.ClientConnectOptions) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("LambdaFunctionArn" in params) body.append(prefix+".LambdaFunctionArn", (params["LambdaFunctionArn"] ?? '').toString());
}

function NewDhcpConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.NewDhcpConfiguration) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":"."})
}

function SpotOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.SpotOptionsRequest) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if (params["MaintenanceStrategies"] != null) FleetSpotMaintenanceStrategiesRequest_Serialize(body, prefix+".MaintenanceStrategies", params["MaintenanceStrategies"]);
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    if ("InstancePoolsToUseCount" in params) body.append(prefix+".InstancePoolsToUseCount", (params["InstancePoolsToUseCount"] ?? '').toString());
    if ("SingleInstanceType" in params) body.append(prefix+".SingleInstanceType", (params["SingleInstanceType"] ?? '').toString());
    if ("SingleAvailabilityZone" in params) body.append(prefix+".SingleAvailabilityZone", (params["SingleAvailabilityZone"] ?? '').toString());
    if ("MinTargetCapacity" in params) body.append(prefix+".MinTargetCapacity", (params["MinTargetCapacity"] ?? '').toString());
    if ("MaxTotalPrice" in params) body.append(prefix+".MaxTotalPrice", (params["MaxTotalPrice"] ?? '').toString());
}

function FleetSpotMaintenanceStrategiesRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FleetSpotMaintenanceStrategiesRequest) {
    if (params["CapacityRebalance"] != null) FleetSpotCapacityRebalanceRequest_Serialize(body, prefix+".CapacityRebalance", params["CapacityRebalance"]);
}

function FleetSpotCapacityRebalanceRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FleetSpotCapacityRebalanceRequest) {
    if ("ReplacementStrategy" in params) body.append(prefix+".ReplacementStrategy", (params["ReplacementStrategy"] ?? '').toString());
}

function OnDemandOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.OnDemandOptionsRequest) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if (params["CapacityReservationOptions"] != null) CapacityReservationOptionsRequest_Serialize(body, prefix+".CapacityReservationOptions", params["CapacityReservationOptions"]);
    if ("SingleInstanceType" in params) body.append(prefix+".SingleInstanceType", (params["SingleInstanceType"] ?? '').toString());
    if ("SingleAvailabilityZone" in params) body.append(prefix+".SingleAvailabilityZone", (params["SingleAvailabilityZone"] ?? '').toString());
    if ("MinTargetCapacity" in params) body.append(prefix+".MinTargetCapacity", (params["MinTargetCapacity"] ?? '').toString());
    if ("MaxTotalPrice" in params) body.append(prefix+".MaxTotalPrice", (params["MaxTotalPrice"] ?? '').toString());
}

function CapacityReservationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.CapacityReservationOptionsRequest) {
    if ("UsageStrategy" in params) body.append(prefix+".UsageStrategy", (params["UsageStrategy"] ?? '').toString());
}

function FleetLaunchTemplateConfigRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FleetLaunchTemplateConfigRequest) {
    if (params["LaunchTemplateSpecification"] != null) FleetLaunchTemplateSpecificationRequest_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".item", params["Overrides"], {"appender":FleetLaunchTemplateOverridesRequest_Serialize,"entryPrefix":"."})
}

function FleetLaunchTemplateSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FleetLaunchTemplateSpecificationRequest) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}

function FleetLaunchTemplateOverridesRequest_Serialize(body: URLSearchParams, prefix: string, params: s.FleetLaunchTemplateOverridesRequest) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
    if (params["Placement"] != null) Placement_Serialize(body, prefix+".Placement", params["Placement"]);
}

function Placement_Serialize(body: URLSearchParams, prefix: string, params: s.Placement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Affinity" in params) body.append(prefix+".Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+".PartitionNumber", (params["PartitionNumber"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+".HostId", (params["HostId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
    if ("SpreadDomain" in params) body.append(prefix+".SpreadDomain", (params["SpreadDomain"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+".HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
}
function Placement_Parse(node: xmlP.XmlNode): s.Placement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Affinity: node.first("affinity", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    PartitionNumber: node.first("partitionNumber", false, x => parseInt(x.content ?? '0')),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as s.Tenancy),
    SpreadDomain: node.first("spreadDomain", false, x => x.content ?? ''),
    HostResourceGroupArn: node.first("hostResourceGroupArn", false, x => x.content ?? ''),
  };
}

function TargetCapacitySpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.TargetCapacitySpecificationRequest) {
    body.append(prefix+".TotalTargetCapacity", (params["TotalTargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+".OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    if ("SpotTargetCapacity" in params) body.append(prefix+".SpotTargetCapacity", (params["SpotTargetCapacity"] ?? '').toString());
    if ("DefaultTargetCapacityType" in params) body.append(prefix+".DefaultTargetCapacityType", (params["DefaultTargetCapacityType"] ?? '').toString());
}

function StorageLocation_Serialize(body: URLSearchParams, prefix: string, params: s.StorageLocation) {
    if ("Bucket" in params) body.append(prefix+".Bucket", (params["Bucket"] ?? '').toString());
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
}

function BlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: s.BlockDeviceMapping) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    if (params["Ebs"] != null) EbsBlockDevice_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}
function BlockDeviceMapping_Parse(node: xmlP.XmlNode): s.BlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    VirtualName: node.first("virtualName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, EbsBlockDevice_Parse),
    NoDevice: node.first("noDevice", false, x => x.content ?? ''),
  };
}

function EbsBlockDevice_Serialize(body: URLSearchParams, prefix: string, params: s.EbsBlockDevice) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+".KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("Throughput" in params) body.append(prefix+".Throughput", (params["Throughput"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+".OutpostArn", (params["OutpostArn"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
}
function EbsBlockDevice_Parse(node: xmlP.XmlNode): s.EbsBlockDevice {
  return {
    ...node.strings({
      optional: {"KmsKeyId":true},
    }),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as s.VolumeType),
    Throughput: node.first("throughput", false, x => parseInt(x.content ?? '0')),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
  };
}

function ExportToS3TaskSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.ExportToS3TaskSpecification) {
    if ("ContainerFormat" in params) body.append(prefix+".ContainerFormat", (params["ContainerFormat"] ?? '').toString());
    if ("DiskImageFormat" in params) body.append(prefix+".DiskImageFormat", (params["DiskImageFormat"] ?? '').toString());
    if ("S3Bucket" in params) body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+".S3Prefix", (params["S3Prefix"] ?? '').toString());
}

function RequestLaunchTemplateData_Serialize(body: URLSearchParams, prefix: string, params: s.RequestLaunchTemplateData) {
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) LaunchTemplateIamInstanceProfileSpecificationRequest_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":LaunchTemplateBlockDeviceMappingRequest_Serialize,"entryPrefix":"."})
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":LaunchTemplateInstanceNetworkInterfaceSpecificationRequest_Serialize,"entryPrefix":"."})
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) LaunchTemplatesMonitoringRequest_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["Placement"] != null) LaunchTemplatePlacementRequest_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamDiskId" in params) body.append(prefix+".RamDiskId", (params["RamDiskId"] ?? '').toString());
    if ("DisableApiTermination" in params) body.append(prefix+".DisableApiTermination", (params["DisableApiTermination"] ?? '').toString());
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+".InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".TagSpecification", params["TagSpecifications"], {"appender":LaunchTemplateTagSpecificationRequest_Serialize,"entryPrefix":"."})
    if (params["ElasticGpuSpecifications"]) qsP.appendList(body, prefix+".ElasticGpuSpecification", params["ElasticGpuSpecifications"], {"appender":ElasticGpuSpecification_Serialize,"entryPrefix":"."})
    if (params["ElasticInferenceAccelerators"]) qsP.appendList(body, prefix+".ElasticInferenceAccelerator", params["ElasticInferenceAccelerators"], {"appender":LaunchTemplateElasticInferenceAccelerator_Serialize,"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if (params["InstanceMarketOptions"] != null) LaunchTemplateInstanceMarketOptionsRequest_Serialize(body, prefix+".InstanceMarketOptions", params["InstanceMarketOptions"]);
    if (params["CreditSpecification"] != null) CreditSpecificationRequest_Serialize(body, prefix+".CreditSpecification", params["CreditSpecification"]);
    if (params["CpuOptions"] != null) LaunchTemplateCpuOptionsRequest_Serialize(body, prefix+".CpuOptions", params["CpuOptions"]);
    if (params["CapacityReservationSpecification"] != null) LaunchTemplateCapacityReservationSpecificationRequest_Serialize(body, prefix+".CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+".LicenseSpecification", params["LicenseSpecifications"], {"appender":LaunchTemplateLicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["HibernationOptions"] != null) LaunchTemplateHibernationOptionsRequest_Serialize(body, prefix+".HibernationOptions", params["HibernationOptions"]);
    if (params["MetadataOptions"] != null) LaunchTemplateInstanceMetadataOptionsRequest_Serialize(body, prefix+".MetadataOptions", params["MetadataOptions"]);
    if (params["EnclaveOptions"] != null) LaunchTemplateEnclaveOptionsRequest_Serialize(body, prefix+".EnclaveOptions", params["EnclaveOptions"]);
}

function LaunchTemplateIamInstanceProfileSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateIamInstanceProfileSpecificationRequest) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}

function LaunchTemplateBlockDeviceMappingRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateBlockDeviceMappingRequest) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    if (params["Ebs"] != null) LaunchTemplateEbsBlockDeviceRequest_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}

function LaunchTemplateEbsBlockDeviceRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateEbsBlockDeviceRequest) {
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+".KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
    if ("Throughput" in params) body.append(prefix+".Throughput", (params["Throughput"] ?? '').toString());
}

function LaunchTemplateInstanceNetworkInterfaceSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest) {
    if ("AssociateCarrierIpAddress" in params) body.append(prefix+".AssociateCarrierIpAddress", (params["AssociateCarrierIpAddress"] ?? '').toString());
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("InterfaceType" in params) body.append(prefix+".InterfaceType", (params["InterfaceType"] ?? '').toString());
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".InstanceIpv6Address", params["Ipv6Addresses"], {"appender":InstanceIpv6AddressRequest_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+".item", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("NetworkCardIndex" in params) body.append(prefix+".NetworkCardIndex", (params["NetworkCardIndex"] ?? '').toString());
}

function InstanceIpv6AddressRequest_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceIpv6AddressRequest) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}

function PrivateIpAddressSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.PrivateIpAddressSpecification) {
    if ("Primary" in params) body.append(prefix+".Primary", (params["Primary"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
}
function PrivateIpAddressSpecification_Parse(node: xmlP.XmlNode): s.PrivateIpAddressSpecification {
  return {
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

function LaunchTemplatesMonitoringRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplatesMonitoringRequest) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

function LaunchTemplatePlacementRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplatePlacementRequest) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Affinity" in params) body.append(prefix+".Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+".HostId", (params["HostId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
    if ("SpreadDomain" in params) body.append(prefix+".SpreadDomain", (params["SpreadDomain"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+".HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+".PartitionNumber", (params["PartitionNumber"] ?? '').toString());
}

function LaunchTemplateTagSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateTagSpecificationRequest) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}

function ElasticGpuSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.ElasticGpuSpecification) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
}

function LaunchTemplateElasticInferenceAccelerator_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateElasticInferenceAccelerator) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Count" in params) body.append(prefix+".Count", (params["Count"] ?? '').toString());
}

function LaunchTemplateInstanceMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateInstanceMarketOptionsRequest) {
    if ("MarketType" in params) body.append(prefix+".MarketType", (params["MarketType"] ?? '').toString());
    if (params["SpotOptions"] != null) LaunchTemplateSpotMarketOptionsRequest_Serialize(body, prefix+".SpotOptions", params["SpotOptions"]);
}

function LaunchTemplateSpotMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateSpotMarketOptionsRequest) {
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SpotInstanceType" in params) body.append(prefix+".SpotInstanceType", (params["SpotInstanceType"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+".BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
}

function CreditSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.CreditSpecificationRequest) {
    body.append(prefix+".CpuCredits", (params["CpuCredits"] ?? '').toString());
}

function LaunchTemplateCpuOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateCpuOptionsRequest) {
    if ("CoreCount" in params) body.append(prefix+".CoreCount", (params["CoreCount"] ?? '').toString());
    if ("ThreadsPerCore" in params) body.append(prefix+".ThreadsPerCore", (params["ThreadsPerCore"] ?? '').toString());
}

function LaunchTemplateCapacityReservationSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateCapacityReservationSpecificationRequest) {
    if ("CapacityReservationPreference" in params) body.append(prefix+".CapacityReservationPreference", (params["CapacityReservationPreference"] ?? '').toString());
    if (params["CapacityReservationTarget"] != null) CapacityReservationTarget_Serialize(body, prefix+".CapacityReservationTarget", params["CapacityReservationTarget"]);
}

function CapacityReservationTarget_Serialize(body: URLSearchParams, prefix: string, params: s.CapacityReservationTarget) {
    if ("CapacityReservationId" in params) body.append(prefix+".CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("CapacityReservationResourceGroupArn" in params) body.append(prefix+".CapacityReservationResourceGroupArn", (params["CapacityReservationResourceGroupArn"] ?? '').toString());
}

function LaunchTemplateLicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateLicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

function LaunchTemplateHibernationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateHibernationOptionsRequest) {
    if ("Configured" in params) body.append(prefix+".Configured", (params["Configured"] ?? '').toString());
}

function LaunchTemplateInstanceMetadataOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateInstanceMetadataOptionsRequest) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}

function LaunchTemplateEnclaveOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateEnclaveOptionsRequest) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

function AddPrefixListEntry_Serialize(body: URLSearchParams, prefix: string, params: s.AddPrefixListEntry) {
    body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}

function IcmpTypeCode_Serialize(body: URLSearchParams, prefix: string, params: s.IcmpTypeCode) {
    if ("Code" in params) body.append(prefix+".Code", (params["Code"] ?? '').toString());
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
}
function IcmpTypeCode_Parse(node: xmlP.XmlNode): s.IcmpTypeCode {
  return {
    Code: node.first("code", false, x => parseInt(x.content ?? '0')),
    Type: node.first("type", false, x => parseInt(x.content ?? '0')),
  };
}

function PortRange_Serialize(body: URLSearchParams, prefix: string, params: s.PortRange) {
    if ("From" in params) body.append(prefix+".From", (params["From"] ?? '').toString());
    if ("To" in params) body.append(prefix+".To", (params["To"] ?? '').toString());
}
function PortRange_Parse(node: xmlP.XmlNode): s.PortRange {
  return {
    From: node.first("from", false, x => parseInt(x.content ?? '0')),
    To: node.first("to", false, x => parseInt(x.content ?? '0')),
  };
}

function InstanceIpv6Address_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceIpv6Address) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}
function InstanceIpv6Address_Parse(node: xmlP.XmlNode): s.InstanceIpv6Address {
  return {
    Ipv6Address: node.first("ipv6Address", false, x => x.content ?? ''),
  };
}

function PriceScheduleSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.PriceScheduleSpecification) {
    if ("CurrencyCode" in params) body.append(prefix+".CurrencyCode", (params["CurrencyCode"] ?? '').toString());
    if ("Price" in params) body.append(prefix+".Price", (params["Price"] ?? '').toString());
    if ("Term" in params) body.append(prefix+".Term", (params["Term"] ?? '').toString());
}

function InstanceSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceSpecification) {
    if ("InstanceId" in params) body.append(prefix+".InstanceId", (params["InstanceId"] ?? '').toString());
    if ("ExcludeBootVolume" in params) body.append(prefix+".ExcludeBootVolume", (params["ExcludeBootVolume"] ?? '').toString());
}

function TrafficMirrorPortRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: s.TrafficMirrorPortRangeRequest) {
    if ("FromPort" in params) body.append(prefix+".FromPort", (params["FromPort"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+".ToPort", (params["ToPort"] ?? '').toString());
}

function TransitGatewayRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TransitGatewayRequestOptions) {
    if ("AmazonSideAsn" in params) body.append(prefix+".AmazonSideAsn", (params["AmazonSideAsn"] ?? '').toString());
    if ("AutoAcceptSharedAttachments" in params) body.append(prefix+".AutoAcceptSharedAttachments", (params["AutoAcceptSharedAttachments"] ?? '').toString());
    if ("DefaultRouteTableAssociation" in params) body.append(prefix+".DefaultRouteTableAssociation", (params["DefaultRouteTableAssociation"] ?? '').toString());
    if ("DefaultRouteTablePropagation" in params) body.append(prefix+".DefaultRouteTablePropagation", (params["DefaultRouteTablePropagation"] ?? '').toString());
    if ("VpnEcmpSupport" in params) body.append(prefix+".VpnEcmpSupport", (params["VpnEcmpSupport"] ?? '').toString());
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("MulticastSupport" in params) body.append(prefix+".MulticastSupport", (params["MulticastSupport"] ?? '').toString());
    if (params["TransitGatewayCidrBlocks"]) qsP.appendList(body, prefix+".item", params["TransitGatewayCidrBlocks"], {"entryPrefix":"."})
}

function CreateTransitGatewayConnectRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: s.CreateTransitGatewayConnectRequestOptions) {
    body.append(prefix+".Protocol", (params["Protocol"] ?? '').toString());
}

function TransitGatewayConnectRequestBgpOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TransitGatewayConnectRequestBgpOptions) {
    if ("PeerAsn" in params) body.append(prefix+".PeerAsn", (params["PeerAsn"] ?? '').toString());
}

function CreateTransitGatewayMulticastDomainRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: s.CreateTransitGatewayMulticastDomainRequestOptions) {
    if ("Igmpv2Support" in params) body.append(prefix+".Igmpv2Support", (params["Igmpv2Support"] ?? '').toString());
    if ("StaticSourcesSupport" in params) body.append(prefix+".StaticSourcesSupport", (params["StaticSourcesSupport"] ?? '').toString());
    if ("AutoAcceptSharedAssociations" in params) body.append(prefix+".AutoAcceptSharedAssociations", (params["AutoAcceptSharedAssociations"] ?? '').toString());
}

function CreateTransitGatewayVpcAttachmentRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: s.CreateTransitGatewayVpcAttachmentRequestOptions) {
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("Ipv6Support" in params) body.append(prefix+".Ipv6Support", (params["Ipv6Support"] ?? '').toString());
    if ("ApplianceModeSupport" in params) body.append(prefix+".ApplianceModeSupport", (params["ApplianceModeSupport"] ?? '').toString());
}

function VpnConnectionOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.VpnConnectionOptionsSpecification) {
    if ("EnableAcceleration" in params) body.append(prefix+".EnableAcceleration", (params["EnableAcceleration"] ?? '').toString());
    if ("StaticRoutesOnly" in params) body.append(prefix+".StaticRoutesOnly", (params["StaticRoutesOnly"] ?? '').toString());
    if ("TunnelInsideIpVersion" in params) body.append(prefix+".TunnelInsideIpVersion", (params["TunnelInsideIpVersion"] ?? '').toString());
    if (params["TunnelOptions"]) qsP.appendList(body, prefix+".TunnelOptions", params["TunnelOptions"], {"appender":VpnTunnelOptionsSpecification_Serialize,"entryPrefix":"."})
    if ("LocalIpv4NetworkCidr" in params) body.append(prefix+".LocalIpv4NetworkCidr", (params["LocalIpv4NetworkCidr"] ?? '').toString());
    if ("RemoteIpv4NetworkCidr" in params) body.append(prefix+".RemoteIpv4NetworkCidr", (params["RemoteIpv4NetworkCidr"] ?? '').toString());
    if ("LocalIpv6NetworkCidr" in params) body.append(prefix+".LocalIpv6NetworkCidr", (params["LocalIpv6NetworkCidr"] ?? '').toString());
    if ("RemoteIpv6NetworkCidr" in params) body.append(prefix+".RemoteIpv6NetworkCidr", (params["RemoteIpv6NetworkCidr"] ?? '').toString());
}

function VpnTunnelOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.VpnTunnelOptionsSpecification) {
    if ("TunnelInsideCidr" in params) body.append(prefix+".TunnelInsideCidr", (params["TunnelInsideCidr"] ?? '').toString());
    if ("TunnelInsideIpv6Cidr" in params) body.append(prefix+".TunnelInsideIpv6Cidr", (params["TunnelInsideIpv6Cidr"] ?? '').toString());
    if ("PreSharedKey" in params) body.append(prefix+".PreSharedKey", (params["PreSharedKey"] ?? '').toString());
    if ("Phase1LifetimeSeconds" in params) body.append(prefix+".Phase1LifetimeSeconds", (params["Phase1LifetimeSeconds"] ?? '').toString());
    if ("Phase2LifetimeSeconds" in params) body.append(prefix+".Phase2LifetimeSeconds", (params["Phase2LifetimeSeconds"] ?? '').toString());
    if ("RekeyMarginTimeSeconds" in params) body.append(prefix+".RekeyMarginTimeSeconds", (params["RekeyMarginTimeSeconds"] ?? '').toString());
    if ("RekeyFuzzPercentage" in params) body.append(prefix+".RekeyFuzzPercentage", (params["RekeyFuzzPercentage"] ?? '').toString());
    if ("ReplayWindowSize" in params) body.append(prefix+".ReplayWindowSize", (params["ReplayWindowSize"] ?? '').toString());
    if ("DPDTimeoutSeconds" in params) body.append(prefix+".DPDTimeoutSeconds", (params["DPDTimeoutSeconds"] ?? '').toString());
    if ("DPDTimeoutAction" in params) body.append(prefix+".DPDTimeoutAction", (params["DPDTimeoutAction"] ?? '').toString());
    if (params["Phase1EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase1EncryptionAlgorithm", params["Phase1EncryptionAlgorithms"], {"appender":Phase1EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase2EncryptionAlgorithm", params["Phase2EncryptionAlgorithms"], {"appender":Phase2EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase1IntegrityAlgorithm", params["Phase1IntegrityAlgorithms"], {"appender":Phase1IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase2IntegrityAlgorithm", params["Phase2IntegrityAlgorithms"], {"appender":Phase2IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase1DHGroupNumber", params["Phase1DHGroupNumbers"], {"appender":Phase1DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase2DHGroupNumber", params["Phase2DHGroupNumbers"], {"appender":Phase2DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["IKEVersions"]) qsP.appendList(body, prefix+".IKEVersion", params["IKEVersions"], {"appender":IKEVersionsRequestListValue_Serialize,"entryPrefix":"."})
    if ("StartupAction" in params) body.append(prefix+".StartupAction", (params["StartupAction"] ?? '').toString());
}

function Phase1EncryptionAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase1EncryptionAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function Phase2EncryptionAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase2EncryptionAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function Phase1IntegrityAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase1IntegrityAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function Phase2IntegrityAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase2IntegrityAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function Phase1DHGroupNumbersRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase1DHGroupNumbersRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function Phase2DHGroupNumbersRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.Phase2DHGroupNumbersRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function IKEVersionsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: s.IKEVersionsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function DeregisterInstanceTagAttributeRequest_Serialize(body: URLSearchParams, prefix: string, params: s.DeregisterInstanceTagAttributeRequest) {
    if ("IncludeAllTagsOfInstance" in params) body.append(prefix+".IncludeAllTagsOfInstance", (params["IncludeAllTagsOfInstance"] ?? '').toString());
    if (params["InstanceTagKeys"]) qsP.appendList(body, prefix+".InstanceTagKey", params["InstanceTagKeys"], {"entryPrefix":"."})
}

function Filter_Serialize(body: URLSearchParams, prefix: string, params: s.Filter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":"."})
}

function SlotDateTimeRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: s.SlotDateTimeRangeRequest) {
    body.append(prefix+".EarliestTime", qsP.encodeDate_iso8601(params["EarliestTime"]));
    body.append(prefix+".LatestTime", qsP.encodeDate_iso8601(params["LatestTime"]));
}

function ScheduledInstanceRecurrenceRequest_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstanceRecurrenceRequest) {
    if ("Frequency" in params) body.append(prefix+".Frequency", (params["Frequency"] ?? '').toString());
    if ("Interval" in params) body.append(prefix+".Interval", (params["Interval"] ?? '').toString());
    if (params["OccurrenceDays"]) qsP.appendList(body, prefix+".OccurrenceDay", params["OccurrenceDays"], {"entryPrefix":"."})
    if ("OccurrenceRelativeToEnd" in params) body.append(prefix+".OccurrenceRelativeToEnd", (params["OccurrenceRelativeToEnd"] ?? '').toString());
    if ("OccurrenceUnit" in params) body.append(prefix+".OccurrenceUnit", (params["OccurrenceUnit"] ?? '').toString());
}

function SlotStartTimeRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: s.SlotStartTimeRangeRequest) {
    if ("EarliestTime" in params) body.append(prefix+".EarliestTime", qsP.encodeDate_iso8601(params["EarliestTime"]));
    if ("LatestTime" in params) body.append(prefix+".LatestTime", qsP.encodeDate_iso8601(params["LatestTime"]));
}

function ExportTaskS3LocationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.ExportTaskS3LocationRequest) {
    body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+".S3Prefix", (params["S3Prefix"] ?? '').toString());
}

function ClientData_Serialize(body: URLSearchParams, prefix: string, params: s.ClientData) {
    if ("Comment" in params) body.append(prefix+".Comment", (params["Comment"] ?? '').toString());
    if ("UploadEnd" in params) body.append(prefix+".UploadEnd", qsP.encodeDate_iso8601(params["UploadEnd"]));
    if ("UploadSize" in params) body.append(prefix+".UploadSize", (params["UploadSize"] ?? '').toString());
    if ("UploadStart" in params) body.append(prefix+".UploadStart", qsP.encodeDate_iso8601(params["UploadStart"]));
}

function ImageDiskContainer_Serialize(body: URLSearchParams, prefix: string, params: s.ImageDiskContainer) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("Format" in params) body.append(prefix+".Format", (params["Format"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("Url" in params) body.append(prefix+".Url", (params["Url"] ?? '').toString());
    if (params["UserBucket"] != null) UserBucket_Serialize(body, prefix+".UserBucket", params["UserBucket"]);
}

function UserBucket_Serialize(body: URLSearchParams, prefix: string, params: s.UserBucket) {
    if ("S3Bucket" in params) body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Key" in params) body.append(prefix+".S3Key", (params["S3Key"] ?? '').toString());
}

function ImportImageLicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.ImportImageLicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

function DiskImage_Serialize(body: URLSearchParams, prefix: string, params: s.DiskImage) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if (params["Image"] != null) DiskImageDetail_Serialize(body, prefix+".Image", params["Image"]);
    if (params["Volume"] != null) VolumeDetail_Serialize(body, prefix+".Volume", params["Volume"]);
}

function DiskImageDetail_Serialize(body: URLSearchParams, prefix: string, params: s.DiskImageDetail) {
    body.append(prefix+".Bytes", (params["Bytes"] ?? '').toString());
    body.append(prefix+".Format", (params["Format"] ?? '').toString());
    body.append(prefix+".ImportManifestUrl", (params["ImportManifestUrl"] ?? '').toString());
}

function VolumeDetail_Serialize(body: URLSearchParams, prefix: string, params: s.VolumeDetail) {
    body.append(prefix+".Size", (params["Size"] ?? '').toString());
}

function ImportInstanceLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.ImportInstanceLaunchSpecification) {
    if ("AdditionalInfo" in params) body.append(prefix+".AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if ("Architecture" in params) body.append(prefix+".Architecture", (params["Architecture"] ?? '').toString());
    if (params["GroupIds"]) qsP.appendList(body, prefix+".GroupId", params["GroupIds"], {"entryPrefix":"."})
    if (params["GroupNames"]) qsP.appendList(body, prefix+".GroupName", params["GroupNames"], {"entryPrefix":"."})
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+".InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Monitoring" in params) body.append(prefix+".Monitoring", (params["Monitoring"] ?? '').toString());
    if (params["Placement"] != null) Placement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["UserData"] != null) UserData_Serialize(body, prefix+".UserData", params["UserData"]);
}

function UserData_Serialize(body: URLSearchParams, prefix: string, params: s.UserData) {
    if ("Data" in params) body.append(prefix+".Data", (params["Data"] ?? '').toString());
}

function SnapshotDiskContainer_Serialize(body: URLSearchParams, prefix: string, params: s.SnapshotDiskContainer) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Format" in params) body.append(prefix+".Format", (params["Format"] ?? '').toString());
    if ("Url" in params) body.append(prefix+".Url", (params["Url"] ?? '').toString());
    if (params["UserBucket"] != null) UserBucket_Serialize(body, prefix+".UserBucket", params["UserBucket"]);
}

function DnsServersOptionsModifyStructure_Serialize(body: URLSearchParams, prefix: string, params: s.DnsServersOptionsModifyStructure) {
    if (params["CustomDnsServers"]) qsP.appendList(body, prefix+".item", params["CustomDnsServers"], {"entryPrefix":"."})
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

function LoadPermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: s.LoadPermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":LoadPermissionRequest_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":LoadPermissionRequest_Serialize,"entryPrefix":"."})
}

function LoadPermissionRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LoadPermissionRequest) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}

function AttributeValue_Serialize(body: URLSearchParams, prefix: string, params: s.AttributeValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function AttributeValue_Parse(node: xmlP.XmlNode): s.AttributeValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function LaunchPermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchPermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":LaunchPermission_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":LaunchPermission_Serialize,"entryPrefix":"."})
}

function LaunchPermission_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchPermission) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}
function LaunchPermission_Parse(node: xmlP.XmlNode): s.LaunchPermission {
  return {
    Group: node.first("group", false, x => (x.content ?? '') as s.PermissionGroup),
    UserId: node.first("userId", false, x => x.content ?? ''),
  };
}

function AttributeBooleanValue_Serialize(body: URLSearchParams, prefix: string, params: s.AttributeBooleanValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function AttributeBooleanValue_Parse(node: xmlP.XmlNode): s.AttributeBooleanValue {
  return {
    Value: node.first("value", false, x => x.content === 'true'),
  };
}

function InstanceBlockDeviceMappingSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceBlockDeviceMappingSpecification) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) EbsInstanceBlockDeviceSpecification_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
}

function EbsInstanceBlockDeviceSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.EbsInstanceBlockDeviceSpecification) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("VolumeId" in params) body.append(prefix+".VolumeId", (params["VolumeId"] ?? '').toString());
}

function BlobAttributeValue_Serialize(body: URLSearchParams, prefix: string, params: s.BlobAttributeValue) {
    if ("Value" in params) body.append(prefix+".Value", serializeBlob(params["Value"]) ?? '');
}

function CapacityReservationSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.CapacityReservationSpecification) {
    if ("CapacityReservationPreference" in params) body.append(prefix+".CapacityReservationPreference", (params["CapacityReservationPreference"] ?? '').toString());
    if (params["CapacityReservationTarget"] != null) CapacityReservationTarget_Serialize(body, prefix+".CapacityReservationTarget", params["CapacityReservationTarget"]);
}

function InstanceCreditSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceCreditSpecificationRequest) {
    if ("InstanceId" in params) body.append(prefix+".InstanceId", (params["InstanceId"] ?? '').toString());
    if ("CpuCredits" in params) body.append(prefix+".CpuCredits", (params["CpuCredits"] ?? '').toString());
}

function RemovePrefixListEntry_Serialize(body: URLSearchParams, prefix: string, params: s.RemovePrefixListEntry) {
    body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
}

function NetworkInterfaceAttachmentChanges_Serialize(body: URLSearchParams, prefix: string, params: s.NetworkInterfaceAttachmentChanges) {
    if ("AttachmentId" in params) body.append(prefix+".AttachmentId", (params["AttachmentId"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
}

function ReservedInstancesConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.ReservedInstancesConfiguration) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Platform" in params) body.append(prefix+".Platform", (params["Platform"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
}
function ReservedInstancesConfiguration_Parse(node: xmlP.XmlNode): s.ReservedInstancesConfiguration {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    Platform: node.first("platform", false, x => x.content ?? ''),
    Scope: node.first("scope", false, x => (x.content ?? '') as s.scope),
  };
}

function CreateVolumePermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: s.CreateVolumePermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":CreateVolumePermission_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":CreateVolumePermission_Serialize,"entryPrefix":"."})
}

function CreateVolumePermission_Serialize(body: URLSearchParams, prefix: string, params: s.CreateVolumePermission) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}
function CreateVolumePermission_Parse(node: xmlP.XmlNode): s.CreateVolumePermission {
  return {
    Group: node.first("group", false, x => (x.content ?? '') as s.PermissionGroup),
    UserId: node.first("userId", false, x => x.content ?? ''),
  };
}

function LaunchTemplateConfig_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateConfig) {
    if (params["LaunchTemplateSpecification"] != null) FleetLaunchTemplateSpecification_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".overrides", params["Overrides"], {"appender":LaunchTemplateOverrides_Serialize,"entryPrefix":"."})
}
function LaunchTemplateConfig_Parse(node: xmlP.XmlNode): s.LaunchTemplateConfig {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.getList("overrides", "item").map(LaunchTemplateOverrides_Parse),
  };
}

function FleetLaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.FleetLaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}
function FleetLaunchTemplateSpecification_Parse(node: xmlP.XmlNode): s.FleetLaunchTemplateSpecification {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    Version: node.first("version", false, x => x.content ?? ''),
  };
}

function LaunchTemplateOverrides_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateOverrides) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
}
function LaunchTemplateOverrides_Parse(node: xmlP.XmlNode): s.LaunchTemplateOverrides {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    Priority: node.first("priority", false, x => parseFloat(x.content ?? '0')),
  };
}

function ModifyTransitGatewayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.ModifyTransitGatewayOptions) {
    if (params["AddTransitGatewayCidrBlocks"]) qsP.appendList(body, prefix+".item", params["AddTransitGatewayCidrBlocks"], {"entryPrefix":"."})
    if (params["RemoveTransitGatewayCidrBlocks"]) qsP.appendList(body, prefix+".item", params["RemoveTransitGatewayCidrBlocks"], {"entryPrefix":"."})
    if ("VpnEcmpSupport" in params) body.append(prefix+".VpnEcmpSupport", (params["VpnEcmpSupport"] ?? '').toString());
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("AutoAcceptSharedAttachments" in params) body.append(prefix+".AutoAcceptSharedAttachments", (params["AutoAcceptSharedAttachments"] ?? '').toString());
    if ("DefaultRouteTableAssociation" in params) body.append(prefix+".DefaultRouteTableAssociation", (params["DefaultRouteTableAssociation"] ?? '').toString());
    if ("AssociationDefaultRouteTableId" in params) body.append(prefix+".AssociationDefaultRouteTableId", (params["AssociationDefaultRouteTableId"] ?? '').toString());
    if ("DefaultRouteTablePropagation" in params) body.append(prefix+".DefaultRouteTablePropagation", (params["DefaultRouteTablePropagation"] ?? '').toString());
    if ("PropagationDefaultRouteTableId" in params) body.append(prefix+".PropagationDefaultRouteTableId", (params["PropagationDefaultRouteTableId"] ?? '').toString());
}

function ModifyTransitGatewayVpcAttachmentRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: s.ModifyTransitGatewayVpcAttachmentRequestOptions) {
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("Ipv6Support" in params) body.append(prefix+".Ipv6Support", (params["Ipv6Support"] ?? '').toString());
    if ("ApplianceModeSupport" in params) body.append(prefix+".ApplianceModeSupport", (params["ApplianceModeSupport"] ?? '').toString());
}

function PeeringConnectionOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.PeeringConnectionOptionsRequest) {
    if ("AllowDnsResolutionFromRemoteVpc" in params) body.append(prefix+".AllowDnsResolutionFromRemoteVpc", (params["AllowDnsResolutionFromRemoteVpc"] ?? '').toString());
    if ("AllowEgressFromLocalClassicLinkToRemoteVpc" in params) body.append(prefix+".AllowEgressFromLocalClassicLinkToRemoteVpc", (params["AllowEgressFromLocalClassicLinkToRemoteVpc"] ?? '').toString());
    if ("AllowEgressFromLocalVpcToRemoteClassicLink" in params) body.append(prefix+".AllowEgressFromLocalVpcToRemoteClassicLink", (params["AllowEgressFromLocalVpcToRemoteClassicLink"] ?? '').toString());
}

function ModifyVpnTunnelOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.ModifyVpnTunnelOptionsSpecification) {
    if ("TunnelInsideCidr" in params) body.append(prefix+".TunnelInsideCidr", (params["TunnelInsideCidr"] ?? '').toString());
    if ("TunnelInsideIpv6Cidr" in params) body.append(prefix+".TunnelInsideIpv6Cidr", (params["TunnelInsideIpv6Cidr"] ?? '').toString());
    if ("PreSharedKey" in params) body.append(prefix+".PreSharedKey", (params["PreSharedKey"] ?? '').toString());
    if ("Phase1LifetimeSeconds" in params) body.append(prefix+".Phase1LifetimeSeconds", (params["Phase1LifetimeSeconds"] ?? '').toString());
    if ("Phase2LifetimeSeconds" in params) body.append(prefix+".Phase2LifetimeSeconds", (params["Phase2LifetimeSeconds"] ?? '').toString());
    if ("RekeyMarginTimeSeconds" in params) body.append(prefix+".RekeyMarginTimeSeconds", (params["RekeyMarginTimeSeconds"] ?? '').toString());
    if ("RekeyFuzzPercentage" in params) body.append(prefix+".RekeyFuzzPercentage", (params["RekeyFuzzPercentage"] ?? '').toString());
    if ("ReplayWindowSize" in params) body.append(prefix+".ReplayWindowSize", (params["ReplayWindowSize"] ?? '').toString());
    if ("DPDTimeoutSeconds" in params) body.append(prefix+".DPDTimeoutSeconds", (params["DPDTimeoutSeconds"] ?? '').toString());
    if ("DPDTimeoutAction" in params) body.append(prefix+".DPDTimeoutAction", (params["DPDTimeoutAction"] ?? '').toString());
    if (params["Phase1EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase1EncryptionAlgorithm", params["Phase1EncryptionAlgorithms"], {"appender":Phase1EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase2EncryptionAlgorithm", params["Phase2EncryptionAlgorithms"], {"appender":Phase2EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase1IntegrityAlgorithm", params["Phase1IntegrityAlgorithms"], {"appender":Phase1IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase2IntegrityAlgorithm", params["Phase2IntegrityAlgorithms"], {"appender":Phase2IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase1DHGroupNumber", params["Phase1DHGroupNumbers"], {"appender":Phase1DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase2DHGroupNumber", params["Phase2DHGroupNumbers"], {"appender":Phase2DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["IKEVersions"]) qsP.appendList(body, prefix+".IKEVersion", params["IKEVersions"], {"appender":IKEVersionsRequestListValue_Serialize,"entryPrefix":"."})
    if ("StartupAction" in params) body.append(prefix+".StartupAction", (params["StartupAction"] ?? '').toString());
}

function CidrAuthorizationContext_Serialize(body: URLSearchParams, prefix: string, params: s.CidrAuthorizationContext) {
    body.append(prefix+".Message", (params["Message"] ?? '').toString());
    body.append(prefix+".Signature", (params["Signature"] ?? '').toString());
}

function ReservedInstanceLimitPrice_Serialize(body: URLSearchParams, prefix: string, params: s.ReservedInstanceLimitPrice) {
    if ("Amount" in params) body.append(prefix+".Amount", (params["Amount"] ?? '').toString());
    if ("CurrencyCode" in params) body.append(prefix+".CurrencyCode", (params["CurrencyCode"] ?? '').toString());
}

function PurchaseRequest_Serialize(body: URLSearchParams, prefix: string, params: s.PurchaseRequest) {
    body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+".PurchaseToken", (params["PurchaseToken"] ?? '').toString());
}

function RegisterInstanceTagAttributeRequest_Serialize(body: URLSearchParams, prefix: string, params: s.RegisterInstanceTagAttributeRequest) {
    if ("IncludeAllTagsOfInstance" in params) body.append(prefix+".IncludeAllTagsOfInstance", (params["IncludeAllTagsOfInstance"] ?? '').toString());
    if (params["InstanceTagKeys"]) qsP.appendList(body, prefix+".InstanceTagKey", params["InstanceTagKeys"], {"entryPrefix":"."})
}

function SpotFleetRequestConfigData_Serialize(body: URLSearchParams, prefix: string, params: s.SpotFleetRequestConfigData) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if ("OnDemandAllocationStrategy" in params) body.append(prefix+".OnDemandAllocationStrategy", (params["OnDemandAllocationStrategy"] ?? '').toString());
    if (params["SpotMaintenanceStrategies"] != null) SpotMaintenanceStrategies_Serialize(body, prefix+".SpotMaintenanceStrategies", params["SpotMaintenanceStrategies"]);
    if ("ClientToken" in params) body.append(prefix+".ClientToken", (params["ClientToken"] ?? '').toString());
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+".ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if ("FulfilledCapacity" in params) body.append(prefix+".FulfilledCapacity", (params["FulfilledCapacity"] ?? '').toString());
    if ("OnDemandFulfilledCapacity" in params) body.append(prefix+".OnDemandFulfilledCapacity", (params["OnDemandFulfilledCapacity"] ?? '').toString());
    body.append(prefix+".IamFleetRole", (params["IamFleetRole"] ?? '').toString());
    if (params["LaunchSpecifications"]) qsP.appendList(body, prefix+".launchSpecifications", params["LaunchSpecifications"], {"appender":SpotFleetLaunchSpecification_Serialize,"entryPrefix":"."})
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+".launchTemplateConfigs", params["LaunchTemplateConfigs"], {"appender":LaunchTemplateConfig_Serialize,"entryPrefix":"."})
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    body.append(prefix+".TargetCapacity", (params["TargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+".OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    if ("OnDemandMaxTotalPrice" in params) body.append(prefix+".OnDemandMaxTotalPrice", (params["OnDemandMaxTotalPrice"] ?? '').toString());
    if ("SpotMaxTotalPrice" in params) body.append(prefix+".SpotMaxTotalPrice", (params["SpotMaxTotalPrice"] ?? '').toString());
    if ("TerminateInstancesWithExpiration" in params) body.append(prefix+".TerminateInstancesWithExpiration", (params["TerminateInstancesWithExpiration"] ?? '').toString());
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+".ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("ReplaceUnhealthyInstances" in params) body.append(prefix+".ReplaceUnhealthyInstances", (params["ReplaceUnhealthyInstances"] ?? '').toString());
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    if (params["LoadBalancersConfig"] != null) LoadBalancersConfig_Serialize(body, prefix+".LoadBalancersConfig", params["LoadBalancersConfig"]);
    if ("InstancePoolsToUseCount" in params) body.append(prefix+".InstancePoolsToUseCount", (params["InstancePoolsToUseCount"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
}
function SpotFleetRequestConfigData_Parse(node: xmlP.XmlNode): s.SpotFleetRequestConfigData {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as s.AllocationStrategy),
    OnDemandAllocationStrategy: node.first("onDemandAllocationStrategy", false, x => (x.content ?? '') as s.OnDemandAllocationStrategy),
    SpotMaintenanceStrategies: node.first("spotMaintenanceStrategies", false, SpotMaintenanceStrategies_Parse),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    ExcessCapacityTerminationPolicy: node.first("excessCapacityTerminationPolicy", false, x => (x.content ?? '') as s.ExcessCapacityTerminationPolicy),
    FulfilledCapacity: node.first("fulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    OnDemandFulfilledCapacity: node.first("onDemandFulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    IamFleetRole: node.first("iamFleetRole", true, x => x.content ?? ''),
    LaunchSpecifications: node.getList("launchSpecifications", "item").map(SpotFleetLaunchSpecification_Parse),
    LaunchTemplateConfigs: node.getList("launchTemplateConfigs", "item").map(LaunchTemplateConfig_Parse),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    TargetCapacity: node.first("targetCapacity", true, x => parseInt(x.content ?? '0')),
    OnDemandTargetCapacity: node.first("onDemandTargetCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandMaxTotalPrice: node.first("onDemandMaxTotalPrice", false, x => x.content ?? ''),
    SpotMaxTotalPrice: node.first("spotMaxTotalPrice", false, x => x.content ?? ''),
    TerminateInstancesWithExpiration: node.first("terminateInstancesWithExpiration", false, x => x.content === 'true'),
    Type: node.first("type", false, x => (x.content ?? '') as s.FleetType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    ReplaceUnhealthyInstances: node.first("replaceUnhealthyInstances", false, x => x.content === 'true'),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as s.InstanceInterruptionBehavior),
    LoadBalancersConfig: node.first("loadBalancersConfig", false, LoadBalancersConfig_Parse),
    InstancePoolsToUseCount: node.first("instancePoolsToUseCount", false, x => parseInt(x.content ?? '0')),
    TagSpecifications: node.getList("TagSpecification", "item").map(TagSpecification_Parse),
  };
}

function SpotMaintenanceStrategies_Serialize(body: URLSearchParams, prefix: string, params: s.SpotMaintenanceStrategies) {
    if (params["CapacityRebalance"] != null) SpotCapacityRebalance_Serialize(body, prefix+".CapacityRebalance", params["CapacityRebalance"]);
}
function SpotMaintenanceStrategies_Parse(node: xmlP.XmlNode): s.SpotMaintenanceStrategies {
  return {
    CapacityRebalance: node.first("capacityRebalance", false, SpotCapacityRebalance_Parse),
  };
}

function SpotCapacityRebalance_Serialize(body: URLSearchParams, prefix: string, params: s.SpotCapacityRebalance) {
    if ("ReplacementStrategy" in params) body.append(prefix+".ReplacementStrategy", (params["ReplacementStrategy"] ?? '').toString());
}
function SpotCapacityRebalance_Parse(node: xmlP.XmlNode): s.SpotCapacityRebalance {
  return {
    ReplacementStrategy: node.first("replacementStrategy", false, x => (x.content ?? '') as s.ReplacementStrategy),
  };
}

function SpotFleetLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.SpotFleetLaunchSpecification) {
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".groupSet", params["SecurityGroups"], {"appender":GroupIdentifier_Serialize,"entryPrefix":"."})
    if ("AddressingType" in params) body.append(prefix+".AddressingType", (params["AddressingType"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) SpotFleetMonitoring_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".networkInterfaceSet", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) SpotPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".tagSpecificationSet", params["TagSpecifications"], {"appender":SpotFleetTagSpecification_Serialize,"entryPrefix":"."})
}
function SpotFleetLaunchSpecification_Parse(node: xmlP.XmlNode): s.SpotFleetLaunchSpecification {
  return {
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    AddressingType: node.first("addressingType", false, x => x.content ?? ''),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfileSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, SpotFleetMonitoring_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterfaceSpecification_Parse),
    Placement: node.first("placement", false, SpotPlacement_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    UserData: node.first("userData", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    TagSpecifications: node.getList("tagSpecificationSet", "item").map(SpotFleetTagSpecification_Parse),
  };
}

function GroupIdentifier_Serialize(body: URLSearchParams, prefix: string, params: s.GroupIdentifier) {
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+".GroupId", (params["GroupId"] ?? '').toString());
}
function GroupIdentifier_Parse(node: xmlP.XmlNode): s.GroupIdentifier {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
  };
}

function SpotFleetMonitoring_Serialize(body: URLSearchParams, prefix: string, params: s.SpotFleetMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function SpotFleetMonitoring_Parse(node: xmlP.XmlNode): s.SpotFleetMonitoring {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

function InstanceNetworkInterfaceSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceNetworkInterfaceSpecification) {
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".Ipv6Addresses", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+".PrivateIpAddresses", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AssociateCarrierIpAddress" in params) body.append(prefix+".AssociateCarrierIpAddress", (params["AssociateCarrierIpAddress"] ?? '').toString());
    if ("InterfaceType" in params) body.append(prefix+".InterfaceType", (params["InterfaceType"] ?? '').toString());
    if ("NetworkCardIndex" in params) body.append(prefix+".NetworkCardIndex", (params["NetworkCardIndex"] ?? '').toString());
}
function InstanceNetworkInterfaceSpecification_Parse(node: xmlP.XmlNode): s.InstanceNetworkInterfaceSpecification {
  return {
    ...node.strings({
      optional: {"InterfaceType":true},
    }),
    AssociatePublicIpAddress: node.first("associatePublicIpAddress", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Groups: node.getList("SecurityGroupId", "SecurityGroupId").map(x => x.content ?? ''),
    Ipv6AddressCount: node.first("ipv6AddressCount", false, x => parseInt(x.content ?? '0')),
    Ipv6Addresses: node.getList("Ipv6Addresses", "item").map(InstanceIpv6Address_Parse),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("PrivateIpAddresses", "item").map(PrivateIpAddressSpecification_Parse),
    SecondaryPrivateIpAddressCount: node.first("secondaryPrivateIpAddressCount", false, x => parseInt(x.content ?? '0')),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AssociateCarrierIpAddress: node.first("AssociateCarrierIpAddress", false, x => x.content === 'true'),
    NetworkCardIndex: node.first("NetworkCardIndex", false, x => parseInt(x.content ?? '0')),
  };
}

function SpotPlacement_Serialize(body: URLSearchParams, prefix: string, params: s.SpotPlacement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
}
function SpotPlacement_Parse(node: xmlP.XmlNode): s.SpotPlacement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as s.Tenancy),
  };
}

function SpotFleetTagSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.SpotFleetTagSpecification) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}
function SpotFleetTagSpecification_Parse(node: xmlP.XmlNode): s.SpotFleetTagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.ResourceType),
    Tags: node.getList("tag", "item").map(Tag_Parse),
  };
}

function LoadBalancersConfig_Serialize(body: URLSearchParams, prefix: string, params: s.LoadBalancersConfig) {
    if (params["ClassicLoadBalancersConfig"] != null) ClassicLoadBalancersConfig_Serialize(body, prefix+".ClassicLoadBalancersConfig", params["ClassicLoadBalancersConfig"]);
    if (params["TargetGroupsConfig"] != null) TargetGroupsConfig_Serialize(body, prefix+".TargetGroupsConfig", params["TargetGroupsConfig"]);
}
function LoadBalancersConfig_Parse(node: xmlP.XmlNode): s.LoadBalancersConfig {
  return {
    ClassicLoadBalancersConfig: node.first("classicLoadBalancersConfig", false, ClassicLoadBalancersConfig_Parse),
    TargetGroupsConfig: node.first("targetGroupsConfig", false, TargetGroupsConfig_Parse),
  };
}

function ClassicLoadBalancersConfig_Serialize(body: URLSearchParams, prefix: string, params: s.ClassicLoadBalancersConfig) {
    if (params["ClassicLoadBalancers"]) qsP.appendList(body, prefix+".classicLoadBalancers", params["ClassicLoadBalancers"], {"appender":ClassicLoadBalancer_Serialize,"entryPrefix":"."})
}
function ClassicLoadBalancersConfig_Parse(node: xmlP.XmlNode): s.ClassicLoadBalancersConfig {
  return {
    ClassicLoadBalancers: node.getList("classicLoadBalancers", "item").map(ClassicLoadBalancer_Parse),
  };
}

function ClassicLoadBalancer_Serialize(body: URLSearchParams, prefix: string, params: s.ClassicLoadBalancer) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function ClassicLoadBalancer_Parse(node: xmlP.XmlNode): s.ClassicLoadBalancer {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

function TargetGroupsConfig_Serialize(body: URLSearchParams, prefix: string, params: s.TargetGroupsConfig) {
    if (params["TargetGroups"]) qsP.appendList(body, prefix+".targetGroups", params["TargetGroups"], {"appender":TargetGroup_Serialize,"entryPrefix":"."})
}
function TargetGroupsConfig_Parse(node: xmlP.XmlNode): s.TargetGroupsConfig {
  return {
    TargetGroups: node.getList("targetGroups", "item").map(TargetGroup_Parse),
  };
}

function TargetGroup_Serialize(body: URLSearchParams, prefix: string, params: s.TargetGroup) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
}
function TargetGroup_Parse(node: xmlP.XmlNode): s.TargetGroup {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
  };
}

function RequestSpotLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.RequestSpotLaunchSpecification) {
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if ("AddressingType" in params) body.append(prefix+".AddressingType", (params["AddressingType"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) RunInstancesMonitoringEnabled_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) SpotPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
}

function RunInstancesMonitoringEnabled_Serialize(body: URLSearchParams, prefix: string, params: s.RunInstancesMonitoringEnabled) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function RunInstancesMonitoringEnabled_Parse(node: xmlP.XmlNode): s.RunInstancesMonitoringEnabled {
  return {
    Enabled: node.first("enabled", true, x => x.content === 'true'),
  };
}

function ElasticInferenceAccelerator_Serialize(body: URLSearchParams, prefix: string, params: s.ElasticInferenceAccelerator) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Count" in params) body.append(prefix+".Count", (params["Count"] ?? '').toString());
}

function LaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}

function InstanceMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceMarketOptionsRequest) {
    if ("MarketType" in params) body.append(prefix+".MarketType", (params["MarketType"] ?? '').toString());
    if (params["SpotOptions"] != null) SpotMarketOptions_Serialize(body, prefix+".SpotOptions", params["SpotOptions"]);
}

function SpotMarketOptions_Serialize(body: URLSearchParams, prefix: string, params: s.SpotMarketOptions) {
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SpotInstanceType" in params) body.append(prefix+".SpotInstanceType", (params["SpotInstanceType"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+".BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
}

function CpuOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.CpuOptionsRequest) {
    if ("CoreCount" in params) body.append(prefix+".CoreCount", (params["CoreCount"] ?? '').toString());
    if ("ThreadsPerCore" in params) body.append(prefix+".ThreadsPerCore", (params["ThreadsPerCore"] ?? '').toString());
}

function HibernationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.HibernationOptionsRequest) {
    if ("Configured" in params) body.append(prefix+".Configured", (params["Configured"] ?? '').toString());
}

function LicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: s.LicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

function InstanceMetadataOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceMetadataOptionsRequest) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}

function EnclaveOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: s.EnclaveOptionsRequest) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

function ScheduledInstancesLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesLaunchSpecification) {
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":ScheduledInstancesBlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) ScheduledInstancesIamInstanceProfile_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) ScheduledInstancesMonitoring_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":ScheduledInstancesNetworkInterface_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) ScheduledInstancesPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
}

function ScheduledInstancesBlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesBlockDeviceMapping) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) ScheduledInstancesEbs_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
}

function ScheduledInstancesEbs_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesEbs) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
}

function ScheduledInstancesIamInstanceProfile_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesIamInstanceProfile) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}

function ScheduledInstancesMonitoring_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

function ScheduledInstancesNetworkInterface_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesNetworkInterface) {
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".Group", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".Ipv6Address", params["Ipv6Addresses"], {"appender":ScheduledInstancesIpv6Address_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddressConfigs"]) qsP.appendList(body, prefix+".PrivateIpAddressConfig", params["PrivateIpAddressConfigs"], {"appender":ScheduledInstancesPrivateIpAddressConfig_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
}

function ScheduledInstancesIpv6Address_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesIpv6Address) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}

function ScheduledInstancesPrivateIpAddressConfig_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesPrivateIpAddressConfig) {
    if ("Primary" in params) body.append(prefix+".Primary", (params["Primary"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
}

function ScheduledInstancesPlacement_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledInstancesPlacement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
}

function TransitGatewayMulticastDomainAssociations_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDomainAssociations {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    ResourceOwnerId: node.first("resourceOwnerId", false, x => x.content ?? ''),
    Subnets: node.getList("subnets", "item").map(SubnetAssociation_Parse),
  };
}

function SubnetAssociation_Parse(node: xmlP.XmlNode): s.SubnetAssociation {
  return {
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayMulitcastDomainAssociationState),
  };
}

function TransitGatewayPeeringAttachment_Parse(node: xmlP.XmlNode): s.TransitGatewayPeeringAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    RequesterTgwInfo: node.first("requesterTgwInfo", false, PeeringTgwInfo_Parse),
    AccepterTgwInfo: node.first("accepterTgwInfo", false, PeeringTgwInfo_Parse),
    Status: node.first("status", false, PeeringAttachmentStatus_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAttachmentState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function PeeringTgwInfo_Parse(node: xmlP.XmlNode): s.PeeringTgwInfo {
  return {
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Region: node.first("region", false, x => x.content ?? ''),
  };
}

function PeeringAttachmentStatus_Parse(node: xmlP.XmlNode): s.PeeringAttachmentStatus {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function TransitGatewayVpcAttachment_Parse(node: xmlP.XmlNode): s.TransitGatewayVpcAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    VpcOwnerId: node.first("vpcOwnerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAttachmentState),
    SubnetIds: node.getList("subnetIds", "item").map(x => x.content ?? ''),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Options: node.first("options", false, TransitGatewayVpcAttachmentOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayVpcAttachmentOptions_Parse(node: xmlP.XmlNode): s.TransitGatewayVpcAttachmentOptions {
  return {
    DnsSupport: node.first("dnsSupport", false, x => (x.content ?? '') as s.DnsSupportValue),
    Ipv6Support: node.first("ipv6Support", false, x => (x.content ?? '') as s.Ipv6SupportValue),
    ApplianceModeSupport: node.first("applianceModeSupport", false, x => (x.content ?? '') as s.ApplianceModeSupportValue),
  };
}

function UnsuccessfulItem_Parse(node: xmlP.XmlNode): s.UnsuccessfulItem {
  return {
    Error: node.first("error", false, UnsuccessfulItemError_Parse),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
  };
}

function UnsuccessfulItemError_Parse(node: xmlP.XmlNode): s.UnsuccessfulItemError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function VpcPeeringConnection_Parse(node: xmlP.XmlNode): s.VpcPeeringConnection {
  return {
    AccepterVpcInfo: node.first("accepterVpcInfo", false, VpcPeeringConnectionVpcInfo_Parse),
    ExpirationTime: node.first("expirationTime", false, x => xmlP.parseTimestamp(x.content)),
    RequesterVpcInfo: node.first("requesterVpcInfo", false, VpcPeeringConnectionVpcInfo_Parse),
    Status: node.first("status", false, VpcPeeringConnectionStateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

function VpcPeeringConnectionVpcInfo_Parse(node: xmlP.XmlNode): s.VpcPeeringConnectionVpcInfo {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockSet: node.getList("ipv6CidrBlockSet", "item").map(Ipv6CidrBlock_Parse),
    CidrBlockSet: node.getList("cidrBlockSet", "item").map(CidrBlock_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PeeringOptions: node.first("peeringOptions", false, VpcPeeringConnectionOptionsDescription_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Region: node.first("region", false, x => x.content ?? ''),
  };
}

function Ipv6CidrBlock_Parse(node: xmlP.XmlNode): s.Ipv6CidrBlock {
  return {
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
  };
}

function CidrBlock_Parse(node: xmlP.XmlNode): s.CidrBlock {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
  };
}

function VpcPeeringConnectionOptionsDescription_Parse(node: xmlP.XmlNode): s.VpcPeeringConnectionOptionsDescription {
  return {
    AllowDnsResolutionFromRemoteVpc: node.first("allowDnsResolutionFromRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalClassicLinkToRemoteVpc: node.first("allowEgressFromLocalClassicLinkToRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalVpcToRemoteClassicLink: node.first("allowEgressFromLocalVpcToRemoteClassicLink", false, x => x.content === 'true'),
  };
}

function VpcPeeringConnectionStateReason_Parse(node: xmlP.XmlNode): s.VpcPeeringConnectionStateReason {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.VpcPeeringConnectionStateReasonCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ByoipCidr_Parse(node: xmlP.XmlNode): s.ByoipCidr {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.ByoipCidrState),
  };
}

function AssignedPrivateIpAddress_Parse(node: xmlP.XmlNode): s.AssignedPrivateIpAddress {
  return {
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

function AssociationStatus_Parse(node: xmlP.XmlNode): s.AssociationStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.AssociationStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function IamInstanceProfileAssociation_Parse(node: xmlP.XmlNode): s.IamInstanceProfileAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfile_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.IamInstanceProfileAssociationState),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function IamInstanceProfile_Parse(node: xmlP.XmlNode): s.IamInstanceProfile {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Id: node.first("id", false, x => x.content ?? ''),
  };
}

function RouteTableAssociationState_Parse(node: xmlP.XmlNode): s.RouteTableAssociationState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.RouteTableAssociationStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

function SubnetIpv6CidrBlockAssociation_Parse(node: xmlP.XmlNode): s.SubnetIpv6CidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockState: node.first("ipv6CidrBlockState", false, SubnetCidrBlockState_Parse),
  };
}

function SubnetCidrBlockState_Parse(node: xmlP.XmlNode): s.SubnetCidrBlockState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.SubnetCidrBlockStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

function TransitGatewayAssociation_Parse(node: xmlP.XmlNode): s.TransitGatewayAssociation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAssociationState),
  };
}

function VpcIpv6CidrBlockAssociation_Parse(node: xmlP.XmlNode): s.VpcIpv6CidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockState: node.first("ipv6CidrBlockState", false, VpcCidrBlockState_Parse),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    Ipv6Pool: node.first("ipv6Pool", false, x => x.content ?? ''),
  };
}

function VpcCidrBlockState_Parse(node: xmlP.XmlNode): s.VpcCidrBlockState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.VpcCidrBlockStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

function VpcCidrBlockAssociation_Parse(node: xmlP.XmlNode): s.VpcCidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    CidrBlockState: node.first("cidrBlockState", false, VpcCidrBlockState_Parse),
  };
}

function VpcAttachment_Parse(node: xmlP.XmlNode): s.VpcAttachment {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.AttachmentStatus),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function ClientVpnAuthorizationRuleStatus_Parse(node: xmlP.XmlNode): s.ClientVpnAuthorizationRuleStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientVpnAuthorizationRuleStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function BundleTask_Parse(node: xmlP.XmlNode): s.BundleTask {
  return {
    BundleId: node.first("bundleId", false, x => x.content ?? ''),
    BundleTaskError: node.first("error", false, BundleTaskError_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as s.BundleTaskState),
    Storage: node.first("storage", false, Storage_Parse),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function BundleTaskError_Parse(node: xmlP.XmlNode): s.BundleTaskError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ReservedInstancesListing_Parse(node: xmlP.XmlNode): s.ReservedInstancesListing {
  return {
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    InstanceCounts: node.getList("instanceCounts", "item").map(InstanceCount_Parse),
    PriceSchedules: node.getList("priceSchedules", "item").map(PriceSchedule_Parse),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    ReservedInstancesListingId: node.first("reservedInstancesListingId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as s.ListingStatus),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    UpdateDate: node.first("updateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function InstanceCount_Parse(node: xmlP.XmlNode): s.InstanceCount {
  return {
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    State: node.first("state", false, x => (x.content ?? '') as s.ListingState),
  };
}

function PriceSchedule_Parse(node: xmlP.XmlNode): s.PriceSchedule {
  return {
    Active: node.first("active", false, x => x.content === 'true'),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    Price: node.first("price", false, x => parseFloat(x.content ?? '0')),
    Term: node.first("term", false, x => parseInt(x.content ?? '0')),
  };
}

function CancelSpotFleetRequestsSuccessItem_Parse(node: xmlP.XmlNode): s.CancelSpotFleetRequestsSuccessItem {
  return {
    CurrentSpotFleetRequestState: node.first("currentSpotFleetRequestState", false, x => (x.content ?? '') as s.BatchState),
    PreviousSpotFleetRequestState: node.first("previousSpotFleetRequestState", false, x => (x.content ?? '') as s.BatchState),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
  };
}

function CancelSpotFleetRequestsErrorItem_Parse(node: xmlP.XmlNode): s.CancelSpotFleetRequestsErrorItem {
  return {
    Error: node.first("error", false, CancelSpotFleetRequestsError_Parse),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
  };
}

function CancelSpotFleetRequestsError_Parse(node: xmlP.XmlNode): s.CancelSpotFleetRequestsError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.CancelBatchErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function CancelledSpotInstanceRequest_Parse(node: xmlP.XmlNode): s.CancelledSpotInstanceRequest {
  return {
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.CancelSpotInstanceRequestState),
  };
}

function CapacityReservation_Parse(node: xmlP.XmlNode): s.CapacityReservation {
  return {
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    CapacityReservationArn: node.first("capacityReservationArn", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    InstancePlatform: node.first("instancePlatform", false, x => (x.content ?? '') as s.CapacityReservationInstancePlatform),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as s.CapacityReservationTenancy),
    TotalInstanceCount: node.first("totalInstanceCount", false, x => parseInt(x.content ?? '0')),
    AvailableInstanceCount: node.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    EphemeralStorage: node.first("ephemeralStorage", false, x => x.content === 'true'),
    State: node.first("state", false, x => (x.content ?? '') as s.CapacityReservationState),
    StartDate: node.first("startDate", false, x => xmlP.parseTimestamp(x.content)),
    EndDate: node.first("endDate", false, x => xmlP.parseTimestamp(x.content)),
    EndDateType: node.first("endDateType", false, x => (x.content ?? '') as s.EndDateType),
    InstanceMatchCriteria: node.first("instanceMatchCriteria", false, x => (x.content ?? '') as s.InstanceMatchCriteria),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function CarrierGateway_Parse(node: xmlP.XmlNode): s.CarrierGateway {
  return {
    CarrierGatewayId: node.first("carrierGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.CarrierGatewayState),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ClientVpnEndpointStatus_Parse(node: xmlP.XmlNode): s.ClientVpnEndpointStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientVpnEndpointStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ClientVpnRouteStatus_Parse(node: xmlP.XmlNode): s.ClientVpnRouteStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientVpnRouteStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function CustomerGateway_Parse(node: xmlP.XmlNode): s.CustomerGateway {
  return {
    BgpAsn: node.first("bgpAsn", false, x => x.content ?? ''),
    CustomerGatewayId: node.first("customerGatewayId", false, x => x.content ?? ''),
    IpAddress: node.first("ipAddress", false, x => x.content ?? ''),
    CertificateArn: node.first("certificateArn", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Type: node.first("type", false, x => x.content ?? ''),
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function Subnet_Parse(node: xmlP.XmlNode): s.Subnet {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    AvailableIpAddressCount: node.first("availableIpAddressCount", false, x => parseInt(x.content ?? '0')),
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    DefaultForAz: node.first("defaultForAz", false, x => x.content === 'true'),
    MapPublicIpOnLaunch: node.first("mapPublicIpOnLaunch", false, x => x.content === 'true'),
    MapCustomerOwnedIpOnLaunch: node.first("mapCustomerOwnedIpOnLaunch", false, x => x.content === 'true'),
    CustomerOwnedIpv4Pool: node.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.SubnetState),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    AssignIpv6AddressOnCreation: node.first("assignIpv6AddressOnCreation", false, x => x.content === 'true'),
    Ipv6CidrBlockAssociationSet: node.getList("ipv6CidrBlockAssociationSet", "item").map(SubnetIpv6CidrBlockAssociation_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    SubnetArn: node.first("subnetArn", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
  };
}

function Vpc_Parse(node: xmlP.XmlNode): s.Vpc {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    DhcpOptionsId: node.first("dhcpOptionsId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.VpcState),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as s.Tenancy),
    Ipv6CidrBlockAssociationSet: node.getList("ipv6CidrBlockAssociationSet", "item").map(VpcIpv6CidrBlockAssociation_Parse),
    CidrBlockAssociationSet: node.getList("cidrBlockAssociationSet", "item").map(VpcCidrBlockAssociation_Parse),
    IsDefault: node.first("isDefault", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function DhcpOptions_Parse(node: xmlP.XmlNode): s.DhcpOptions {
  return {
    DhcpConfigurations: node.getList("dhcpConfigurationSet", "item").map(DhcpConfiguration_Parse),
    DhcpOptionsId: node.first("dhcpOptionsId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function DhcpConfiguration_Parse(node: xmlP.XmlNode): s.DhcpConfiguration {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    Values: node.getList("valueSet", "item").map(AttributeValue_Parse),
  };
}

function EgressOnlyInternetGateway_Parse(node: xmlP.XmlNode): s.EgressOnlyInternetGateway {
  return {
    Attachments: node.getList("attachmentSet", "item").map(InternetGatewayAttachment_Parse),
    EgressOnlyInternetGatewayId: node.first("egressOnlyInternetGatewayId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function InternetGatewayAttachment_Parse(node: xmlP.XmlNode): s.InternetGatewayAttachment {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.AttachmentStatus),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function CreateFleetError_Parse(node: xmlP.XmlNode): s.CreateFleetError {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as s.InstanceLifecycle),
    ErrorCode: node.first("errorCode", false, x => x.content ?? ''),
    ErrorMessage: node.first("errorMessage", false, x => x.content ?? ''),
  };
}

function LaunchTemplateAndOverridesResponse_Parse(node: xmlP.XmlNode): s.LaunchTemplateAndOverridesResponse {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.first("overrides", false, FleetLaunchTemplateOverrides_Parse),
  };
}

function FleetLaunchTemplateOverrides_Parse(node: xmlP.XmlNode): s.FleetLaunchTemplateOverrides {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    MaxPrice: node.first("maxPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    Priority: node.first("priority", false, x => parseFloat(x.content ?? '0')),
    Placement: node.first("placement", false, PlacementResponse_Parse),
  };
}

function PlacementResponse_Parse(node: xmlP.XmlNode): s.PlacementResponse {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
  };
}

function CreateFleetInstance_Parse(node: xmlP.XmlNode): s.CreateFleetInstance {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as s.InstanceLifecycle),
    InstanceIds: node.getList("instanceIds", "item").map(x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    Platform: node.first("platform", false, x => (x.content ?? '') as s.PlatformValues),
  };
}

function ExportTask_Parse(node: xmlP.XmlNode): s.ExportTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ExportTaskId: node.first("exportTaskId", false, x => x.content ?? ''),
    ExportToS3Task: node.first("exportToS3", false, ExportToS3Task_Parse),
    InstanceExportDetails: node.first("instanceExport", false, InstanceExportDetails_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.ExportTaskState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ExportToS3Task_Parse(node: xmlP.XmlNode): s.ExportToS3Task {
  return {
    ContainerFormat: node.first("containerFormat", false, x => (x.content ?? '') as s.ContainerFormat),
    DiskImageFormat: node.first("diskImageFormat", false, x => (x.content ?? '') as s.DiskImageFormat),
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Key: node.first("s3Key", false, x => x.content ?? ''),
  };
}

function InstanceExportDetails_Parse(node: xmlP.XmlNode): s.InstanceExportDetails {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    TargetEnvironment: node.first("targetEnvironment", false, x => (x.content ?? '') as s.ExportEnvironment),
  };
}

function InternetGateway_Parse(node: xmlP.XmlNode): s.InternetGateway {
  return {
    Attachments: node.getList("attachmentSet", "item").map(InternetGatewayAttachment_Parse),
    InternetGatewayId: node.first("internetGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LaunchTemplate_Parse(node: xmlP.XmlNode): s.LaunchTemplate {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    CreatedBy: node.first("createdBy", false, x => x.content ?? ''),
    DefaultVersionNumber: node.first("defaultVersionNumber", false, x => parseInt(x.content ?? '0')),
    LatestVersionNumber: node.first("latestVersionNumber", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ValidationWarning_Parse(node: xmlP.XmlNode): s.ValidationWarning {
  return {
    Errors: node.getList("errorSet", "item").map(ValidationError_Parse),
  };
}

function ValidationError_Parse(node: xmlP.XmlNode): s.ValidationError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function LaunchTemplateVersion_Parse(node: xmlP.XmlNode): s.LaunchTemplateVersion {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
    VersionDescription: node.first("versionDescription", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    CreatedBy: node.first("createdBy", false, x => x.content ?? ''),
    DefaultVersion: node.first("defaultVersion", false, x => x.content === 'true'),
    LaunchTemplateData: node.first("launchTemplateData", false, ResponseLaunchTemplateData_Parse),
  };
}

function ResponseLaunchTemplateData_Parse(node: xmlP.XmlNode): s.ResponseLaunchTemplateData {
  return {
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, LaunchTemplateIamInstanceProfileSpecification_Parse),
    BlockDeviceMappings: node.getList("blockDeviceMappingSet", "item").map(LaunchTemplateBlockDeviceMapping_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(LaunchTemplateInstanceNetworkInterfaceSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, LaunchTemplatesMonitoring_Parse),
    Placement: node.first("placement", false, LaunchTemplatePlacement_Parse),
    RamDiskId: node.first("ramDiskId", false, x => x.content ?? ''),
    DisableApiTermination: node.first("disableApiTermination", false, x => x.content === 'true'),
    InstanceInitiatedShutdownBehavior: node.first("instanceInitiatedShutdownBehavior", false, x => (x.content ?? '') as s.ShutdownBehavior),
    UserData: node.first("userData", false, x => x.content ?? ''),
    TagSpecifications: node.getList("tagSpecificationSet", "item").map(LaunchTemplateTagSpecification_Parse),
    ElasticGpuSpecifications: node.getList("elasticGpuSpecificationSet", "item").map(ElasticGpuSpecificationResponse_Parse),
    ElasticInferenceAccelerators: node.getList("elasticInferenceAcceleratorSet", "item").map(LaunchTemplateElasticInferenceAcceleratorResponse_Parse),
    SecurityGroupIds: node.getList("securityGroupIdSet", "item").map(x => x.content ?? ''),
    SecurityGroups: node.getList("securityGroupSet", "item").map(x => x.content ?? ''),
    InstanceMarketOptions: node.first("instanceMarketOptions", false, LaunchTemplateInstanceMarketOptions_Parse),
    CreditSpecification: node.first("creditSpecification", false, CreditSpecification_Parse),
    CpuOptions: node.first("cpuOptions", false, LaunchTemplateCpuOptions_Parse),
    CapacityReservationSpecification: node.first("capacityReservationSpecification", false, LaunchTemplateCapacityReservationSpecificationResponse_Parse),
    LicenseSpecifications: node.getList("licenseSet", "item").map(LaunchTemplateLicenseConfiguration_Parse),
    HibernationOptions: node.first("hibernationOptions", false, LaunchTemplateHibernationOptions_Parse),
    MetadataOptions: node.first("metadataOptions", false, LaunchTemplateInstanceMetadataOptions_Parse),
    EnclaveOptions: node.first("enclaveOptions", false, LaunchTemplateEnclaveOptions_Parse),
  };
}

function LaunchTemplateIamInstanceProfileSpecification_Parse(node: xmlP.XmlNode): s.LaunchTemplateIamInstanceProfileSpecification {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

function LaunchTemplateBlockDeviceMapping_Parse(node: xmlP.XmlNode): s.LaunchTemplateBlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    VirtualName: node.first("virtualName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, LaunchTemplateEbsBlockDevice_Parse),
    NoDevice: node.first("noDevice", false, x => x.content ?? ''),
  };
}

function LaunchTemplateEbsBlockDevice_Parse(node: xmlP.XmlNode): s.LaunchTemplateEbsBlockDevice {
  return {
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as s.VolumeType),
    Throughput: node.first("throughput", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchTemplateInstanceNetworkInterfaceSpecification_Parse(node: xmlP.XmlNode): s.LaunchTemplateInstanceNetworkInterfaceSpecification {
  return {
    AssociateCarrierIpAddress: node.first("associateCarrierIpAddress", false, x => x.content === 'true'),
    AssociatePublicIpAddress: node.first("associatePublicIpAddress", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Groups: node.getList("groupSet", "groupId").map(x => x.content ?? ''),
    InterfaceType: node.first("interfaceType", false, x => x.content ?? ''),
    Ipv6AddressCount: node.first("ipv6AddressCount", false, x => parseInt(x.content ?? '0')),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(InstanceIpv6Address_Parse),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(PrivateIpAddressSpecification_Parse),
    SecondaryPrivateIpAddressCount: node.first("secondaryPrivateIpAddressCount", false, x => parseInt(x.content ?? '0')),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    NetworkCardIndex: node.first("networkCardIndex", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchTemplatesMonitoring_Parse(node: xmlP.XmlNode): s.LaunchTemplatesMonitoring {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

function LaunchTemplatePlacement_Parse(node: xmlP.XmlNode): s.LaunchTemplatePlacement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Affinity: node.first("affinity", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as s.Tenancy),
    SpreadDomain: node.first("spreadDomain", false, x => x.content ?? ''),
    HostResourceGroupArn: node.first("hostResourceGroupArn", false, x => x.content ?? ''),
    PartitionNumber: node.first("partitionNumber", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchTemplateTagSpecification_Parse(node: xmlP.XmlNode): s.LaunchTemplateTagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.ResourceType),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ElasticGpuSpecificationResponse_Parse(node: xmlP.XmlNode): s.ElasticGpuSpecificationResponse {
  return {
    Type: node.first("type", false, x => x.content ?? ''),
  };
}

function LaunchTemplateElasticInferenceAcceleratorResponse_Parse(node: xmlP.XmlNode): s.LaunchTemplateElasticInferenceAcceleratorResponse {
  return {
    Type: node.first("type", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchTemplateInstanceMarketOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateInstanceMarketOptions {
  return {
    MarketType: node.first("marketType", false, x => (x.content ?? '') as s.MarketType),
    SpotOptions: node.first("spotOptions", false, LaunchTemplateSpotMarketOptions_Parse),
  };
}

function LaunchTemplateSpotMarketOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateSpotMarketOptions {
  return {
    MaxPrice: node.first("maxPrice", false, x => x.content ?? ''),
    SpotInstanceType: node.first("spotInstanceType", false, x => (x.content ?? '') as s.SpotInstanceType),
    BlockDurationMinutes: node.first("blockDurationMinutes", false, x => parseInt(x.content ?? '0')),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as s.InstanceInterruptionBehavior),
  };
}

function CreditSpecification_Parse(node: xmlP.XmlNode): s.CreditSpecification {
  return {
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

function LaunchTemplateCpuOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateCpuOptions {
  return {
    CoreCount: node.first("coreCount", false, x => parseInt(x.content ?? '0')),
    ThreadsPerCore: node.first("threadsPerCore", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchTemplateCapacityReservationSpecificationResponse_Parse(node: xmlP.XmlNode): s.LaunchTemplateCapacityReservationSpecificationResponse {
  return {
    CapacityReservationPreference: node.first("capacityReservationPreference", false, x => (x.content ?? '') as s.CapacityReservationPreference),
    CapacityReservationTarget: node.first("capacityReservationTarget", false, CapacityReservationTargetResponse_Parse),
  };
}

function CapacityReservationTargetResponse_Parse(node: xmlP.XmlNode): s.CapacityReservationTargetResponse {
  return {
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    CapacityReservationResourceGroupArn: node.first("capacityReservationResourceGroupArn", false, x => x.content ?? ''),
  };
}

function LaunchTemplateLicenseConfiguration_Parse(node: xmlP.XmlNode): s.LaunchTemplateLicenseConfiguration {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

function LaunchTemplateHibernationOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateHibernationOptions {
  return {
    Configured: node.first("configured", false, x => x.content === 'true'),
  };
}

function LaunchTemplateInstanceMetadataOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateInstanceMetadataOptions {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.LaunchTemplateInstanceMetadataOptionsState),
    HttpTokens: node.first("httpTokens", false, x => (x.content ?? '') as s.LaunchTemplateHttpTokensState),
    HttpPutResponseHopLimit: node.first("httpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("httpEndpoint", false, x => (x.content ?? '') as s.LaunchTemplateInstanceMetadataEndpointState),
  };
}

function LaunchTemplateEnclaveOptions_Parse(node: xmlP.XmlNode): s.LaunchTemplateEnclaveOptions {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

function LocalGatewayRoute_Parse(node: xmlP.XmlNode): s.LocalGatewayRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    Type: node.first("type", false, x => (x.content ?? '') as s.LocalGatewayRouteType),
    State: node.first("state", false, x => (x.content ?? '') as s.LocalGatewayRouteState),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function LocalGatewayRouteTableVpcAssociation_Parse(node: xmlP.XmlNode): s.LocalGatewayRouteTableVpcAssociation {
  return {
    LocalGatewayRouteTableVpcAssociationId: node.first("localGatewayRouteTableVpcAssociationId", false, x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ManagedPrefixList_Parse(node: xmlP.XmlNode): s.ManagedPrefixList {
  return {
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    AddressFamily: node.first("addressFamily", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.PrefixListState),
    StateMessage: node.first("stateMessage", false, x => x.content ?? ''),
    PrefixListArn: node.first("prefixListArn", false, x => x.content ?? ''),
    PrefixListName: node.first("prefixListName", false, x => x.content ?? ''),
    MaxEntries: node.first("maxEntries", false, x => parseInt(x.content ?? '0')),
    Version: node.first("version", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function NatGateway_Parse(node: xmlP.XmlNode): s.NatGateway {
  return {
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    DeleteTime: node.first("deleteTime", false, x => xmlP.parseTimestamp(x.content)),
    FailureCode: node.first("failureCode", false, x => x.content ?? ''),
    FailureMessage: node.first("failureMessage", false, x => x.content ?? ''),
    NatGatewayAddresses: node.getList("natGatewayAddressSet", "item").map(NatGatewayAddress_Parse),
    NatGatewayId: node.first("natGatewayId", false, x => x.content ?? ''),
    ProvisionedBandwidth: node.first("provisionedBandwidth", false, ProvisionedBandwidth_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.NatGatewayState),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function NatGatewayAddress_Parse(node: xmlP.XmlNode): s.NatGatewayAddress {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIp: node.first("privateIp", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

function ProvisionedBandwidth_Parse(node: xmlP.XmlNode): s.ProvisionedBandwidth {
  return {
    ProvisionTime: node.first("provisionTime", false, x => xmlP.parseTimestamp(x.content)),
    Provisioned: node.first("provisioned", false, x => x.content ?? ''),
    RequestTime: node.first("requestTime", false, x => xmlP.parseTimestamp(x.content)),
    Requested: node.first("requested", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
  };
}

function NetworkAcl_Parse(node: xmlP.XmlNode): s.NetworkAcl {
  return {
    Associations: node.getList("associationSet", "item").map(NetworkAclAssociation_Parse),
    Entries: node.getList("entrySet", "item").map(NetworkAclEntry_Parse),
    IsDefault: node.first("default", false, x => x.content === 'true'),
    NetworkAclId: node.first("networkAclId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function NetworkAclAssociation_Parse(node: xmlP.XmlNode): s.NetworkAclAssociation {
  return {
    NetworkAclAssociationId: node.first("networkAclAssociationId", false, x => x.content ?? ''),
    NetworkAclId: node.first("networkAclId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
  };
}

function NetworkAclEntry_Parse(node: xmlP.XmlNode): s.NetworkAclEntry {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    Egress: node.first("egress", false, x => x.content === 'true'),
    IcmpTypeCode: node.first("icmpTypeCode", false, IcmpTypeCode_Parse),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    PortRange: node.first("portRange", false, PortRange_Parse),
    Protocol: node.first("protocol", false, x => x.content ?? ''),
    RuleAction: node.first("ruleAction", false, x => (x.content ?? '') as s.RuleAction),
    RuleNumber: node.first("ruleNumber", false, x => parseInt(x.content ?? '0')),
  };
}

function NetworkInsightsPath_Parse(node: xmlP.XmlNode): s.NetworkInsightsPath {
  return {
    NetworkInsightsPathId: node.first("networkInsightsPathId", false, x => x.content ?? ''),
    NetworkInsightsPathArn: node.first("networkInsightsPathArn", false, x => x.content ?? ''),
    CreatedDate: node.first("createdDate", false, x => xmlP.parseTimestamp(x.content)),
    Source: node.first("source", false, x => x.content ?? ''),
    Destination: node.first("destination", false, x => x.content ?? ''),
    SourceIp: node.first("sourceIp", false, x => x.content ?? ''),
    DestinationIp: node.first("destinationIp", false, x => x.content ?? ''),
    Protocol: node.first("protocol", false, x => (x.content ?? '') as s.Protocol),
    DestinationPort: node.first("destinationPort", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function NetworkInterface_Parse(node: xmlP.XmlNode): s.NetworkInterface {
  return {
    Association: node.first("association", false, NetworkInterfaceAssociation_Parse),
    Attachment: node.first("attachment", false, NetworkInterfaceAttachment_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    InterfaceType: node.first("interfaceType", false, x => (x.content ?? '') as s.NetworkInterfaceType),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(NetworkInterfaceIpv6Address_Parse),
    MacAddress: node.first("macAddress", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(NetworkInterfacePrivateIpAddress_Parse),
    RequesterId: node.first("requesterId", false, x => x.content ?? ''),
    RequesterManaged: node.first("requesterManaged", false, x => x.content === 'true'),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as s.NetworkInterfaceStatus),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    TagSet: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function NetworkInterfaceAssociation_Parse(node: xmlP.XmlNode): s.NetworkInterfaceAssociation {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    IpOwnerId: node.first("ipOwnerId", false, x => x.content ?? ''),
    PublicDnsName: node.first("publicDnsName", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
    CustomerOwnedIp: node.first("customerOwnedIp", false, x => x.content ?? ''),
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
  };
}

function NetworkInterfaceAttachment_Parse(node: xmlP.XmlNode): s.NetworkInterfaceAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    AttachmentId: node.first("attachmentId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    NetworkCardIndex: node.first("networkCardIndex", false, x => parseInt(x.content ?? '0')),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceOwnerId: node.first("instanceOwnerId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as s.AttachmentStatus),
  };
}

function NetworkInterfaceIpv6Address_Parse(node: xmlP.XmlNode): s.NetworkInterfaceIpv6Address {
  return {
    Ipv6Address: node.first("ipv6Address", false, x => x.content ?? ''),
  };
}

function NetworkInterfacePrivateIpAddress_Parse(node: xmlP.XmlNode): s.NetworkInterfacePrivateIpAddress {
  return {
    Association: node.first("association", false, NetworkInterfaceAssociation_Parse),
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

function NetworkInterfacePermission_Parse(node: xmlP.XmlNode): s.NetworkInterfacePermission {
  return {
    NetworkInterfacePermissionId: node.first("networkInterfacePermissionId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    AwsAccountId: node.first("awsAccountId", false, x => x.content ?? ''),
    AwsService: node.first("awsService", false, x => x.content ?? ''),
    Permission: node.first("permission", false, x => (x.content ?? '') as s.InterfacePermissionType),
    PermissionState: node.first("permissionState", false, NetworkInterfacePermissionState_Parse),
  };
}

function NetworkInterfacePermissionState_Parse(node: xmlP.XmlNode): s.NetworkInterfacePermissionState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.NetworkInterfacePermissionStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

function PlacementGroup_Parse(node: xmlP.XmlNode): s.PlacementGroup {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.PlacementGroupState),
    Strategy: node.first("strategy", false, x => (x.content ?? '') as s.PlacementStrategy),
    PartitionCount: node.first("partitionCount", false, x => parseInt(x.content ?? '0')),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function RouteTable_Parse(node: xmlP.XmlNode): s.RouteTable {
  return {
    Associations: node.getList("associationSet", "item").map(RouteTableAssociation_Parse),
    PropagatingVgws: node.getList("propagatingVgwSet", "item").map(PropagatingVgw_Parse),
    RouteTableId: node.first("routeTableId", false, x => x.content ?? ''),
    Routes: node.getList("routeSet", "item").map(Route_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function RouteTableAssociation_Parse(node: xmlP.XmlNode): s.RouteTableAssociation {
  return {
    Main: node.first("main", false, x => x.content === 'true'),
    RouteTableAssociationId: node.first("routeTableAssociationId", false, x => x.content ?? ''),
    RouteTableId: node.first("routeTableId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
    AssociationState: node.first("associationState", false, RouteTableAssociationState_Parse),
  };
}

function PropagatingVgw_Parse(node: xmlP.XmlNode): s.PropagatingVgw {
  return {
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
  };
}

function Route_Parse(node: xmlP.XmlNode): s.Route {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    DestinationIpv6CidrBlock: node.first("destinationIpv6CidrBlock", false, x => x.content ?? ''),
    DestinationPrefixListId: node.first("destinationPrefixListId", false, x => x.content ?? ''),
    EgressOnlyInternetGatewayId: node.first("egressOnlyInternetGatewayId", false, x => x.content ?? ''),
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceOwnerId: node.first("instanceOwnerId", false, x => x.content ?? ''),
    NatGatewayId: node.first("natGatewayId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    CarrierGatewayId: node.first("carrierGatewayId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    Origin: node.first("origin", false, x => (x.content ?? '') as s.RouteOrigin),
    State: node.first("state", false, x => (x.content ?? '') as s.RouteState),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

function SnapshotInfo_Parse(node: xmlP.XmlNode): s.SnapshotInfo {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.SnapshotState),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    Progress: node.first("progress", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
  };
}

function SpotDatafeedSubscription_Parse(node: xmlP.XmlNode): s.SpotDatafeedSubscription {
  return {
    Bucket: node.first("bucket", false, x => x.content ?? ''),
    Fault: node.first("fault", false, SpotInstanceStateFault_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Prefix: node.first("prefix", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.DatafeedSubscriptionState),
  };
}

function SpotInstanceStateFault_Parse(node: xmlP.XmlNode): s.SpotInstanceStateFault {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function TrafficMirrorFilter_Parse(node: xmlP.XmlNode): s.TrafficMirrorFilter {
  return {
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    IngressFilterRules: node.getList("ingressFilterRuleSet", "item").map(TrafficMirrorFilterRule_Parse),
    EgressFilterRules: node.getList("egressFilterRuleSet", "item").map(TrafficMirrorFilterRule_Parse),
    NetworkServices: node.getList("networkServiceSet", "item").map(x => (x.content ?? '') as s.TrafficMirrorNetworkService),
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TrafficMirrorFilterRule_Parse(node: xmlP.XmlNode): s.TrafficMirrorFilterRule {
  return {
    TrafficMirrorFilterRuleId: node.first("trafficMirrorFilterRuleId", false, x => x.content ?? ''),
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    TrafficDirection: node.first("trafficDirection", false, x => (x.content ?? '') as s.TrafficDirection),
    RuleNumber: node.first("ruleNumber", false, x => parseInt(x.content ?? '0')),
    RuleAction: node.first("ruleAction", false, x => (x.content ?? '') as s.TrafficMirrorRuleAction),
    Protocol: node.first("protocol", false, x => parseInt(x.content ?? '0')),
    DestinationPortRange: node.first("destinationPortRange", false, TrafficMirrorPortRange_Parse),
    SourcePortRange: node.first("sourcePortRange", false, TrafficMirrorPortRange_Parse),
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    SourceCidrBlock: node.first("sourceCidrBlock", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

function TrafficMirrorPortRange_Parse(node: xmlP.XmlNode): s.TrafficMirrorPortRange {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
  };
}

function TrafficMirrorSession_Parse(node: xmlP.XmlNode): s.TrafficMirrorSession {
  return {
    TrafficMirrorSessionId: node.first("trafficMirrorSessionId", false, x => x.content ?? ''),
    TrafficMirrorTargetId: node.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PacketLength: node.first("packetLength", false, x => parseInt(x.content ?? '0')),
    SessionNumber: node.first("sessionNumber", false, x => parseInt(x.content ?? '0')),
    VirtualNetworkId: node.first("virtualNetworkId", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TrafficMirrorTarget_Parse(node: xmlP.XmlNode): s.TrafficMirrorTarget {
  return {
    TrafficMirrorTargetId: node.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    NetworkLoadBalancerArn: node.first("networkLoadBalancerArn", false, x => x.content ?? ''),
    Type: node.first("type", false, x => (x.content ?? '') as s.TrafficMirrorTargetType),
    Description: node.first("description", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGateway_Parse(node: xmlP.XmlNode): s.TransitGateway {
  return {
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    TransitGatewayArn: node.first("transitGatewayArn", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayState),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Options: node.first("options", false, TransitGatewayOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayOptions_Parse(node: xmlP.XmlNode): s.TransitGatewayOptions {
  return {
    AmazonSideAsn: node.first("amazonSideAsn", false, x => parseInt(x.content ?? '0')),
    TransitGatewayCidrBlocks: node.getList("transitGatewayCidrBlocks", "item").map(x => x.content ?? ''),
    AutoAcceptSharedAttachments: node.first("autoAcceptSharedAttachments", false, x => (x.content ?? '') as s.AutoAcceptSharedAttachmentsValue),
    DefaultRouteTableAssociation: node.first("defaultRouteTableAssociation", false, x => (x.content ?? '') as s.DefaultRouteTableAssociationValue),
    AssociationDefaultRouteTableId: node.first("associationDefaultRouteTableId", false, x => x.content ?? ''),
    DefaultRouteTablePropagation: node.first("defaultRouteTablePropagation", false, x => (x.content ?? '') as s.DefaultRouteTablePropagationValue),
    PropagationDefaultRouteTableId: node.first("propagationDefaultRouteTableId", false, x => x.content ?? ''),
    VpnEcmpSupport: node.first("vpnEcmpSupport", false, x => (x.content ?? '') as s.VpnEcmpSupportValue),
    DnsSupport: node.first("dnsSupport", false, x => (x.content ?? '') as s.DnsSupportValue),
    MulticastSupport: node.first("multicastSupport", false, x => (x.content ?? '') as s.MulticastSupportValue),
  };
}

function TransitGatewayConnect_Parse(node: xmlP.XmlNode): s.TransitGatewayConnect {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransportTransitGatewayAttachmentId: node.first("transportTransitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAttachmentState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Options: node.first("options", false, TransitGatewayConnectOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayConnectOptions_Parse(node: xmlP.XmlNode): s.TransitGatewayConnectOptions {
  return {
    Protocol: node.first("protocol", false, x => (x.content ?? '') as s.ProtocolValue),
  };
}

function TransitGatewayConnectPeer_Parse(node: xmlP.XmlNode): s.TransitGatewayConnectPeer {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayConnectPeerId: node.first("transitGatewayConnectPeerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayConnectPeerState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    ConnectPeerConfiguration: node.first("connectPeerConfiguration", false, TransitGatewayConnectPeerConfiguration_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayConnectPeerConfiguration_Parse(node: xmlP.XmlNode): s.TransitGatewayConnectPeerConfiguration {
  return {
    TransitGatewayAddress: node.first("transitGatewayAddress", false, x => x.content ?? ''),
    PeerAddress: node.first("peerAddress", false, x => x.content ?? ''),
    InsideCidrBlocks: node.getList("insideCidrBlocks", "item").map(x => x.content ?? ''),
    Protocol: node.first("protocol", false, x => (x.content ?? '') as s.ProtocolValue),
    BgpConfigurations: node.getList("bgpConfigurations", "item").map(TransitGatewayAttachmentBgpConfiguration_Parse),
  };
}

function TransitGatewayAttachmentBgpConfiguration_Parse(node: xmlP.XmlNode): s.TransitGatewayAttachmentBgpConfiguration {
  return {
    TransitGatewayAsn: node.first("transitGatewayAsn", false, x => parseInt(x.content ?? '0')),
    PeerAsn: node.first("peerAsn", false, x => parseInt(x.content ?? '0')),
    TransitGatewayAddress: node.first("transitGatewayAddress", false, x => x.content ?? ''),
    PeerAddress: node.first("peerAddress", false, x => x.content ?? ''),
    BgpStatus: node.first("bgpStatus", false, x => (x.content ?? '') as s.BgpStatus),
  };
}

function TransitGatewayMulticastDomain_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDomain {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    TransitGatewayMulticastDomainArn: node.first("transitGatewayMulticastDomainArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Options: node.first("options", false, TransitGatewayMulticastDomainOptions_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayMulticastDomainState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayMulticastDomainOptions_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDomainOptions {
  return {
    Igmpv2Support: node.first("igmpv2Support", false, x => (x.content ?? '') as s.Igmpv2SupportValue),
    StaticSourcesSupport: node.first("staticSourcesSupport", false, x => (x.content ?? '') as s.StaticSourcesSupportValue),
    AutoAcceptSharedAssociations: node.first("autoAcceptSharedAssociations", false, x => (x.content ?? '') as s.AutoAcceptSharedAssociationsValue),
  };
}

function TransitGatewayPrefixListReference_Parse(node: xmlP.XmlNode): s.TransitGatewayPrefixListReference {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    PrefixListOwnerId: node.first("prefixListOwnerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayPrefixListReferenceState),
    Blackhole: node.first("blackhole", false, x => x.content === 'true'),
    TransitGatewayAttachment: node.first("transitGatewayAttachment", false, TransitGatewayPrefixListAttachment_Parse),
  };
}

function TransitGatewayPrefixListAttachment_Parse(node: xmlP.XmlNode): s.TransitGatewayPrefixListAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
  };
}

function TransitGatewayRoute_Parse(node: xmlP.XmlNode): s.TransitGatewayRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    TransitGatewayAttachments: node.getList("transitGatewayAttachments", "item").map(TransitGatewayRouteAttachment_Parse),
    Type: node.first("type", false, x => (x.content ?? '') as s.TransitGatewayRouteType),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayRouteState),
  };
}

function TransitGatewayRouteAttachment_Parse(node: xmlP.XmlNode): s.TransitGatewayRouteAttachment {
  return {
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
  };
}

function TransitGatewayRouteTable_Parse(node: xmlP.XmlNode): s.TransitGatewayRouteTable {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayRouteTableState),
    DefaultAssociationRouteTable: node.first("defaultAssociationRouteTable", false, x => x.content === 'true'),
    DefaultPropagationRouteTable: node.first("defaultPropagationRouteTable", false, x => x.content === 'true'),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function VpcEndpoint_Parse(node: xmlP.XmlNode): s.VpcEndpoint {
  return {
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    VpcEndpointType: node.first("vpcEndpointType", false, x => (x.content ?? '') as s.VpcEndpointType),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.State),
    PolicyDocument: node.first("policyDocument", false, x => x.content ?? ''),
    RouteTableIds: node.getList("routeTableIdSet", "item").map(x => x.content ?? ''),
    SubnetIds: node.getList("subnetIdSet", "item").map(x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(SecurityGroupIdentifier_Parse),
    PrivateDnsEnabled: node.first("privateDnsEnabled", false, x => x.content === 'true'),
    RequesterManaged: node.first("requesterManaged", false, x => x.content === 'true'),
    NetworkInterfaceIds: node.getList("networkInterfaceIdSet", "item").map(x => x.content ?? ''),
    DnsEntries: node.getList("dnsEntrySet", "item").map(DnsEntry_Parse),
    CreationTimestamp: node.first("creationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    LastError: node.first("lastError", false, LastError_Parse),
  };
}

function SecurityGroupIdentifier_Parse(node: xmlP.XmlNode): s.SecurityGroupIdentifier {
  return {
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
  };
}

function DnsEntry_Parse(node: xmlP.XmlNode): s.DnsEntry {
  return {
    DnsName: node.first("dnsName", false, x => x.content ?? ''),
    HostedZoneId: node.first("hostedZoneId", false, x => x.content ?? ''),
  };
}

function LastError_Parse(node: xmlP.XmlNode): s.LastError {
  return {
    Message: node.first("message", false, x => x.content ?? ''),
    Code: node.first("code", false, x => x.content ?? ''),
  };
}

function ConnectionNotification_Parse(node: xmlP.XmlNode): s.ConnectionNotification {
  return {
    ConnectionNotificationId: node.first("connectionNotificationId", false, x => x.content ?? ''),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    ConnectionNotificationType: node.first("connectionNotificationType", false, x => (x.content ?? '') as s.ConnectionNotificationType),
    ConnectionNotificationArn: node.first("connectionNotificationArn", false, x => x.content ?? ''),
    ConnectionEvents: node.getList("connectionEvents", "item").map(x => x.content ?? ''),
    ConnectionNotificationState: node.first("connectionNotificationState", false, x => (x.content ?? '') as s.ConnectionNotificationState),
  };
}

function ServiceConfiguration_Parse(node: xmlP.XmlNode): s.ServiceConfiguration {
  return {
    ServiceType: node.getList("serviceType", "item").map(ServiceTypeDetail_Parse),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    ServiceState: node.first("serviceState", false, x => (x.content ?? '') as s.ServiceState),
    AvailabilityZones: node.getList("availabilityZoneSet", "item").map(x => x.content ?? ''),
    AcceptanceRequired: node.first("acceptanceRequired", false, x => x.content === 'true'),
    ManagesVpcEndpoints: node.first("managesVpcEndpoints", false, x => x.content === 'true'),
    NetworkLoadBalancerArns: node.getList("networkLoadBalancerArnSet", "item").map(x => x.content ?? ''),
    GatewayLoadBalancerArns: node.getList("gatewayLoadBalancerArnSet", "item").map(x => x.content ?? ''),
    BaseEndpointDnsNames: node.getList("baseEndpointDnsNameSet", "item").map(x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateDnsNameConfiguration: node.first("privateDnsNameConfiguration", false, PrivateDnsNameConfiguration_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ServiceTypeDetail_Parse(node: xmlP.XmlNode): s.ServiceTypeDetail {
  return {
    ServiceType: node.first("serviceType", false, x => (x.content ?? '') as s.ServiceType),
  };
}

function PrivateDnsNameConfiguration_Parse(node: xmlP.XmlNode): s.PrivateDnsNameConfiguration {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.DnsNameState),
    Type: node.first("type", false, x => x.content ?? ''),
    Value: node.first("value", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

function VpnConnection_Parse(node: xmlP.XmlNode): s.VpnConnection {
  return {
    CustomerGatewayConfiguration: node.first("customerGatewayConfiguration", false, x => x.content ?? ''),
    CustomerGatewayId: node.first("customerGatewayId", false, x => x.content ?? ''),
    Category: node.first("category", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.VpnState),
    Type: node.first("type", false, x => (x.content ?? '') as s.GatewayType),
    VpnConnectionId: node.first("vpnConnectionId", false, x => x.content ?? ''),
    VpnGatewayId: node.first("vpnGatewayId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    Options: node.first("options", false, VpnConnectionOptions_Parse),
    Routes: node.getList("routes", "item").map(VpnStaticRoute_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VgwTelemetry: node.getList("vgwTelemetry", "item").map(VgwTelemetry_Parse),
  };
}

function VpnConnectionOptions_Parse(node: xmlP.XmlNode): s.VpnConnectionOptions {
  return {
    EnableAcceleration: node.first("enableAcceleration", false, x => x.content === 'true'),
    StaticRoutesOnly: node.first("staticRoutesOnly", false, x => x.content === 'true'),
    LocalIpv4NetworkCidr: node.first("localIpv4NetworkCidr", false, x => x.content ?? ''),
    RemoteIpv4NetworkCidr: node.first("remoteIpv4NetworkCidr", false, x => x.content ?? ''),
    LocalIpv6NetworkCidr: node.first("localIpv6NetworkCidr", false, x => x.content ?? ''),
    RemoteIpv6NetworkCidr: node.first("remoteIpv6NetworkCidr", false, x => x.content ?? ''),
    TunnelInsideIpVersion: node.first("tunnelInsideIpVersion", false, x => (x.content ?? '') as s.TunnelInsideIpVersion),
    TunnelOptions: node.getList("tunnelOptionSet", "item").map(TunnelOption_Parse),
  };
}

function TunnelOption_Parse(node: xmlP.XmlNode): s.TunnelOption {
  return {
    OutsideIpAddress: node.first("outsideIpAddress", false, x => x.content ?? ''),
    TunnelInsideCidr: node.first("tunnelInsideCidr", false, x => x.content ?? ''),
    TunnelInsideIpv6Cidr: node.first("tunnelInsideIpv6Cidr", false, x => x.content ?? ''),
    PreSharedKey: node.first("preSharedKey", false, x => x.content ?? ''),
    Phase1LifetimeSeconds: node.first("phase1LifetimeSeconds", false, x => parseInt(x.content ?? '0')),
    Phase2LifetimeSeconds: node.first("phase2LifetimeSeconds", false, x => parseInt(x.content ?? '0')),
    RekeyMarginTimeSeconds: node.first("rekeyMarginTimeSeconds", false, x => parseInt(x.content ?? '0')),
    RekeyFuzzPercentage: node.first("rekeyFuzzPercentage", false, x => parseInt(x.content ?? '0')),
    ReplayWindowSize: node.first("replayWindowSize", false, x => parseInt(x.content ?? '0')),
    DpdTimeoutSeconds: node.first("dpdTimeoutSeconds", false, x => parseInt(x.content ?? '0')),
    DpdTimeoutAction: node.first("dpdTimeoutAction", false, x => x.content ?? ''),
    Phase1EncryptionAlgorithms: node.getList("phase1EncryptionAlgorithmSet", "item").map(Phase1EncryptionAlgorithmsListValue_Parse),
    Phase2EncryptionAlgorithms: node.getList("phase2EncryptionAlgorithmSet", "item").map(Phase2EncryptionAlgorithmsListValue_Parse),
    Phase1IntegrityAlgorithms: node.getList("phase1IntegrityAlgorithmSet", "item").map(Phase1IntegrityAlgorithmsListValue_Parse),
    Phase2IntegrityAlgorithms: node.getList("phase2IntegrityAlgorithmSet", "item").map(Phase2IntegrityAlgorithmsListValue_Parse),
    Phase1DHGroupNumbers: node.getList("phase1DHGroupNumberSet", "item").map(Phase1DHGroupNumbersListValue_Parse),
    Phase2DHGroupNumbers: node.getList("phase2DHGroupNumberSet", "item").map(Phase2DHGroupNumbersListValue_Parse),
    IkeVersions: node.getList("ikeVersionSet", "item").map(IKEVersionsListValue_Parse),
    StartupAction: node.first("startupAction", false, x => x.content ?? ''),
  };
}

function Phase1EncryptionAlgorithmsListValue_Parse(node: xmlP.XmlNode): s.Phase1EncryptionAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function Phase2EncryptionAlgorithmsListValue_Parse(node: xmlP.XmlNode): s.Phase2EncryptionAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function Phase1IntegrityAlgorithmsListValue_Parse(node: xmlP.XmlNode): s.Phase1IntegrityAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function Phase2IntegrityAlgorithmsListValue_Parse(node: xmlP.XmlNode): s.Phase2IntegrityAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function Phase1DHGroupNumbersListValue_Parse(node: xmlP.XmlNode): s.Phase1DHGroupNumbersListValue {
  return {
    Value: node.first("value", false, x => parseInt(x.content ?? '0')),
  };
}

function Phase2DHGroupNumbersListValue_Parse(node: xmlP.XmlNode): s.Phase2DHGroupNumbersListValue {
  return {
    Value: node.first("value", false, x => parseInt(x.content ?? '0')),
  };
}

function IKEVersionsListValue_Parse(node: xmlP.XmlNode): s.IKEVersionsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function VpnStaticRoute_Parse(node: xmlP.XmlNode): s.VpnStaticRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    Source: node.first("source", false, x => (x.content ?? '') as s.VpnStaticRouteSource),
    State: node.first("state", false, x => (x.content ?? '') as s.VpnState),
  };
}

function VgwTelemetry_Parse(node: xmlP.XmlNode): s.VgwTelemetry {
  return {
    AcceptedRouteCount: node.first("acceptedRouteCount", false, x => parseInt(x.content ?? '0')),
    LastStatusChange: node.first("lastStatusChange", false, x => xmlP.parseTimestamp(x.content)),
    OutsideIpAddress: node.first("outsideIpAddress", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as s.TelemetryStatus),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    CertificateArn: node.first("certificateArn", false, x => x.content ?? ''),
  };
}

function VpnGateway_Parse(node: xmlP.XmlNode): s.VpnGateway {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.VpnState),
    Type: node.first("type", false, x => (x.content ?? '') as s.GatewayType),
    VpcAttachments: node.getList("attachments", "item").map(VpcAttachment_Parse),
    VpnGatewayId: node.first("vpnGatewayId", false, x => x.content ?? ''),
    AmazonSideAsn: node.first("amazonSideAsn", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function DeleteFleetSuccessItem_Parse(node: xmlP.XmlNode): s.DeleteFleetSuccessItem {
  return {
    CurrentFleetState: node.first("currentFleetState", false, x => (x.content ?? '') as s.FleetStateCode),
    PreviousFleetState: node.first("previousFleetState", false, x => (x.content ?? '') as s.FleetStateCode),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
  };
}

function DeleteFleetErrorItem_Parse(node: xmlP.XmlNode): s.DeleteFleetErrorItem {
  return {
    Error: node.first("error", false, DeleteFleetError_Parse),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
  };
}

function DeleteFleetError_Parse(node: xmlP.XmlNode): s.DeleteFleetError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.DeleteFleetErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function DeleteLaunchTemplateVersionsResponseSuccessItem_Parse(node: xmlP.XmlNode): s.DeleteLaunchTemplateVersionsResponseSuccessItem {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
  };
}

function DeleteLaunchTemplateVersionsResponseErrorItem_Parse(node: xmlP.XmlNode): s.DeleteLaunchTemplateVersionsResponseErrorItem {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
    ResponseError: node.first("responseError", false, ResponseError_Parse),
  };
}

function ResponseError_Parse(node: xmlP.XmlNode): s.ResponseError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.LaunchTemplateErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function SuccessfulQueuedPurchaseDeletion_Parse(node: xmlP.XmlNode): s.SuccessfulQueuedPurchaseDeletion {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

function FailedQueuedPurchaseDeletion_Parse(node: xmlP.XmlNode): s.FailedQueuedPurchaseDeletion {
  return {
    Error: node.first("error", false, DeleteQueuedReservedInstancesError_Parse),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

function DeleteQueuedReservedInstancesError_Parse(node: xmlP.XmlNode): s.DeleteQueuedReservedInstancesError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.DeleteQueuedReservedInstancesErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function InstanceTagNotificationAttribute_Parse(node: xmlP.XmlNode): s.InstanceTagNotificationAttribute {
  return {
    InstanceTagKeys: node.getList("instanceTagKeySet", "item").map(x => x.content ?? ''),
    IncludeAllTagsOfInstance: node.first("includeAllTagsOfInstance", false, x => x.content === 'true'),
  };
}

function TransitGatewayMulticastDeregisteredGroupMembers_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDeregisteredGroupMembers {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    DeregisteredNetworkInterfaceIds: node.getList("deregisteredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

function TransitGatewayMulticastDeregisteredGroupSources_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDeregisteredGroupSources {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    DeregisteredNetworkInterfaceIds: node.getList("deregisteredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

function AccountAttribute_Parse(node: xmlP.XmlNode): s.AccountAttribute {
  return {
    AttributeName: node.first("attributeName", false, x => x.content ?? ''),
    AttributeValues: node.getList("attributeValueSet", "item").map(AccountAttributeValue_Parse),
  };
}

function AccountAttributeValue_Parse(node: xmlP.XmlNode): s.AccountAttributeValue {
  return {
    AttributeValue: node.first("attributeValue", false, x => x.content ?? ''),
  };
}

function Address_Parse(node: xmlP.XmlNode): s.Address {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Domain: node.first("domain", false, x => (x.content ?? '') as s.DomainType),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    NetworkInterfaceOwnerId: node.first("networkInterfaceOwnerId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PublicIpv4Pool: node.first("publicIpv4Pool", false, x => x.content ?? ''),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    CustomerOwnedIp: node.first("customerOwnedIp", false, x => x.content ?? ''),
    CustomerOwnedIpv4Pool: node.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
  };
}

function AddressAttribute_Parse(node: xmlP.XmlNode): s.AddressAttribute {
  return {
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    PtrRecord: node.first("ptrRecord", false, x => x.content ?? ''),
    PtrRecordUpdate: node.first("ptrRecordUpdate", false, PtrUpdateStatus_Parse),
  };
}

function PtrUpdateStatus_Parse(node: xmlP.XmlNode): s.PtrUpdateStatus {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    Reason: node.first("reason", false, x => x.content ?? ''),
  };
}

function IdFormat_Parse(node: xmlP.XmlNode): s.IdFormat {
  return {
    Deadline: node.first("deadline", false, x => xmlP.parseTimestamp(x.content)),
    Resource: node.first("resource", false, x => x.content ?? ''),
    UseLongIds: node.first("useLongIds", false, x => x.content === 'true'),
  };
}

function AvailabilityZone_Parse(node: xmlP.XmlNode): s.AvailabilityZone {
  return {
    State: node.first("zoneState", false, x => (x.content ?? '') as s.AvailabilityZoneState),
    OptInStatus: node.first("optInStatus", false, x => (x.content ?? '') as s.AvailabilityZoneOptInStatus),
    Messages: node.getList("messageSet", "item").map(AvailabilityZoneMessage_Parse),
    RegionName: node.first("regionName", false, x => x.content ?? ''),
    ZoneName: node.first("zoneName", false, x => x.content ?? ''),
    ZoneId: node.first("zoneId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    ZoneType: node.first("zoneType", false, x => x.content ?? ''),
    ParentZoneName: node.first("parentZoneName", false, x => x.content ?? ''),
    ParentZoneId: node.first("parentZoneId", false, x => x.content ?? ''),
  };
}

function AvailabilityZoneMessage_Parse(node: xmlP.XmlNode): s.AvailabilityZoneMessage {
  return {
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ClassicLinkInstance_Parse(node: xmlP.XmlNode): s.ClassicLinkInstance {
  return {
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function AuthorizationRule_Parse(node: xmlP.XmlNode): s.AuthorizationRule {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    AccessAll: node.first("accessAll", false, x => x.content === 'true'),
    DestinationCidr: node.first("destinationCidr", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
  };
}

function ClientVpnConnection_Parse(node: xmlP.XmlNode): s.ClientVpnConnection {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Timestamp: node.first("timestamp", false, x => x.content ?? ''),
    ConnectionId: node.first("connectionId", false, x => x.content ?? ''),
    Username: node.first("username", false, x => x.content ?? ''),
    ConnectionEstablishedTime: node.first("connectionEstablishedTime", false, x => x.content ?? ''),
    IngressBytes: node.first("ingressBytes", false, x => x.content ?? ''),
    EgressBytes: node.first("egressBytes", false, x => x.content ?? ''),
    IngressPackets: node.first("ingressPackets", false, x => x.content ?? ''),
    EgressPackets: node.first("egressPackets", false, x => x.content ?? ''),
    ClientIp: node.first("clientIp", false, x => x.content ?? ''),
    CommonName: node.first("commonName", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnConnectionStatus_Parse),
    ConnectionEndTime: node.first("connectionEndTime", false, x => x.content ?? ''),
    PostureComplianceStatuses: node.getList("postureComplianceStatusSet", "item").map(x => x.content ?? ''),
  };
}

function ClientVpnConnectionStatus_Parse(node: xmlP.XmlNode): s.ClientVpnConnectionStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientVpnConnectionStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ClientVpnEndpoint_Parse(node: xmlP.XmlNode): s.ClientVpnEndpoint {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnEndpointStatus_Parse),
    CreationTime: node.first("creationTime", false, x => x.content ?? ''),
    DeletionTime: node.first("deletionTime", false, x => x.content ?? ''),
    DnsName: node.first("dnsName", false, x => x.content ?? ''),
    ClientCidrBlock: node.first("clientCidrBlock", false, x => x.content ?? ''),
    DnsServers: node.getList("dnsServer", "item").map(x => x.content ?? ''),
    SplitTunnel: node.first("splitTunnel", false, x => x.content === 'true'),
    VpnProtocol: node.first("vpnProtocol", false, x => (x.content ?? '') as s.VpnProtocol),
    TransportProtocol: node.first("transportProtocol", false, x => (x.content ?? '') as s.TransportProtocol),
    VpnPort: node.first("vpnPort", false, x => parseInt(x.content ?? '0')),
    AssociatedTargetNetworks: node.getList("associatedTargetNetwork", "item").map(AssociatedTargetNetwork_Parse),
    ServerCertificateArn: node.first("serverCertificateArn", false, x => x.content ?? ''),
    AuthenticationOptions: node.getList("authenticationOptions", "item").map(ClientVpnAuthentication_Parse),
    ConnectionLogOptions: node.first("connectionLogOptions", false, ConnectionLogResponseOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    SecurityGroupIds: node.getList("securityGroupIdSet", "item").map(x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    SelfServicePortalUrl: node.first("selfServicePortalUrl", false, x => x.content ?? ''),
    ClientConnectOptions: node.first("clientConnectOptions", false, ClientConnectResponseOptions_Parse),
  };
}

function AssociatedTargetNetwork_Parse(node: xmlP.XmlNode): s.AssociatedTargetNetwork {
  return {
    NetworkId: node.first("networkId", false, x => x.content ?? ''),
    NetworkType: node.first("networkType", false, x => (x.content ?? '') as s.AssociatedNetworkType),
  };
}

function ClientVpnAuthentication_Parse(node: xmlP.XmlNode): s.ClientVpnAuthentication {
  return {
    Type: node.first("type", false, x => (x.content ?? '') as s.ClientVpnAuthenticationType),
    ActiveDirectory: node.first("activeDirectory", false, DirectoryServiceAuthentication_Parse),
    MutualAuthentication: node.first("mutualAuthentication", false, CertificateAuthentication_Parse),
    FederatedAuthentication: node.first("federatedAuthentication", false, FederatedAuthentication_Parse),
  };
}

function DirectoryServiceAuthentication_Parse(node: xmlP.XmlNode): s.DirectoryServiceAuthentication {
  return {
    DirectoryId: node.first("directoryId", false, x => x.content ?? ''),
  };
}

function CertificateAuthentication_Parse(node: xmlP.XmlNode): s.CertificateAuthentication {
  return {
    ClientRootCertificateChain: node.first("clientRootCertificateChain", false, x => x.content ?? ''),
  };
}

function FederatedAuthentication_Parse(node: xmlP.XmlNode): s.FederatedAuthentication {
  return {
    SamlProviderArn: node.first("samlProviderArn", false, x => x.content ?? ''),
    SelfServiceSamlProviderArn: node.first("selfServiceSamlProviderArn", false, x => x.content ?? ''),
  };
}

function ConnectionLogResponseOptions_Parse(node: xmlP.XmlNode): s.ConnectionLogResponseOptions {
  return {
    ...node.strings({
      optional: {"CloudwatchLogGroup":true,"CloudwatchLogStream":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

function ClientConnectResponseOptions_Parse(node: xmlP.XmlNode): s.ClientConnectResponseOptions {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
    LambdaFunctionArn: node.first("lambdaFunctionArn", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnEndpointAttributeStatus_Parse),
  };
}

function ClientVpnEndpointAttributeStatus_Parse(node: xmlP.XmlNode): s.ClientVpnEndpointAttributeStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientVpnEndpointAttributeStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ClientVpnRoute_Parse(node: xmlP.XmlNode): s.ClientVpnRoute {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    DestinationCidr: node.first("destinationCidr", false, x => x.content ?? ''),
    TargetSubnet: node.first("targetSubnet", false, x => x.content ?? ''),
    Type: node.first("type", false, x => x.content ?? ''),
    Origin: node.first("origin", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnRouteStatus_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

function TargetNetwork_Parse(node: xmlP.XmlNode): s.TargetNetwork {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    TargetNetworkId: node.first("targetNetworkId", false, x => x.content ?? ''),
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Status: node.first("status", false, AssociationStatus_Parse),
    SecurityGroups: node.getList("securityGroups", "item").map(x => x.content ?? ''),
  };
}

function CoipPool_Parse(node: xmlP.XmlNode): s.CoipPool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    PoolCidrs: node.getList("poolCidrSet", "item").map(x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PoolArn: node.first("poolArn", false, x => x.content ?? ''),
  };
}

function ConversionTask_Parse(node: xmlP.XmlNode): s.ConversionTask {
  return {
    ConversionTaskId: node.first("conversionTaskId", false, x => x.content ?? ''),
    ExpirationTime: node.first("expirationTime", false, x => x.content ?? ''),
    ImportInstance: node.first("importInstance", false, ImportInstanceTaskDetails_Parse),
    ImportVolume: node.first("importVolume", false, ImportVolumeTaskDetails_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.ConversionTaskState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ImportInstanceTaskDetails_Parse(node: xmlP.XmlNode): s.ImportInstanceTaskDetails {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => (x.content ?? '') as s.PlatformValues),
    Volumes: node.getList("volumes", "item").map(ImportInstanceVolumeDetailItem_Parse),
  };
}

function ImportInstanceVolumeDetailItem_Parse(node: xmlP.XmlNode): s.ImportInstanceVolumeDetailItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    BytesConverted: node.first("bytesConverted", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Image: node.first("image", false, DiskImageDescription_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Volume: node.first("volume", false, DiskImageVolumeDescription_Parse),
  };
}

function DiskImageDescription_Parse(node: xmlP.XmlNode): s.DiskImageDescription {
  return {
    Checksum: node.first("checksum", false, x => x.content ?? ''),
    Format: node.first("format", false, x => (x.content ?? '') as s.DiskImageFormat),
    ImportManifestUrl: node.first("importManifestUrl", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
  };
}

function DiskImageVolumeDescription_Parse(node: xmlP.XmlNode): s.DiskImageVolumeDescription {
  return {
    Id: node.first("id", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
  };
}

function ImportVolumeTaskDetails_Parse(node: xmlP.XmlNode): s.ImportVolumeTaskDetails {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    BytesConverted: node.first("bytesConverted", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Image: node.first("image", false, DiskImageDescription_Parse),
    Volume: node.first("volume", false, DiskImageVolumeDescription_Parse),
  };
}

function ElasticGpus_Parse(node: xmlP.XmlNode): s.ElasticGpus {
  return {
    ElasticGpuId: node.first("elasticGpuId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    ElasticGpuType: node.first("elasticGpuType", false, x => x.content ?? ''),
    ElasticGpuHealth: node.first("elasticGpuHealth", false, ElasticGpuHealth_Parse),
    ElasticGpuState: node.first("elasticGpuState", false, x => (x.content ?? '') as s.ElasticGpuState),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ElasticGpuHealth_Parse(node: xmlP.XmlNode): s.ElasticGpuHealth {
  return {
    Status: node.first("status", false, x => (x.content ?? '') as s.ElasticGpuStatus),
  };
}

function ExportImageTask_Parse(node: xmlP.XmlNode): s.ExportImageTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ExportImageTaskId: node.first("exportImageTaskId", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    S3ExportLocation: node.first("s3ExportLocation", false, ExportTaskS3Location_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function ExportTaskS3Location_Parse(node: xmlP.XmlNode): s.ExportTaskS3Location {
  return {
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Prefix: node.first("s3Prefix", false, x => x.content ?? ''),
  };
}

function DescribeFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): s.DescribeFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function HistoryRecordEntry_Parse(node: xmlP.XmlNode): s.HistoryRecordEntry {
  return {
    EventInformation: node.first("eventInformation", false, EventInformation_Parse),
    EventType: node.first("eventType", false, x => (x.content ?? '') as s.FleetEventType),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EventInformation_Parse(node: xmlP.XmlNode): s.EventInformation {
  return {
    EventDescription: node.first("eventDescription", false, x => x.content ?? ''),
    EventSubType: node.first("eventSubType", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

function ActiveInstance_Parse(node: xmlP.XmlNode): s.ActiveInstance {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    InstanceHealth: node.first("instanceHealth", false, x => (x.content ?? '') as s.InstanceHealthStatus),
  };
}

function FleetData_Parse(node: xmlP.XmlNode): s.FleetData {
  return {
    ActivityStatus: node.first("activityStatus", false, x => (x.content ?? '') as s.FleetActivityStatus),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
    FleetState: node.first("fleetState", false, x => (x.content ?? '') as s.FleetStateCode),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    ExcessCapacityTerminationPolicy: node.first("excessCapacityTerminationPolicy", false, x => (x.content ?? '') as s.FleetExcessCapacityTerminationPolicy),
    FulfilledCapacity: node.first("fulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    FulfilledOnDemandCapacity: node.first("fulfilledOnDemandCapacity", false, x => parseFloat(x.content ?? '0')),
    LaunchTemplateConfigs: node.getList("launchTemplateConfigs", "item").map(FleetLaunchTemplateConfig_Parse),
    TargetCapacitySpecification: node.first("targetCapacitySpecification", false, TargetCapacitySpecification_Parse),
    TerminateInstancesWithExpiration: node.first("terminateInstancesWithExpiration", false, x => x.content === 'true'),
    Type: node.first("type", false, x => (x.content ?? '') as s.FleetType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    ReplaceUnhealthyInstances: node.first("replaceUnhealthyInstances", false, x => x.content === 'true'),
    SpotOptions: node.first("spotOptions", false, SpotOptions_Parse),
    OnDemandOptions: node.first("onDemandOptions", false, OnDemandOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Errors: node.getList("errorSet", "item").map(DescribeFleetError_Parse),
    Instances: node.getList("fleetInstanceSet", "item").map(DescribeFleetsInstances_Parse),
  };
}

function FleetLaunchTemplateConfig_Parse(node: xmlP.XmlNode): s.FleetLaunchTemplateConfig {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.getList("overrides", "item").map(FleetLaunchTemplateOverrides_Parse),
  };
}

function TargetCapacitySpecification_Parse(node: xmlP.XmlNode): s.TargetCapacitySpecification {
  return {
    TotalTargetCapacity: node.first("totalTargetCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandTargetCapacity: node.first("onDemandTargetCapacity", false, x => parseInt(x.content ?? '0')),
    SpotTargetCapacity: node.first("spotTargetCapacity", false, x => parseInt(x.content ?? '0')),
    DefaultTargetCapacityType: node.first("defaultTargetCapacityType", false, x => (x.content ?? '') as s.DefaultTargetCapacityType),
  };
}

function SpotOptions_Parse(node: xmlP.XmlNode): s.SpotOptions {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as s.SpotAllocationStrategy),
    MaintenanceStrategies: node.first("maintenanceStrategies", false, FleetSpotMaintenanceStrategies_Parse),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as s.SpotInstanceInterruptionBehavior),
    InstancePoolsToUseCount: node.first("instancePoolsToUseCount", false, x => parseInt(x.content ?? '0')),
    SingleInstanceType: node.first("singleInstanceType", false, x => x.content === 'true'),
    SingleAvailabilityZone: node.first("singleAvailabilityZone", false, x => x.content === 'true'),
    MinTargetCapacity: node.first("minTargetCapacity", false, x => parseInt(x.content ?? '0')),
    MaxTotalPrice: node.first("maxTotalPrice", false, x => x.content ?? ''),
  };
}

function FleetSpotMaintenanceStrategies_Parse(node: xmlP.XmlNode): s.FleetSpotMaintenanceStrategies {
  return {
    CapacityRebalance: node.first("capacityRebalance", false, FleetSpotCapacityRebalance_Parse),
  };
}

function FleetSpotCapacityRebalance_Parse(node: xmlP.XmlNode): s.FleetSpotCapacityRebalance {
  return {
    ReplacementStrategy: node.first("replacementStrategy", false, x => (x.content ?? '') as s.FleetReplacementStrategy),
  };
}

function OnDemandOptions_Parse(node: xmlP.XmlNode): s.OnDemandOptions {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as s.FleetOnDemandAllocationStrategy),
    CapacityReservationOptions: node.first("capacityReservationOptions", false, CapacityReservationOptions_Parse),
    SingleInstanceType: node.first("singleInstanceType", false, x => x.content === 'true'),
    SingleAvailabilityZone: node.first("singleAvailabilityZone", false, x => x.content === 'true'),
    MinTargetCapacity: node.first("minTargetCapacity", false, x => parseInt(x.content ?? '0')),
    MaxTotalPrice: node.first("maxTotalPrice", false, x => x.content ?? ''),
  };
}

function CapacityReservationOptions_Parse(node: xmlP.XmlNode): s.CapacityReservationOptions {
  return {
    UsageStrategy: node.first("usageStrategy", false, x => (x.content ?? '') as s.FleetCapacityReservationUsageStrategy),
  };
}

function DescribeFleetError_Parse(node: xmlP.XmlNode): s.DescribeFleetError {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as s.InstanceLifecycle),
    ErrorCode: node.first("errorCode", false, x => x.content ?? ''),
    ErrorMessage: node.first("errorMessage", false, x => x.content ?? ''),
  };
}

function DescribeFleetsInstances_Parse(node: xmlP.XmlNode): s.DescribeFleetsInstances {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as s.InstanceLifecycle),
    InstanceIds: node.getList("instanceIds", "item").map(x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    Platform: node.first("platform", false, x => (x.content ?? '') as s.PlatformValues),
  };
}

function FlowLog_Parse(node: xmlP.XmlNode): s.FlowLog {
  return {
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    DeliverLogsErrorMessage: node.first("deliverLogsErrorMessage", false, x => x.content ?? ''),
    DeliverLogsPermissionArn: node.first("deliverLogsPermissionArn", false, x => x.content ?? ''),
    DeliverLogsStatus: node.first("deliverLogsStatus", false, x => x.content ?? ''),
    FlowLogId: node.first("flowLogId", false, x => x.content ?? ''),
    FlowLogStatus: node.first("flowLogStatus", false, x => x.content ?? ''),
    LogGroupName: node.first("logGroupName", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    TrafficType: node.first("trafficType", false, x => (x.content ?? '') as s.TrafficType),
    LogDestinationType: node.first("logDestinationType", false, x => (x.content ?? '') as s.LogDestinationType),
    LogDestination: node.first("logDestination", false, x => x.content ?? ''),
    LogFormat: node.first("logFormat", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    MaxAggregationInterval: node.first("maxAggregationInterval", false, x => parseInt(x.content ?? '0')),
  };
}

function FpgaImageAttribute_Parse(node: xmlP.XmlNode): s.FpgaImageAttribute {
  return {
    FpgaImageId: node.first("fpgaImageId", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    LoadPermissions: node.getList("loadPermissions", "item").map(LoadPermission_Parse),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
  };
}

function LoadPermission_Parse(node: xmlP.XmlNode): s.LoadPermission {
  return {
    UserId: node.first("userId", false, x => x.content ?? ''),
    Group: node.first("group", false, x => (x.content ?? '') as s.PermissionGroup),
  };
}

function ProductCode_Parse(node: xmlP.XmlNode): s.ProductCode {
  return {
    ProductCodeId: node.first("productCode", false, x => x.content ?? ''),
    ProductCodeType: node.first("type", false, x => (x.content ?? '') as s.ProductCodeValues),
  };
}

function FpgaImage_Parse(node: xmlP.XmlNode): s.FpgaImage {
  return {
    FpgaImageId: node.first("fpgaImageId", false, x => x.content ?? ''),
    FpgaImageGlobalId: node.first("fpgaImageGlobalId", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    ShellVersion: node.first("shellVersion", false, x => x.content ?? ''),
    PciId: node.first("pciId", false, PciId_Parse),
    State: node.first("state", false, FpgaImageState_Parse),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    Tags: node.getList("tags", "item").map(Tag_Parse),
    Public: node.first("public", false, x => x.content === 'true'),
    DataRetentionSupport: node.first("dataRetentionSupport", false, x => x.content === 'true'),
  };
}

function PciId_Parse(node: xmlP.XmlNode): s.PciId {
  return node.strings({
    optional: {"DeviceId":true,"VendorId":true,"SubsystemId":true,"SubsystemVendorId":true},
  });
}

function FpgaImageState_Parse(node: xmlP.XmlNode): s.FpgaImageState {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.FpgaImageStateCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function HostOffering_Parse(node: xmlP.XmlNode): s.HostOffering {
  return {
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as s.PaymentOption),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
  };
}

function HostReservation_Parse(node: xmlP.XmlNode): s.HostReservation {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    End: node.first("end", false, x => xmlP.parseTimestamp(x.content)),
    HostIdSet: node.getList("hostIdSet", "item").map(x => x.content ?? ''),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as s.PaymentOption),
    Start: node.first("start", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as s.ReservationState),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function Host_Parse(node: xmlP.XmlNode): s.Host {
  return {
    AutoPlacement: node.first("autoPlacement", false, x => (x.content ?? '') as s.AutoPlacement),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailableCapacity: node.first("availableCapacity", false, AvailableCapacity_Parse),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    HostProperties: node.first("hostProperties", false, HostProperties_Parse),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    Instances: node.getList("instances", "item").map(HostInstance_Parse),
    State: node.first("state", false, x => (x.content ?? '') as s.AllocationState),
    AllocationTime: node.first("allocationTime", false, x => xmlP.parseTimestamp(x.content)),
    ReleaseTime: node.first("releaseTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    HostRecovery: node.first("hostRecovery", false, x => (x.content ?? '') as s.HostRecovery),
    AllowsMultipleInstanceTypes: node.first("allowsMultipleInstanceTypes", false, x => (x.content ?? '') as s.AllowsMultipleInstanceTypes),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    MemberOfServiceLinkedResourceGroup: node.first("memberOfServiceLinkedResourceGroup", false, x => x.content === 'true'),
  };
}

function AvailableCapacity_Parse(node: xmlP.XmlNode): s.AvailableCapacity {
  return {
    AvailableInstanceCapacity: node.getList("availableInstanceCapacity", "item").map(InstanceCapacity_Parse),
    AvailableVCpus: node.first("availableVCpus", false, x => parseInt(x.content ?? '0')),
  };
}

function InstanceCapacity_Parse(node: xmlP.XmlNode): s.InstanceCapacity {
  return {
    AvailableCapacity: node.first("availableCapacity", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    TotalCapacity: node.first("totalCapacity", false, x => parseInt(x.content ?? '0')),
  };
}

function HostProperties_Parse(node: xmlP.XmlNode): s.HostProperties {
  return {
    Cores: node.first("cores", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    Sockets: node.first("sockets", false, x => parseInt(x.content ?? '0')),
    TotalVCpus: node.first("totalVCpus", false, x => parseInt(x.content ?? '0')),
  };
}

function HostInstance_Parse(node: xmlP.XmlNode): s.HostInstance {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function Image_Parse(node: xmlP.XmlNode): s.Image {
  return {
    Architecture: node.first("architecture", false, x => (x.content ?? '') as s.ArchitectureValues),
    CreationDate: node.first("creationDate", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    ImageLocation: node.first("imageLocation", false, x => x.content ?? ''),
    ImageType: node.first("imageType", false, x => (x.content ?? '') as s.ImageTypeValues),
    Public: node.first("isPublic", false, x => x.content === 'true'),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    OwnerId: node.first("imageOwnerId", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => (x.content ?? '') as s.PlatformValues),
    PlatformDetails: node.first("platformDetails", false, x => x.content ?? ''),
    UsageOperation: node.first("usageOperation", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    State: node.first("imageState", false, x => (x.content ?? '') as s.ImageState),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
    EnaSupport: node.first("enaSupport", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as s.HypervisorType),
    ImageOwnerAlias: node.first("imageOwnerAlias", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    RootDeviceName: node.first("rootDeviceName", false, x => x.content ?? ''),
    RootDeviceType: node.first("rootDeviceType", false, x => (x.content ?? '') as s.DeviceType),
    SriovNetSupport: node.first("sriovNetSupport", false, x => x.content ?? ''),
    StateReason: node.first("stateReason", false, StateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VirtualizationType: node.first("virtualizationType", false, x => (x.content ?? '') as s.VirtualizationType),
  };
}

function StateReason_Parse(node: xmlP.XmlNode): s.StateReason {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ImportImageTask_Parse(node: xmlP.XmlNode): s.ImportImageTask {
  return {
    Architecture: node.first("architecture", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    ImportTaskId: node.first("importTaskId", false, x => x.content ?? ''),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    LicenseType: node.first("licenseType", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotDetails: node.getList("snapshotDetailSet", "item").map(SnapshotDetail_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    LicenseSpecifications: node.getList("licenseSpecifications", "item").map(ImportImageLicenseConfigurationResponse_Parse),
  };
}

function SnapshotDetail_Parse(node: xmlP.XmlNode): s.SnapshotDetail {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    DiskImageSize: node.first("diskImageSize", false, x => parseFloat(x.content ?? '0')),
    Format: node.first("format", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Url: node.first("url", false, x => x.content ?? ''),
    UserBucket: node.first("userBucket", false, UserBucketDetails_Parse),
  };
}

function UserBucketDetails_Parse(node: xmlP.XmlNode): s.UserBucketDetails {
  return {
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Key: node.first("s3Key", false, x => x.content ?? ''),
  };
}

function ImportImageLicenseConfigurationResponse_Parse(node: xmlP.XmlNode): s.ImportImageLicenseConfigurationResponse {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

function ImportSnapshotTask_Parse(node: xmlP.XmlNode): s.ImportSnapshotTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ImportTaskId: node.first("importTaskId", false, x => x.content ?? ''),
    SnapshotTaskDetail: node.first("snapshotTaskDetail", false, SnapshotTaskDetail_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function SnapshotTaskDetail_Parse(node: xmlP.XmlNode): s.SnapshotTaskDetail {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    DiskImageSize: node.first("diskImageSize", false, x => parseFloat(x.content ?? '0')),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    Format: node.first("format", false, x => x.content ?? ''),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Url: node.first("url", false, x => x.content ?? ''),
    UserBucket: node.first("userBucket", false, UserBucketDetails_Parse),
  };
}

function InstanceBlockDeviceMapping_Parse(node: xmlP.XmlNode): s.InstanceBlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, EbsInstanceBlockDevice_Parse),
  };
}

function EbsInstanceBlockDevice_Parse(node: xmlP.XmlNode): s.EbsInstanceBlockDevice {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as s.AttachmentStatus),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
  };
}

function EnclaveOptions_Parse(node: xmlP.XmlNode): s.EnclaveOptions {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

function InstanceCreditSpecification_Parse(node: xmlP.XmlNode): s.InstanceCreditSpecification {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

function InstanceStatus_Parse(node: xmlP.XmlNode): s.InstanceStatus {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Events: node.getList("eventsSet", "item").map(InstanceStatusEvent_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceState: node.first("instanceState", false, InstanceState_Parse),
    InstanceStatus: node.first("instanceStatus", false, InstanceStatusSummary_Parse),
    SystemStatus: node.first("systemStatus", false, InstanceStatusSummary_Parse),
  };
}

function InstanceStatusEvent_Parse(node: xmlP.XmlNode): s.InstanceStatusEvent {
  return {
    InstanceEventId: node.first("instanceEventId", false, x => x.content ?? ''),
    Code: node.first("code", false, x => (x.content ?? '') as s.EventCode),
    Description: node.first("description", false, x => x.content ?? ''),
    NotAfter: node.first("notAfter", false, x => xmlP.parseTimestamp(x.content)),
    NotBefore: node.first("notBefore", false, x => xmlP.parseTimestamp(x.content)),
    NotBeforeDeadline: node.first("notBeforeDeadline", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function InstanceState_Parse(node: xmlP.XmlNode): s.InstanceState {
  return {
    Code: node.first("code", false, x => parseInt(x.content ?? '0')),
    Name: node.first("name", false, x => (x.content ?? '') as s.InstanceStateName),
  };
}

function InstanceStatusSummary_Parse(node: xmlP.XmlNode): s.InstanceStatusSummary {
  return {
    Details: node.getList("details", "item").map(InstanceStatusDetails_Parse),
    Status: node.first("status", false, x => (x.content ?? '') as s.SummaryStatus),
  };
}

function InstanceStatusDetails_Parse(node: xmlP.XmlNode): s.InstanceStatusDetails {
  return {
    ImpairedSince: node.first("impairedSince", false, x => xmlP.parseTimestamp(x.content)),
    Name: node.first("name", false, x => (x.content ?? '') as s.StatusName),
    Status: node.first("status", false, x => (x.content ?? '') as s.StatusType),
  };
}

function InstanceTypeOffering_Parse(node: xmlP.XmlNode): s.InstanceTypeOffering {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    LocationType: node.first("locationType", false, x => (x.content ?? '') as s.LocationType),
    Location: node.first("location", false, x => x.content ?? ''),
  };
}

function InstanceTypeInfo_Parse(node: xmlP.XmlNode): s.InstanceTypeInfo {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    CurrentGeneration: node.first("currentGeneration", false, x => x.content === 'true'),
    FreeTierEligible: node.first("freeTierEligible", false, x => x.content === 'true'),
    SupportedUsageClasses: node.getList("supportedUsageClasses", "item").map(x => (x.content ?? '') as s.UsageClassType),
    SupportedRootDeviceTypes: node.getList("supportedRootDeviceTypes", "item").map(x => (x.content ?? '') as s.RootDeviceType),
    SupportedVirtualizationTypes: node.getList("supportedVirtualizationTypes", "item").map(x => (x.content ?? '') as s.VirtualizationType),
    BareMetal: node.first("bareMetal", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as s.InstanceTypeHypervisor),
    ProcessorInfo: node.first("processorInfo", false, ProcessorInfo_Parse),
    VCpuInfo: node.first("vCpuInfo", false, VCpuInfo_Parse),
    MemoryInfo: node.first("memoryInfo", false, MemoryInfo_Parse),
    InstanceStorageSupported: node.first("instanceStorageSupported", false, x => x.content === 'true'),
    InstanceStorageInfo: node.first("instanceStorageInfo", false, InstanceStorageInfo_Parse),
    EbsInfo: node.first("ebsInfo", false, EbsInfo_Parse),
    NetworkInfo: node.first("networkInfo", false, NetworkInfo_Parse),
    GpuInfo: node.first("gpuInfo", false, GpuInfo_Parse),
    FpgaInfo: node.first("fpgaInfo", false, FpgaInfo_Parse),
    PlacementGroupInfo: node.first("placementGroupInfo", false, PlacementGroupInfo_Parse),
    InferenceAcceleratorInfo: node.first("inferenceAcceleratorInfo", false, InferenceAcceleratorInfo_Parse),
    HibernationSupported: node.first("hibernationSupported", false, x => x.content === 'true'),
    BurstablePerformanceSupported: node.first("burstablePerformanceSupported", false, x => x.content === 'true'),
    DedicatedHostsSupported: node.first("dedicatedHostsSupported", false, x => x.content === 'true'),
    AutoRecoverySupported: node.first("autoRecoverySupported", false, x => x.content === 'true'),
  };
}

function ProcessorInfo_Parse(node: xmlP.XmlNode): s.ProcessorInfo {
  return {
    SupportedArchitectures: node.getList("supportedArchitectures", "item").map(x => (x.content ?? '') as s.ArchitectureType),
    SustainedClockSpeedInGhz: node.first("sustainedClockSpeedInGhz", false, x => parseFloat(x.content ?? '0')),
  };
}

function VCpuInfo_Parse(node: xmlP.XmlNode): s.VCpuInfo {
  return {
    DefaultVCpus: node.first("defaultVCpus", false, x => parseInt(x.content ?? '0')),
    DefaultCores: node.first("defaultCores", false, x => parseInt(x.content ?? '0')),
    DefaultThreadsPerCore: node.first("defaultThreadsPerCore", false, x => parseInt(x.content ?? '0')),
    ValidCores: node.getList("validCores", "item").map(x => parseInt(x.content ?? '0')),
    ValidThreadsPerCore: node.getList("validThreadsPerCore", "item").map(x => parseInt(x.content ?? '0')),
  };
}

function MemoryInfo_Parse(node: xmlP.XmlNode): s.MemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

function InstanceStorageInfo_Parse(node: xmlP.XmlNode): s.InstanceStorageInfo {
  return {
    TotalSizeInGB: node.first("totalSizeInGB", false, x => parseInt(x.content ?? '0')),
    Disks: node.getList("disks", "item").map(DiskInfo_Parse),
    NvmeSupport: node.first("nvmeSupport", false, x => (x.content ?? '') as s.EphemeralNvmeSupport),
  };
}

function DiskInfo_Parse(node: xmlP.XmlNode): s.DiskInfo {
  return {
    SizeInGB: node.first("sizeInGB", false, x => parseInt(x.content ?? '0')),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Type: node.first("type", false, x => (x.content ?? '') as s.DiskType),
  };
}

function EbsInfo_Parse(node: xmlP.XmlNode): s.EbsInfo {
  return {
    EbsOptimizedSupport: node.first("ebsOptimizedSupport", false, x => (x.content ?? '') as s.EbsOptimizedSupport),
    EncryptionSupport: node.first("encryptionSupport", false, x => (x.content ?? '') as s.EbsEncryptionSupport),
    EbsOptimizedInfo: node.first("ebsOptimizedInfo", false, EbsOptimizedInfo_Parse),
    NvmeSupport: node.first("nvmeSupport", false, x => (x.content ?? '') as s.EbsNvmeSupport),
  };
}

function EbsOptimizedInfo_Parse(node: xmlP.XmlNode): s.EbsOptimizedInfo {
  return {
    BaselineBandwidthInMbps: node.first("baselineBandwidthInMbps", false, x => parseInt(x.content ?? '0')),
    BaselineThroughputInMBps: node.first("baselineThroughputInMBps", false, x => parseFloat(x.content ?? '0')),
    BaselineIops: node.first("baselineIops", false, x => parseInt(x.content ?? '0')),
    MaximumBandwidthInMbps: node.first("maximumBandwidthInMbps", false, x => parseInt(x.content ?? '0')),
    MaximumThroughputInMBps: node.first("maximumThroughputInMBps", false, x => parseFloat(x.content ?? '0')),
    MaximumIops: node.first("maximumIops", false, x => parseInt(x.content ?? '0')),
  };
}

function NetworkInfo_Parse(node: xmlP.XmlNode): s.NetworkInfo {
  return {
    NetworkPerformance: node.first("networkPerformance", false, x => x.content ?? ''),
    MaximumNetworkInterfaces: node.first("maximumNetworkInterfaces", false, x => parseInt(x.content ?? '0')),
    MaximumNetworkCards: node.first("maximumNetworkCards", false, x => parseInt(x.content ?? '0')),
    DefaultNetworkCardIndex: node.first("defaultNetworkCardIndex", false, x => parseInt(x.content ?? '0')),
    NetworkCards: node.getList("networkCards", "item").map(NetworkCardInfo_Parse),
    Ipv4AddressesPerInterface: node.first("ipv4AddressesPerInterface", false, x => parseInt(x.content ?? '0')),
    Ipv6AddressesPerInterface: node.first("ipv6AddressesPerInterface", false, x => parseInt(x.content ?? '0')),
    Ipv6Supported: node.first("ipv6Supported", false, x => x.content === 'true'),
    EnaSupport: node.first("enaSupport", false, x => (x.content ?? '') as s.EnaSupport),
    EfaSupported: node.first("efaSupported", false, x => x.content === 'true'),
  };
}

function NetworkCardInfo_Parse(node: xmlP.XmlNode): s.NetworkCardInfo {
  return {
    NetworkCardIndex: node.first("networkCardIndex", false, x => parseInt(x.content ?? '0')),
    NetworkPerformance: node.first("networkPerformance", false, x => x.content ?? ''),
    MaximumNetworkInterfaces: node.first("maximumNetworkInterfaces", false, x => parseInt(x.content ?? '0')),
  };
}

function GpuInfo_Parse(node: xmlP.XmlNode): s.GpuInfo {
  return {
    Gpus: node.getList("gpus", "item").map(GpuDeviceInfo_Parse),
    TotalGpuMemoryInMiB: node.first("totalGpuMemoryInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

function GpuDeviceInfo_Parse(node: xmlP.XmlNode): s.GpuDeviceInfo {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    MemoryInfo: node.first("memoryInfo", false, GpuDeviceMemoryInfo_Parse),
  };
}

function GpuDeviceMemoryInfo_Parse(node: xmlP.XmlNode): s.GpuDeviceMemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

function FpgaInfo_Parse(node: xmlP.XmlNode): s.FpgaInfo {
  return {
    Fpgas: node.getList("fpgas", "item").map(FpgaDeviceInfo_Parse),
    TotalFpgaMemoryInMiB: node.first("totalFpgaMemoryInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

function FpgaDeviceInfo_Parse(node: xmlP.XmlNode): s.FpgaDeviceInfo {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    MemoryInfo: node.first("memoryInfo", false, FpgaDeviceMemoryInfo_Parse),
  };
}

function FpgaDeviceMemoryInfo_Parse(node: xmlP.XmlNode): s.FpgaDeviceMemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

function PlacementGroupInfo_Parse(node: xmlP.XmlNode): s.PlacementGroupInfo {
  return {
    SupportedStrategies: node.getList("supportedStrategies", "item").map(x => (x.content ?? '') as s.PlacementGroupStrategy),
  };
}

function InferenceAcceleratorInfo_Parse(node: xmlP.XmlNode): s.InferenceAcceleratorInfo {
  return {
    Accelerators: node.getList("accelerators", "item").map(InferenceDeviceInfo_Parse),
  };
}

function InferenceDeviceInfo_Parse(node: xmlP.XmlNode): s.InferenceDeviceInfo {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
  };
}

function Instance_Parse(node: xmlP.XmlNode): s.Instance {
  return {
    AmiLaunchIndex: node.first("amiLaunchIndex", false, x => parseInt(x.content ?? '0')),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    LaunchTime: node.first("launchTime", false, x => xmlP.parseTimestamp(x.content)),
    Monitoring: node.first("monitoring", false, Monitoring_Parse),
    Placement: node.first("placement", false, Placement_Parse),
    Platform: node.first("platform", false, x => (x.content ?? '') as s.PlatformValues),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    PublicDnsName: node.first("dnsName", false, x => x.content ?? ''),
    PublicIpAddress: node.first("ipAddress", false, x => x.content ?? ''),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    State: node.first("instanceState", false, InstanceState_Parse),
    StateTransitionReason: node.first("reason", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Architecture: node.first("architecture", false, x => (x.content ?? '') as s.ArchitectureValues),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(InstanceBlockDeviceMapping_Parse),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    EnaSupport: node.first("enaSupport", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as s.HypervisorType),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfile_Parse),
    InstanceLifecycle: node.first("instanceLifecycle", false, x => (x.content ?? '') as s.InstanceLifecycleType),
    ElasticGpuAssociations: node.getList("elasticGpuAssociationSet", "item").map(ElasticGpuAssociation_Parse),
    ElasticInferenceAcceleratorAssociations: node.getList("elasticInferenceAcceleratorAssociationSet", "item").map(ElasticInferenceAcceleratorAssociation_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterface_Parse),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    RootDeviceName: node.first("rootDeviceName", false, x => x.content ?? ''),
    RootDeviceType: node.first("rootDeviceType", false, x => (x.content ?? '') as s.DeviceType),
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    SriovNetSupport: node.first("sriovNetSupport", false, x => x.content ?? ''),
    StateReason: node.first("stateReason", false, StateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VirtualizationType: node.first("virtualizationType", false, x => (x.content ?? '') as s.VirtualizationType),
    CpuOptions: node.first("cpuOptions", false, CpuOptions_Parse),
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    CapacityReservationSpecification: node.first("capacityReservationSpecification", false, CapacityReservationSpecificationResponse_Parse),
    HibernationOptions: node.first("hibernationOptions", false, HibernationOptions_Parse),
    Licenses: node.getList("licenseSet", "item").map(LicenseConfiguration_Parse),
    MetadataOptions: node.first("metadataOptions", false, InstanceMetadataOptionsResponse_Parse),
    EnclaveOptions: node.first("enclaveOptions", false, EnclaveOptions_Parse),
  };
}

function Monitoring_Parse(node: xmlP.XmlNode): s.Monitoring {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.MonitoringState),
  };
}

function ElasticGpuAssociation_Parse(node: xmlP.XmlNode): s.ElasticGpuAssociation {
  return {
    ElasticGpuId: node.first("elasticGpuId", false, x => x.content ?? ''),
    ElasticGpuAssociationId: node.first("elasticGpuAssociationId", false, x => x.content ?? ''),
    ElasticGpuAssociationState: node.first("elasticGpuAssociationState", false, x => x.content ?? ''),
    ElasticGpuAssociationTime: node.first("elasticGpuAssociationTime", false, x => x.content ?? ''),
  };
}

function ElasticInferenceAcceleratorAssociation_Parse(node: xmlP.XmlNode): s.ElasticInferenceAcceleratorAssociation {
  return {
    ElasticInferenceAcceleratorArn: node.first("elasticInferenceAcceleratorArn", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationId: node.first("elasticInferenceAcceleratorAssociationId", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationState: node.first("elasticInferenceAcceleratorAssociationState", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationTime: node.first("elasticInferenceAcceleratorAssociationTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function InstanceNetworkInterface_Parse(node: xmlP.XmlNode): s.InstanceNetworkInterface {
  return {
    Association: node.first("association", false, InstanceNetworkInterfaceAssociation_Parse),
    Attachment: node.first("attachment", false, InstanceNetworkInterfaceAttachment_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(InstanceIpv6Address_Parse),
    MacAddress: node.first("macAddress", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(InstancePrivateIpAddress_Parse),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as s.NetworkInterfaceStatus),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    InterfaceType: node.first("interfaceType", false, x => x.content ?? ''),
  };
}

function InstanceNetworkInterfaceAssociation_Parse(node: xmlP.XmlNode): s.InstanceNetworkInterfaceAssociation {
  return {
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
    IpOwnerId: node.first("ipOwnerId", false, x => x.content ?? ''),
    PublicDnsName: node.first("publicDnsName", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

function InstanceNetworkInterfaceAttachment_Parse(node: xmlP.XmlNode): s.InstanceNetworkInterfaceAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    AttachmentId: node.first("attachmentId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Status: node.first("status", false, x => (x.content ?? '') as s.AttachmentStatus),
    NetworkCardIndex: node.first("networkCardIndex", false, x => parseInt(x.content ?? '0')),
  };
}

function InstancePrivateIpAddress_Parse(node: xmlP.XmlNode): s.InstancePrivateIpAddress {
  return {
    Association: node.first("association", false, InstanceNetworkInterfaceAssociation_Parse),
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

function CpuOptions_Parse(node: xmlP.XmlNode): s.CpuOptions {
  return {
    CoreCount: node.first("coreCount", false, x => parseInt(x.content ?? '0')),
    ThreadsPerCore: node.first("threadsPerCore", false, x => parseInt(x.content ?? '0')),
  };
}

function CapacityReservationSpecificationResponse_Parse(node: xmlP.XmlNode): s.CapacityReservationSpecificationResponse {
  return {
    CapacityReservationPreference: node.first("capacityReservationPreference", false, x => (x.content ?? '') as s.CapacityReservationPreference),
    CapacityReservationTarget: node.first("capacityReservationTarget", false, CapacityReservationTargetResponse_Parse),
  };
}

function HibernationOptions_Parse(node: xmlP.XmlNode): s.HibernationOptions {
  return {
    Configured: node.first("configured", false, x => x.content === 'true'),
  };
}

function LicenseConfiguration_Parse(node: xmlP.XmlNode): s.LicenseConfiguration {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

function InstanceMetadataOptionsResponse_Parse(node: xmlP.XmlNode): s.InstanceMetadataOptionsResponse {
  return {
    State: node.first("state", false, x => (x.content ?? '') as s.InstanceMetadataOptionsState),
    HttpTokens: node.first("httpTokens", false, x => (x.content ?? '') as s.HttpTokensState),
    HttpPutResponseHopLimit: node.first("httpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("httpEndpoint", false, x => (x.content ?? '') as s.InstanceMetadataEndpointState),
  };
}

function Ipv6Pool_Parse(node: xmlP.XmlNode): s.Ipv6Pool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    PoolCidrBlocks: node.getList("poolCidrBlockSet", "item").map(PoolCidrBlock_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function PoolCidrBlock_Parse(node: xmlP.XmlNode): s.PoolCidrBlock {
  return {
    Cidr: node.first("poolCidrBlock", false, x => x.content ?? ''),
  };
}

function KeyPairInfo_Parse(node: xmlP.XmlNode): s.KeyPairInfo {
  return {
    KeyPairId: node.first("keyPairId", false, x => x.content ?? ''),
    KeyFingerprint: node.first("keyFingerprint", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LocalGatewayRouteTableVirtualInterfaceGroupAssociation_Parse(node: xmlP.XmlNode): s.LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
  return {
    LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: node.first("localGatewayRouteTableVirtualInterfaceGroupAssociationId", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LocalGatewayRouteTable_Parse(node: xmlP.XmlNode): s.LocalGatewayRouteTable {
  return {
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LocalGatewayVirtualInterfaceGroup_Parse(node: xmlP.XmlNode): s.LocalGatewayVirtualInterfaceGroup {
  return {
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceIds: node.getList("localGatewayVirtualInterfaceIdSet", "item").map(x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LocalGatewayVirtualInterface_Parse(node: xmlP.XmlNode): s.LocalGatewayVirtualInterface {
  return {
    LocalGatewayVirtualInterfaceId: node.first("localGatewayVirtualInterfaceId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    Vlan: node.first("vlan", false, x => parseInt(x.content ?? '0')),
    LocalAddress: node.first("localAddress", false, x => x.content ?? ''),
    PeerAddress: node.first("peerAddress", false, x => x.content ?? ''),
    LocalBgpAsn: node.first("localBgpAsn", false, x => parseInt(x.content ?? '0')),
    PeerBgpAsn: node.first("peerBgpAsn", false, x => parseInt(x.content ?? '0')),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function LocalGateway_Parse(node: xmlP.XmlNode): s.LocalGateway {
  return {
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function MovingAddressStatus_Parse(node: xmlP.XmlNode): s.MovingAddressStatus {
  return {
    MoveStatus: node.first("moveStatus", false, x => (x.content ?? '') as s.MoveStatus),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

function NetworkInsightsAnalysis_Parse(node: xmlP.XmlNode): s.NetworkInsightsAnalysis {
  return {
    NetworkInsightsAnalysisId: node.first("networkInsightsAnalysisId", false, x => x.content ?? ''),
    NetworkInsightsAnalysisArn: node.first("networkInsightsAnalysisArn", false, x => x.content ?? ''),
    NetworkInsightsPathId: node.first("networkInsightsPathId", false, x => x.content ?? ''),
    FilterInArns: node.getList("filterInArnSet", "item").map(x => x.content ?? ''),
    StartDate: node.first("startDate", false, x => xmlP.parseTimestamp(x.content)),
    Status: node.first("status", false, x => (x.content ?? '') as s.AnalysisStatus),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    NetworkPathFound: node.first("networkPathFound", false, x => x.content === 'true'),
    ForwardPathComponents: node.getList("forwardPathComponentSet", "item").map(PathComponent_Parse),
    ReturnPathComponents: node.getList("returnPathComponentSet", "item").map(PathComponent_Parse),
    Explanations: node.getList("explanationSet", "item").map(Explanation_Parse),
    AlternatePathHints: node.getList("alternatePathHintSet", "item").map(AlternatePathHint_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function PathComponent_Parse(node: xmlP.XmlNode): s.PathComponent {
  return {
    SequenceNumber: node.first("sequenceNumber", false, x => parseInt(x.content ?? '0')),
    AclRule: node.first("aclRule", false, AnalysisAclRule_Parse),
    Component: node.first("component", false, AnalysisComponent_Parse),
    DestinationVpc: node.first("destinationVpc", false, AnalysisComponent_Parse),
    OutboundHeader: node.first("outboundHeader", false, AnalysisPacketHeader_Parse),
    InboundHeader: node.first("inboundHeader", false, AnalysisPacketHeader_Parse),
    RouteTableRoute: node.first("routeTableRoute", false, AnalysisRouteTableRoute_Parse),
    SecurityGroupRule: node.first("securityGroupRule", false, AnalysisSecurityGroupRule_Parse),
    SourceVpc: node.first("sourceVpc", false, AnalysisComponent_Parse),
    Subnet: node.first("subnet", false, AnalysisComponent_Parse),
    Vpc: node.first("vpc", false, AnalysisComponent_Parse),
  };
}

function AnalysisAclRule_Parse(node: xmlP.XmlNode): s.AnalysisAclRule {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Egress: node.first("egress", false, x => x.content === 'true'),
    PortRange: node.first("portRange", false, PortRange_Parse),
    Protocol: node.first("protocol", false, x => x.content ?? ''),
    RuleAction: node.first("ruleAction", false, x => x.content ?? ''),
    RuleNumber: node.first("ruleNumber", false, x => parseInt(x.content ?? '0')),
  };
}

function AnalysisComponent_Parse(node: xmlP.XmlNode): s.AnalysisComponent {
  return {
    Id: node.first("id", false, x => x.content ?? ''),
    Arn: node.first("arn", false, x => x.content ?? ''),
  };
}

function AnalysisPacketHeader_Parse(node: xmlP.XmlNode): s.AnalysisPacketHeader {
  return {
    DestinationAddresses: node.getList("destinationAddressSet", "item").map(x => x.content ?? ''),
    DestinationPortRanges: node.getList("destinationPortRangeSet", "item").map(PortRange_Parse),
    Protocol: node.first("protocol", false, x => x.content ?? ''),
    SourceAddresses: node.getList("sourceAddressSet", "item").map(x => x.content ?? ''),
    SourcePortRanges: node.getList("sourcePortRangeSet", "item").map(PortRange_Parse),
  };
}

function AnalysisRouteTableRoute_Parse(node: xmlP.XmlNode): s.AnalysisRouteTableRoute {
  return {
    DestinationCidr: node.first("destinationCidr", false, x => x.content ?? ''),
    DestinationPrefixListId: node.first("destinationPrefixListId", false, x => x.content ?? ''),
    EgressOnlyInternetGatewayId: node.first("egressOnlyInternetGatewayId", false, x => x.content ?? ''),
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    NatGatewayId: node.first("natGatewayId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    Origin: node.first("origin", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

function AnalysisSecurityGroupRule_Parse(node: xmlP.XmlNode): s.AnalysisSecurityGroupRule {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Direction: node.first("direction", false, x => x.content ?? ''),
    SecurityGroupId: node.first("securityGroupId", false, x => x.content ?? ''),
    PortRange: node.first("portRange", false, PortRange_Parse),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    Protocol: node.first("protocol", false, x => x.content ?? ''),
  };
}

function Explanation_Parse(node: xmlP.XmlNode): s.Explanation {
  return {
    Acl: node.first("acl", false, AnalysisComponent_Parse),
    AclRule: node.first("aclRule", false, AnalysisAclRule_Parse),
    Address: node.first("address", false, x => x.content ?? ''),
    Addresses: node.getList("addressSet", "item").map(x => x.content ?? ''),
    AttachedTo: node.first("attachedTo", false, AnalysisComponent_Parse),
    AvailabilityZones: node.getList("availabilityZoneSet", "item").map(x => x.content ?? ''),
    Cidrs: node.getList("cidrSet", "item").map(x => x.content ?? ''),
    Component: node.first("component", false, AnalysisComponent_Parse),
    CustomerGateway: node.first("customerGateway", false, AnalysisComponent_Parse),
    Destination: node.first("destination", false, AnalysisComponent_Parse),
    DestinationVpc: node.first("destinationVpc", false, AnalysisComponent_Parse),
    Direction: node.first("direction", false, x => x.content ?? ''),
    ExplanationCode: node.first("explanationCode", false, x => x.content ?? ''),
    IngressRouteTable: node.first("ingressRouteTable", false, AnalysisComponent_Parse),
    InternetGateway: node.first("internetGateway", false, AnalysisComponent_Parse),
    LoadBalancerArn: node.first("loadBalancerArn", false, x => x.content ?? ''),
    ClassicLoadBalancerListener: node.first("classicLoadBalancerListener", false, AnalysisLoadBalancerListener_Parse),
    LoadBalancerListenerPort: node.first("loadBalancerListenerPort", false, x => parseInt(x.content ?? '0')),
    LoadBalancerTarget: node.first("loadBalancerTarget", false, AnalysisLoadBalancerTarget_Parse),
    LoadBalancerTargetGroup: node.first("loadBalancerTargetGroup", false, AnalysisComponent_Parse),
    LoadBalancerTargetGroups: node.getList("loadBalancerTargetGroupSet", "item").map(AnalysisComponent_Parse),
    LoadBalancerTargetPort: node.first("loadBalancerTargetPort", false, x => parseInt(x.content ?? '0')),
    ElasticLoadBalancerListener: node.first("elasticLoadBalancerListener", false, AnalysisComponent_Parse),
    MissingComponent: node.first("missingComponent", false, x => x.content ?? ''),
    NatGateway: node.first("natGateway", false, AnalysisComponent_Parse),
    NetworkInterface: node.first("networkInterface", false, AnalysisComponent_Parse),
    PacketField: node.first("packetField", false, x => x.content ?? ''),
    VpcPeeringConnection: node.first("vpcPeeringConnection", false, AnalysisComponent_Parse),
    Port: node.first("port", false, x => parseInt(x.content ?? '0')),
    PortRanges: node.getList("portRangeSet", "item").map(PortRange_Parse),
    PrefixList: node.first("prefixList", false, AnalysisComponent_Parse),
    Protocols: node.getList("protocolSet", "item").map(x => x.content ?? ''),
    RouteTableRoute: node.first("routeTableRoute", false, AnalysisRouteTableRoute_Parse),
    RouteTable: node.first("routeTable", false, AnalysisComponent_Parse),
    SecurityGroup: node.first("securityGroup", false, AnalysisComponent_Parse),
    SecurityGroupRule: node.first("securityGroupRule", false, AnalysisSecurityGroupRule_Parse),
    SecurityGroups: node.getList("securityGroupSet", "item").map(AnalysisComponent_Parse),
    SourceVpc: node.first("sourceVpc", false, AnalysisComponent_Parse),
    State: node.first("state", false, x => x.content ?? ''),
    Subnet: node.first("subnet", false, AnalysisComponent_Parse),
    SubnetRouteTable: node.first("subnetRouteTable", false, AnalysisComponent_Parse),
    Vpc: node.first("vpc", false, AnalysisComponent_Parse),
    VpcEndpoint: node.first("vpcEndpoint", false, AnalysisComponent_Parse),
    VpnConnection: node.first("vpnConnection", false, AnalysisComponent_Parse),
    VpnGateway: node.first("vpnGateway", false, AnalysisComponent_Parse),
  };
}

function AnalysisLoadBalancerListener_Parse(node: xmlP.XmlNode): s.AnalysisLoadBalancerListener {
  return {
    LoadBalancerPort: node.first("loadBalancerPort", false, x => parseInt(x.content ?? '0')),
    InstancePort: node.first("instancePort", false, x => parseInt(x.content ?? '0')),
  };
}

function AnalysisLoadBalancerTarget_Parse(node: xmlP.XmlNode): s.AnalysisLoadBalancerTarget {
  return {
    Address: node.first("address", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Instance: node.first("instance", false, AnalysisComponent_Parse),
    Port: node.first("port", false, x => parseInt(x.content ?? '0')),
  };
}

function AlternatePathHint_Parse(node: xmlP.XmlNode): s.AlternatePathHint {
  return {
    ComponentId: node.first("componentId", false, x => x.content ?? ''),
    ComponentArn: node.first("componentArn", false, x => x.content ?? ''),
  };
}

function PrefixList_Parse(node: xmlP.XmlNode): s.PrefixList {
  return {
    Cidrs: node.getList("cidrSet", "item").map(x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    PrefixListName: node.first("prefixListName", false, x => x.content ?? ''),
  };
}

function PrincipalIdFormat_Parse(node: xmlP.XmlNode): s.PrincipalIdFormat {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Statuses: node.getList("statusSet", "item").map(IdFormat_Parse),
  };
}

function PublicIpv4Pool_Parse(node: xmlP.XmlNode): s.PublicIpv4Pool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    PoolAddressRanges: node.getList("poolAddressRangeSet", "item").map(PublicIpv4PoolRange_Parse),
    TotalAddressCount: node.first("totalAddressCount", false, x => parseInt(x.content ?? '0')),
    TotalAvailableAddressCount: node.first("totalAvailableAddressCount", false, x => parseInt(x.content ?? '0')),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function PublicIpv4PoolRange_Parse(node: xmlP.XmlNode): s.PublicIpv4PoolRange {
  return {
    FirstAddress: node.first("firstAddress", false, x => x.content ?? ''),
    LastAddress: node.first("lastAddress", false, x => x.content ?? ''),
    AddressCount: node.first("addressCount", false, x => parseInt(x.content ?? '0')),
    AvailableAddressCount: node.first("availableAddressCount", false, x => parseInt(x.content ?? '0')),
  };
}

function Region_Parse(node: xmlP.XmlNode): s.Region {
  return {
    Endpoint: node.first("regionEndpoint", false, x => x.content ?? ''),
    RegionName: node.first("regionName", false, x => x.content ?? ''),
    OptInStatus: node.first("optInStatus", false, x => x.content ?? ''),
  };
}

function ReservedInstances_Parse(node: xmlP.XmlNode): s.ReservedInstances {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    End: node.first("end", false, x => xmlP.parseTimestamp(x.content)),
    FixedPrice: node.first("fixedPrice", false, x => parseFloat(x.content ?? '0')),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as s.RIProductDescription),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    Start: node.first("start", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as s.ReservedInstanceState),
    UsagePrice: node.first("usagePrice", false, x => parseFloat(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as s.Tenancy),
    OfferingClass: node.first("offeringClass", false, x => (x.content ?? '') as s.OfferingClassType),
    OfferingType: node.first("offeringType", false, x => (x.content ?? '') as s.OfferingTypeValues),
    RecurringCharges: node.getList("recurringCharges", "item").map(RecurringCharge_Parse),
    Scope: node.first("scope", false, x => (x.content ?? '') as s.scope),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function RecurringCharge_Parse(node: xmlP.XmlNode): s.RecurringCharge {
  return {
    Amount: node.first("amount", false, x => parseFloat(x.content ?? '0')),
    Frequency: node.first("frequency", false, x => (x.content ?? '') as s.RecurringChargeFrequency),
  };
}

function ReservedInstancesModification_Parse(node: xmlP.XmlNode): s.ReservedInstancesModification {
  return {
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    EffectiveDate: node.first("effectiveDate", false, x => xmlP.parseTimestamp(x.content)),
    ModificationResults: node.getList("modificationResultSet", "item").map(ReservedInstancesModificationResult_Parse),
    ReservedInstancesIds: node.getList("reservedInstancesSet", "item").map(ReservedInstancesId_Parse),
    ReservedInstancesModificationId: node.first("reservedInstancesModificationId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    UpdateDate: node.first("updateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ReservedInstancesModificationResult_Parse(node: xmlP.XmlNode): s.ReservedInstancesModificationResult {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    TargetConfiguration: node.first("targetConfiguration", false, ReservedInstancesConfiguration_Parse),
  };
}

function ReservedInstancesId_Parse(node: xmlP.XmlNode): s.ReservedInstancesId {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

function ReservedInstancesOffering_Parse(node: xmlP.XmlNode): s.ReservedInstancesOffering {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("fixedPrice", false, x => parseFloat(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as s.RIProductDescription),
    ReservedInstancesOfferingId: node.first("reservedInstancesOfferingId", false, x => x.content ?? ''),
    UsagePrice: node.first("usagePrice", false, x => parseFloat(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as s.Tenancy),
    Marketplace: node.first("marketplace", false, x => x.content === 'true'),
    OfferingClass: node.first("offeringClass", false, x => (x.content ?? '') as s.OfferingClassType),
    OfferingType: node.first("offeringType", false, x => (x.content ?? '') as s.OfferingTypeValues),
    PricingDetails: node.getList("pricingDetailsSet", "item").map(PricingDetail_Parse),
    RecurringCharges: node.getList("recurringCharges", "item").map(RecurringCharge_Parse),
    Scope: node.first("scope", false, x => (x.content ?? '') as s.scope),
  };
}

function PricingDetail_Parse(node: xmlP.XmlNode): s.PricingDetail {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Price: node.first("price", false, x => parseFloat(x.content ?? '0')),
  };
}

function ScheduledInstanceAvailability_Parse(node: xmlP.XmlNode): s.ScheduledInstanceAvailability {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailableInstanceCount: node.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
    FirstSlotStartTime: node.first("firstSlotStartTime", false, x => xmlP.parseTimestamp(x.content)),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    MaxTermDurationInDays: node.first("maxTermDurationInDays", false, x => parseInt(x.content ?? '0')),
    MinTermDurationInDays: node.first("minTermDurationInDays", false, x => parseInt(x.content ?? '0')),
    NetworkPlatform: node.first("networkPlatform", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => x.content ?? ''),
    PurchaseToken: node.first("purchaseToken", false, x => x.content ?? ''),
    Recurrence: node.first("recurrence", false, ScheduledInstanceRecurrence_Parse),
    SlotDurationInHours: node.first("slotDurationInHours", false, x => parseInt(x.content ?? '0')),
    TotalScheduledInstanceHours: node.first("totalScheduledInstanceHours", false, x => parseInt(x.content ?? '0')),
  };
}

function ScheduledInstanceRecurrence_Parse(node: xmlP.XmlNode): s.ScheduledInstanceRecurrence {
  return {
    Frequency: node.first("frequency", false, x => x.content ?? ''),
    Interval: node.first("interval", false, x => parseInt(x.content ?? '0')),
    OccurrenceDaySet: node.getList("occurrenceDaySet", "item").map(x => parseInt(x.content ?? '0')),
    OccurrenceRelativeToEnd: node.first("occurrenceRelativeToEnd", false, x => x.content === 'true'),
    OccurrenceUnit: node.first("occurrenceUnit", false, x => x.content ?? ''),
  };
}

function ScheduledInstance_Parse(node: xmlP.XmlNode): s.ScheduledInstance {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    NetworkPlatform: node.first("networkPlatform", false, x => x.content ?? ''),
    NextSlotStartTime: node.first("nextSlotStartTime", false, x => xmlP.parseTimestamp(x.content)),
    Platform: node.first("platform", false, x => x.content ?? ''),
    PreviousSlotEndTime: node.first("previousSlotEndTime", false, x => xmlP.parseTimestamp(x.content)),
    Recurrence: node.first("recurrence", false, ScheduledInstanceRecurrence_Parse),
    ScheduledInstanceId: node.first("scheduledInstanceId", false, x => x.content ?? ''),
    SlotDurationInHours: node.first("slotDurationInHours", false, x => parseInt(x.content ?? '0')),
    TermEndDate: node.first("termEndDate", false, x => xmlP.parseTimestamp(x.content)),
    TermStartDate: node.first("termStartDate", false, x => xmlP.parseTimestamp(x.content)),
    TotalScheduledInstanceHours: node.first("totalScheduledInstanceHours", false, x => parseInt(x.content ?? '0')),
  };
}

function SecurityGroupReference_Parse(node: xmlP.XmlNode): s.SecurityGroupReference {
  return {
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    ReferencingVpcId: node.first("referencingVpcId", false, x => x.content ?? ''),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

function SecurityGroup_Parse(node: xmlP.XmlNode): s.SecurityGroup {
  return {
    Description: node.first("groupDescription", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    IpPermissions: node.getList("ipPermissions", "item").map(IpPermission_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    IpPermissionsEgress: node.getList("ipPermissionsEgress", "item").map(IpPermission_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function HistoryRecord_Parse(node: xmlP.XmlNode): s.HistoryRecord {
  return {
    EventInformation: node.first("eventInformation", false, EventInformation_Parse),
    EventType: node.first("eventType", false, x => (x.content ?? '') as s.EventType),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function SpotFleetRequestConfig_Parse(node: xmlP.XmlNode): s.SpotFleetRequestConfig {
  return {
    ActivityStatus: node.first("activityStatus", false, x => (x.content ?? '') as s.ActivityStatus),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    SpotFleetRequestConfig: node.first("spotFleetRequestConfig", false, SpotFleetRequestConfigData_Parse),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
    SpotFleetRequestState: node.first("spotFleetRequestState", false, x => (x.content ?? '') as s.BatchState),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function SpotInstanceRequest_Parse(node: xmlP.XmlNode): s.SpotInstanceRequest {
  return {
    ActualBlockHourlyPrice: node.first("actualBlockHourlyPrice", false, x => x.content ?? ''),
    AvailabilityZoneGroup: node.first("availabilityZoneGroup", false, x => x.content ?? ''),
    BlockDurationMinutes: node.first("blockDurationMinutes", false, x => parseInt(x.content ?? '0')),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    Fault: node.first("fault", false, SpotInstanceStateFault_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    LaunchGroup: node.first("launchGroup", false, x => x.content ?? ''),
    LaunchSpecification: node.first("launchSpecification", false, LaunchSpecification_Parse),
    LaunchedAvailabilityZone: node.first("launchedAvailabilityZone", false, x => x.content ?? ''),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as s.RIProductDescription),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.SpotInstanceState),
    Status: node.first("status", false, SpotInstanceStatus_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Type: node.first("type", false, x => (x.content ?? '') as s.SpotInstanceType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as s.InstanceInterruptionBehavior),
  };
}

function LaunchSpecification_Parse(node: xmlP.XmlNode): s.LaunchSpecification {
  return {
    UserData: node.first("userData", false, x => x.content ?? ''),
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    AddressingType: node.first("addressingType", false, x => x.content ?? ''),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfileSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterfaceSpecification_Parse),
    Placement: node.first("placement", false, SpotPlacement_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, RunInstancesMonitoringEnabled_Parse),
  };
}

function SpotInstanceStatus_Parse(node: xmlP.XmlNode): s.SpotInstanceStatus {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function SpotPrice_Parse(node: xmlP.XmlNode): s.SpotPrice {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as s.InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as s.RIProductDescription),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StaleSecurityGroup_Parse(node: xmlP.XmlNode): s.StaleSecurityGroup {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    StaleIpPermissions: node.getList("staleIpPermissions", "item").map(StaleIpPermission_Parse),
    StaleIpPermissionsEgress: node.getList("staleIpPermissionsEgress", "item").map(StaleIpPermission_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function StaleIpPermission_Parse(node: xmlP.XmlNode): s.StaleIpPermission {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    IpProtocol: node.first("ipProtocol", false, x => x.content ?? ''),
    IpRanges: node.getList("ipRanges", "item").map(x => x.content ?? ''),
    PrefixListIds: node.getList("prefixListIds", "item").map(x => x.content ?? ''),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
    UserIdGroupPairs: node.getList("groups", "item").map(UserIdGroupPair_Parse),
  };
}

function TagDescription_Parse(node: xmlP.XmlNode): s.TagDescription {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.ResourceType),
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

function TransitGatewayAttachment_Parse(node: xmlP.XmlNode): s.TransitGatewayAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    TransitGatewayOwnerId: node.first("transitGatewayOwnerId", false, x => x.content ?? ''),
    ResourceOwnerId: node.first("resourceOwnerId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAttachmentState),
    Association: node.first("association", false, TransitGatewayAttachmentAssociation_Parse),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

function TransitGatewayAttachmentAssociation_Parse(node: xmlP.XmlNode): s.TransitGatewayAttachmentAssociation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAssociationState),
  };
}

function VolumeStatusItem_Parse(node: xmlP.XmlNode): s.VolumeStatusItem {
  return {
    Actions: node.getList("actionsSet", "item").map(VolumeStatusAction_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Events: node.getList("eventsSet", "item").map(VolumeStatusEvent_Parse),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    VolumeStatus: node.first("volumeStatus", false, VolumeStatusInfo_Parse),
    AttachmentStatuses: node.getList("attachmentStatuses", "item").map(VolumeStatusAttachmentStatus_Parse),
  };
}

function VolumeStatusAction_Parse(node: xmlP.XmlNode): s.VolumeStatusAction {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    EventId: node.first("eventId", false, x => x.content ?? ''),
    EventType: node.first("eventType", false, x => x.content ?? ''),
  };
}

function VolumeStatusEvent_Parse(node: xmlP.XmlNode): s.VolumeStatusEvent {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    EventId: node.first("eventId", false, x => x.content ?? ''),
    EventType: node.first("eventType", false, x => x.content ?? ''),
    NotAfter: node.first("notAfter", false, x => xmlP.parseTimestamp(x.content)),
    NotBefore: node.first("notBefore", false, x => xmlP.parseTimestamp(x.content)),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

function VolumeStatusInfo_Parse(node: xmlP.XmlNode): s.VolumeStatusInfo {
  return {
    Details: node.getList("details", "item").map(VolumeStatusDetails_Parse),
    Status: node.first("status", false, x => (x.content ?? '') as s.VolumeStatusInfoStatus),
  };
}

function VolumeStatusDetails_Parse(node: xmlP.XmlNode): s.VolumeStatusDetails {
  return {
    Name: node.first("name", false, x => (x.content ?? '') as s.VolumeStatusName),
    Status: node.first("status", false, x => x.content ?? ''),
  };
}

function VolumeStatusAttachmentStatus_Parse(node: xmlP.XmlNode): s.VolumeStatusAttachmentStatus {
  return {
    IoPerformance: node.first("ioPerformance", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

function VolumeModification_Parse(node: xmlP.XmlNode): s.VolumeModification {
  return {
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    ModificationState: node.first("modificationState", false, x => (x.content ?? '') as s.VolumeModificationState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    TargetSize: node.first("targetSize", false, x => parseInt(x.content ?? '0')),
    TargetIops: node.first("targetIops", false, x => parseInt(x.content ?? '0')),
    TargetVolumeType: node.first("targetVolumeType", false, x => (x.content ?? '') as s.VolumeType),
    TargetThroughput: node.first("targetThroughput", false, x => parseInt(x.content ?? '0')),
    TargetMultiAttachEnabled: node.first("targetMultiAttachEnabled", false, x => x.content === 'true'),
    OriginalSize: node.first("originalSize", false, x => parseInt(x.content ?? '0')),
    OriginalIops: node.first("originalIops", false, x => parseInt(x.content ?? '0')),
    OriginalVolumeType: node.first("originalVolumeType", false, x => (x.content ?? '') as s.VolumeType),
    OriginalThroughput: node.first("originalThroughput", false, x => parseInt(x.content ?? '0')),
    OriginalMultiAttachEnabled: node.first("originalMultiAttachEnabled", false, x => x.content === 'true'),
    Progress: node.first("progress", false, x => parseInt(x.content ?? '0')),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("endTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function VpcClassicLink_Parse(node: xmlP.XmlNode): s.VpcClassicLink {
  return {
    ClassicLinkEnabled: node.first("classicLinkEnabled", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function ClassicLinkDnsSupport_Parse(node: xmlP.XmlNode): s.ClassicLinkDnsSupport {
  return {
    ClassicLinkDnsSupported: node.first("classicLinkDnsSupported", false, x => x.content === 'true'),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

function VpcEndpointConnection_Parse(node: xmlP.XmlNode): s.VpcEndpointConnection {
  return {
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    VpcEndpointOwner: node.first("vpcEndpointOwner", false, x => x.content ?? ''),
    VpcEndpointState: node.first("vpcEndpointState", false, x => (x.content ?? '') as s.State),
    CreationTimestamp: node.first("creationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    DnsEntries: node.getList("dnsEntrySet", "item").map(DnsEntry_Parse),
    NetworkLoadBalancerArns: node.getList("networkLoadBalancerArnSet", "item").map(x => x.content ?? ''),
    GatewayLoadBalancerArns: node.getList("gatewayLoadBalancerArnSet", "item").map(x => x.content ?? ''),
  };
}

function AllowedPrincipal_Parse(node: xmlP.XmlNode): s.AllowedPrincipal {
  return {
    PrincipalType: node.first("principalType", false, x => (x.content ?? '') as s.PrincipalType),
    Principal: node.first("principal", false, x => x.content ?? ''),
  };
}

function ServiceDetail_Parse(node: xmlP.XmlNode): s.ServiceDetail {
  return {
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    ServiceType: node.getList("serviceType", "item").map(ServiceTypeDetail_Parse),
    AvailabilityZones: node.getList("availabilityZoneSet", "item").map(x => x.content ?? ''),
    Owner: node.first("owner", false, x => x.content ?? ''),
    BaseEndpointDnsNames: node.getList("baseEndpointDnsNameSet", "item").map(x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateDnsNames: node.getList("privateDnsNameSet", "item").map(PrivateDnsDetails_Parse),
    VpcEndpointPolicySupported: node.first("vpcEndpointPolicySupported", false, x => x.content === 'true'),
    AcceptanceRequired: node.first("acceptanceRequired", false, x => x.content === 'true'),
    ManagesVpcEndpoints: node.first("managesVpcEndpoints", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PrivateDnsNameVerificationState: node.first("privateDnsNameVerificationState", false, x => (x.content ?? '') as s.DnsNameState),
  };
}

function PrivateDnsDetails_Parse(node: xmlP.XmlNode): s.PrivateDnsDetails {
  return {
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
  };
}

function DisableFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): s.DisableFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function DisableFastSnapshotRestoreErrorItem_Parse(node: xmlP.XmlNode): s.DisableFastSnapshotRestoreErrorItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    FastSnapshotRestoreStateErrors: node.getList("fastSnapshotRestoreStateErrorSet", "item").map(DisableFastSnapshotRestoreStateErrorItem_Parse),
  };
}

function DisableFastSnapshotRestoreStateErrorItem_Parse(node: xmlP.XmlNode): s.DisableFastSnapshotRestoreStateErrorItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Error: node.first("error", false, DisableFastSnapshotRestoreStateError_Parse),
  };
}

function DisableFastSnapshotRestoreStateError_Parse(node: xmlP.XmlNode): s.DisableFastSnapshotRestoreStateError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function TransitGatewayPropagation_Parse(node: xmlP.XmlNode): s.TransitGatewayPropagation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayPropagationState),
  };
}

function EnableFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): s.EnableFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EnableFastSnapshotRestoreErrorItem_Parse(node: xmlP.XmlNode): s.EnableFastSnapshotRestoreErrorItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    FastSnapshotRestoreStateErrors: node.getList("fastSnapshotRestoreStateErrorSet", "item").map(EnableFastSnapshotRestoreStateErrorItem_Parse),
  };
}

function EnableFastSnapshotRestoreStateErrorItem_Parse(node: xmlP.XmlNode): s.EnableFastSnapshotRestoreStateErrorItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Error: node.first("error", false, EnableFastSnapshotRestoreStateError_Parse),
  };
}

function EnableFastSnapshotRestoreStateError_Parse(node: xmlP.XmlNode): s.EnableFastSnapshotRestoreStateError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function ClientCertificateRevocationListStatus_Parse(node: xmlP.XmlNode): s.ClientCertificateRevocationListStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.ClientCertificateRevocationListStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function AssociatedRole_Parse(node: xmlP.XmlNode): s.AssociatedRole {
  return {
    AssociatedRoleArn: node.first("associatedRoleArn", false, x => x.content ?? ''),
    CertificateS3BucketName: node.first("certificateS3BucketName", false, x => x.content ?? ''),
    CertificateS3ObjectKey: node.first("certificateS3ObjectKey", false, x => x.content ?? ''),
    EncryptionKmsKeyId: node.first("encryptionKmsKeyId", false, x => x.content ?? ''),
  };
}

function Ipv6CidrAssociation_Parse(node: xmlP.XmlNode): s.Ipv6CidrAssociation {
  return {
    Ipv6Cidr: node.first("ipv6Cidr", false, x => x.content ?? ''),
    AssociatedResource: node.first("associatedResource", false, x => x.content ?? ''),
  };
}

function InstanceUsage_Parse(node: xmlP.XmlNode): s.InstanceUsage {
  return {
    AccountId: node.first("accountId", false, x => x.content ?? ''),
    UsedInstanceCount: node.first("usedInstanceCount", false, x => parseInt(x.content ?? '0')),
  };
}

function CoipAddressUsage_Parse(node: xmlP.XmlNode): s.CoipAddressUsage {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AwsAccountId: node.first("awsAccountId", false, x => x.content ?? ''),
    AwsService: node.first("awsService", false, x => x.content ?? ''),
    CoIp: node.first("coIp", false, x => x.content ?? ''),
  };
}

function InstanceFamilyCreditSpecification_Parse(node: xmlP.XmlNode): s.InstanceFamilyCreditSpecification {
  return {
    InstanceFamily: node.first("instanceFamily", false, x => (x.content ?? '') as s.UnlimitedSupportedInstanceFamily),
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

function CapacityReservationGroup_Parse(node: xmlP.XmlNode): s.CapacityReservationGroup {
  return {
    GroupArn: node.first("groupArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

function Purchase_Parse(node: xmlP.XmlNode): s.Purchase {
  return {
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as s.CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    HostIdSet: node.getList("hostIdSet", "item").map(x => x.content ?? ''),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as s.PaymentOption),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
  };
}

function PrefixListAssociation_Parse(node: xmlP.XmlNode): s.PrefixListAssociation {
  return {
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceOwner: node.first("resourceOwner", false, x => x.content ?? ''),
  };
}

function PrefixListEntry_Parse(node: xmlP.XmlNode): s.PrefixListEntry {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

function ReservationValue_Parse(node: xmlP.XmlNode): s.ReservationValue {
  return {
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    RemainingTotalValue: node.first("remainingTotalValue", false, x => x.content ?? ''),
    RemainingUpfrontValue: node.first("remainingUpfrontValue", false, x => x.content ?? ''),
  };
}

function ReservedInstanceReservationValue_Parse(node: xmlP.XmlNode): s.ReservedInstanceReservationValue {
  return {
    ReservationValue: node.first("reservationValue", false, ReservationValue_Parse),
    ReservedInstanceId: node.first("reservedInstanceId", false, x => x.content ?? ''),
  };
}

function TargetReservationValue_Parse(node: xmlP.XmlNode): s.TargetReservationValue {
  return {
    ReservationValue: node.first("reservationValue", false, ReservationValue_Parse),
    TargetConfiguration: node.first("targetConfiguration", false, TargetConfiguration_Parse),
  };
}

function TargetConfiguration_Parse(node: xmlP.XmlNode): s.TargetConfiguration {
  return {
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
  };
}

function TransitGatewayAttachmentPropagation_Parse(node: xmlP.XmlNode): s.TransitGatewayAttachmentPropagation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayPropagationState),
  };
}

function TransitGatewayMulticastDomainAssociation_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastDomainAssociation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    ResourceOwnerId: node.first("resourceOwnerId", false, x => x.content ?? ''),
    Subnet: node.first("subnet", false, SubnetAssociation_Parse),
  };
}

function TransitGatewayRouteTableAssociation_Parse(node: xmlP.XmlNode): s.TransitGatewayRouteTableAssociation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayAssociationState),
  };
}

function TransitGatewayRouteTablePropagation_Parse(node: xmlP.XmlNode): s.TransitGatewayRouteTablePropagation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as s.TransitGatewayPropagationState),
  };
}

function SuccessfulInstanceCreditSpecificationItem_Parse(node: xmlP.XmlNode): s.SuccessfulInstanceCreditSpecificationItem {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

function UnsuccessfulInstanceCreditSpecificationItem_Parse(node: xmlP.XmlNode): s.UnsuccessfulInstanceCreditSpecificationItem {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Error: node.first("error", false, UnsuccessfulInstanceCreditSpecificationItemError_Parse),
  };
}

function UnsuccessfulInstanceCreditSpecificationItemError_Parse(node: xmlP.XmlNode): s.UnsuccessfulInstanceCreditSpecificationItemError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as s.UnsuccessfulInstanceCreditSpecificationErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

function PeeringConnectionOptions_Parse(node: xmlP.XmlNode): s.PeeringConnectionOptions {
  return {
    AllowDnsResolutionFromRemoteVpc: node.first("allowDnsResolutionFromRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalClassicLinkToRemoteVpc: node.first("allowEgressFromLocalClassicLinkToRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalVpcToRemoteClassicLink: node.first("allowEgressFromLocalVpcToRemoteClassicLink", false, x => x.content === 'true'),
  };
}

function InstanceMonitoring_Parse(node: xmlP.XmlNode): s.InstanceMonitoring {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, Monitoring_Parse),
  };
}

function TransitGatewayMulticastRegisteredGroupMembers_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastRegisteredGroupMembers {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    RegisteredNetworkInterfaceIds: node.getList("registeredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

function TransitGatewayMulticastRegisteredGroupSources_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastRegisteredGroupSources {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    RegisteredNetworkInterfaceIds: node.getList("registeredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

function TransitGatewayMulticastGroup_Parse(node: xmlP.XmlNode): s.TransitGatewayMulticastGroup {
  return {
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as s.TransitGatewayAttachmentResourceType),
    ResourceOwnerId: node.first("resourceOwnerId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    GroupMember: node.first("groupMember", false, x => x.content === 'true'),
    GroupSource: node.first("groupSource", false, x => x.content === 'true'),
    MemberType: node.first("memberType", false, x => (x.content ?? '') as s.MembershipType),
    SourceType: node.first("sourceType", false, x => (x.content ?? '') as s.MembershipType),
  };
}

function InstanceStateChange_Parse(node: xmlP.XmlNode): s.InstanceStateChange {
  return {
    CurrentState: node.first("currentState", false, InstanceState_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    PreviousState: node.first("previousState", false, InstanceState_Parse),
  };
}

function TerminateConnectionStatus_Parse(node: xmlP.XmlNode): s.TerminateConnectionStatus {
  return {
    ConnectionId: node.first("connectionId", false, x => x.content ?? ''),
    PreviousStatus: node.first("previousStatus", false, ClientVpnConnectionStatus_Parse),
    CurrentStatus: node.first("currentStatus", false, ClientVpnConnectionStatus_Parse),
  };
}
