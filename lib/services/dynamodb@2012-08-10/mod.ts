// Autogenerated API client for: Amazon DynamoDB

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class DynamoDB {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DynamoDB.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-08-10",
    "endpointPrefix": "dynamodb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "DynamoDB",
    "serviceFullName": "Amazon DynamoDB",
    "serviceId": "DynamoDB",
    "signatureVersion": "v4",
    "targetPrefix": "DynamoDB_20120810",
    "uid": "dynamodb-2012-08-10"
  };

  async batchExecuteStatement(
    {abortSignal, ...params}: RequestConfig & s.BatchExecuteStatementInput,
  ): Promise<s.BatchExecuteStatementOutput> {
    const body: jsonP.JSONObject = {
      Statements: params["Statements"]?.map(x => fromBatchStatementRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchExecuteStatement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": [toBatchStatementResponse],
      },
    }, await resp.json());
  }

  async batchGetItem(
    {abortSignal, ...params}: RequestConfig & s.BatchGetItemInput,
  ): Promise<s.BatchGetItemOutput> {
    const body: jsonP.JSONObject = {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => fromKeysAndAttributes(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readMap(String, toAttributeValue, y)!) : [], x),
        "UnprocessedKeys": x => jsonP.readMap(String, toKeysAndAttributes, x),
        "ConsumedCapacity": [toConsumedCapacity],
      },
    }, await resp.json());
  }

  async batchWriteItem(
    {abortSignal, ...params}: RequestConfig & s.BatchWriteItemInput,
  ): Promise<s.BatchWriteItemOutput> {
    const body: jsonP.JSONObject = {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => x?.map(fromWriteRequest)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchWriteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedItems": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toWriteRequest) : [], x),
        "ItemCollectionMetrics": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toItemCollectionMetrics) : [], x),
        "ConsumedCapacity": [toConsumedCapacity],
      },
    }, await resp.json());
  }

  async createBackup(
    {abortSignal, ...params}: RequestConfig & s.CreateBackupInput,
  ): Promise<s.CreateBackupOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      BackupName: params["BackupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDetails": toBackupDetails,
      },
    }, await resp.json());
  }

  async createGlobalTable(
    {abortSignal, ...params}: RequestConfig & s.CreateGlobalTableInput,
  ): Promise<s.CreateGlobalTableOutput> {
    const body: jsonP.JSONObject = {
      GlobalTableName: params["GlobalTableName"],
      ReplicationGroup: params["ReplicationGroup"]?.map(x => fromReplica(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & s.CreateTableInput,
  ): Promise<s.CreateTableOutput> {
    const body: jsonP.JSONObject = {
      AttributeDefinitions: params["AttributeDefinitions"]?.map(x => fromAttributeDefinition(x)),
      TableName: params["TableName"],
      KeySchema: params["KeySchema"]?.map(x => fromKeySchemaElement(x)),
      LocalSecondaryIndexes: params["LocalSecondaryIndexes"]?.map(x => fromLocalSecondaryIndex(x)),
      GlobalSecondaryIndexes: params["GlobalSecondaryIndexes"]?.map(x => fromGlobalSecondaryIndex(x)),
      BillingMode: params["BillingMode"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
      StreamSpecification: fromStreamSpecification(params["StreamSpecification"]),
      SSESpecification: fromSSESpecification(params["SSESpecification"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async deleteBackup(
    {abortSignal, ...params}: RequestConfig & s.DeleteBackupInput,
  ): Promise<s.DeleteBackupOutput> {
    const body: jsonP.JSONObject = {
      BackupArn: params["BackupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDescription": toBackupDescription,
      },
    }, await resp.json());
  }

  async deleteItem(
    {abortSignal, ...params}: RequestConfig & s.DeleteItemInput,
  ): Promise<s.DeleteItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteTableInput,
  ): Promise<s.DeleteTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async describeBackup(
    {abortSignal, ...params}: RequestConfig & s.DescribeBackupInput,
  ): Promise<s.DescribeBackupOutput> {
    const body: jsonP.JSONObject = {
      BackupArn: params["BackupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDescription": toBackupDescription,
      },
    }, await resp.json());
  }

  async describeContinuousBackups(
    {abortSignal, ...params}: RequestConfig & s.DescribeContinuousBackupsInput,
  ): Promise<s.DescribeContinuousBackupsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContinuousBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContinuousBackupsDescription": toContinuousBackupsDescription,
      },
    }, await resp.json());
  }

  async describeContributorInsights(
    {abortSignal, ...params}: RequestConfig & s.DescribeContributorInsightsInput,
  ): Promise<s.DescribeContributorInsightsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "IndexName": "s",
        "ContributorInsightsRuleList": ["s"],
        "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContributorInsightsStatus>(x),
        "LastUpdateDateTime": "d",
        "FailureException": toFailureException,
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointsRequest = {},
  ): Promise<s.DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpoint],
      },
      optional: {},
    }, await resp.json());
  }

  async describeExport(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportInput,
  ): Promise<s.DescribeExportOutput> {
    const body: jsonP.JSONObject = {
      ExportArn: params["ExportArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExportDescription": toExportDescription,
      },
    }, await resp.json());
  }

  async describeGlobalTable(
    {abortSignal, ...params}: RequestConfig & s.DescribeGlobalTableInput,
  ): Promise<s.DescribeGlobalTableOutput> {
    const body: jsonP.JSONObject = {
      GlobalTableName: params["GlobalTableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async describeGlobalTableSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeGlobalTableSettingsInput,
  ): Promise<s.DescribeGlobalTableSettingsOutput> {
    const body: jsonP.JSONObject = {
      GlobalTableName: params["GlobalTableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalTableSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableName": "s",
        "ReplicaSettings": [toReplicaSettingsDescription],
      },
    }, await resp.json());
  }

  async describeKinesisStreamingDestination(
    {abortSignal, ...params}: RequestConfig & s.DescribeKinesisStreamingDestinationInput,
  ): Promise<s.DescribeKinesisStreamingDestinationOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKinesisStreamingDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "KinesisDataStreamDestinations": [toKinesisDataStreamDestination],
      },
    }, await resp.json());
  }

  async describeLimits(
    {abortSignal, ...params}: RequestConfig & s.DescribeLimitsInput = {},
  ): Promise<s.DescribeLimitsOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountMaxReadCapacityUnits": "n",
        "AccountMaxWriteCapacityUnits": "n",
        "TableMaxReadCapacityUnits": "n",
        "TableMaxWriteCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async describeTable(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableInput,
  ): Promise<s.DescribeTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTableDescription,
      },
    }, await resp.json());
  }

  async describeTableReplicaAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableReplicaAutoScalingInput,
  ): Promise<s.DescribeTableReplicaAutoScalingOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableReplicaAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableAutoScalingDescription": toTableAutoScalingDescription,
      },
    }, await resp.json());
  }

  async describeTimeToLive(
    {abortSignal, ...params}: RequestConfig & s.DescribeTimeToLiveInput,
  ): Promise<s.DescribeTimeToLiveOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTimeToLive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeToLiveDescription": toTimeToLiveDescription,
      },
    }, await resp.json());
  }

  async disableKinesisStreamingDestination(
    {abortSignal, ...params}: RequestConfig & s.KinesisStreamingDestinationInput,
  ): Promise<s.KinesisStreamingDestinationOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      StreamArn: params["StreamArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableKinesisStreamingDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "StreamArn": "s",
        "DestinationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DestinationStatus>(x),
      },
    }, await resp.json());
  }

  async enableKinesisStreamingDestination(
    {abortSignal, ...params}: RequestConfig & s.KinesisStreamingDestinationInput,
  ): Promise<s.KinesisStreamingDestinationOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      StreamArn: params["StreamArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableKinesisStreamingDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "StreamArn": "s",
        "DestinationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DestinationStatus>(x),
      },
    }, await resp.json());
  }

  async executeStatement(
    {abortSignal, ...params}: RequestConfig & s.ExecuteStatementInput,
  ): Promise<s.ExecuteStatementOutput> {
    const body: jsonP.JSONObject = {
      Statement: params["Statement"],
      Parameters: params["Parameters"]?.map(x => fromAttributeValue(x)),
      ConsistentRead: params["ConsistentRead"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteStatement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async executeTransaction(
    {abortSignal, ...params}: RequestConfig & s.ExecuteTransactionInput,
  ): Promise<s.ExecuteTransactionOutput> {
    const body: jsonP.JSONObject = {
      TransactStatements: params["TransactStatements"]?.map(x => fromParameterizedStatement(x)),
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteTransaction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": [toItemResponse],
      },
    }, await resp.json());
  }

  async exportTableToPointInTime(
    {abortSignal, ...params}: RequestConfig & s.ExportTableToPointInTimeInput,
  ): Promise<s.ExportTableToPointInTimeOutput> {
    const body: jsonP.JSONObject = {
      TableArn: params["TableArn"],
      ExportTime: jsonP.serializeDate_unixTimestamp(params["ExportTime"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      S3Bucket: params["S3Bucket"],
      S3BucketOwner: params["S3BucketOwner"],
      S3Prefix: params["S3Prefix"],
      S3SseAlgorithm: params["S3SseAlgorithm"],
      S3SseKmsKeyId: params["S3SseKmsKeyId"],
      ExportFormat: params["ExportFormat"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportTableToPointInTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExportDescription": toExportDescription,
      },
    }, await resp.json());
  }

  async getItem(
    {abortSignal, ...params}: RequestConfig & s.GetItemInput,
  ): Promise<s.GetItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      AttributesToGet: params["AttributesToGet"],
      ConsistentRead: params["ConsistentRead"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ProjectionExpression: params["ProjectionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Item": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async listBackups(
    {abortSignal, ...params}: RequestConfig & s.ListBackupsInput = {},
  ): Promise<s.ListBackupsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Limit: params["Limit"],
      TimeRangeLowerBound: jsonP.serializeDate_unixTimestamp(params["TimeRangeLowerBound"]),
      TimeRangeUpperBound: jsonP.serializeDate_unixTimestamp(params["TimeRangeUpperBound"]),
      ExclusiveStartBackupArn: params["ExclusiveStartBackupArn"],
      BackupType: params["BackupType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupSummaries": [toBackupSummary],
        "LastEvaluatedBackupArn": "s",
      },
    }, await resp.json());
  }

  async listContributorInsights(
    {abortSignal, ...params}: RequestConfig & s.ListContributorInsightsInput = {},
  ): Promise<s.ListContributorInsightsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContributorInsightsSummaries": [toContributorInsightsSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listExports(
    {abortSignal, ...params}: RequestConfig & s.ListExportsInput = {},
  ): Promise<s.ListExportsOutput> {
    const body: jsonP.JSONObject = {
      TableArn: params["TableArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListExports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExportSummaries": [toExportSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGlobalTables(
    {abortSignal, ...params}: RequestConfig & s.ListGlobalTablesInput = {},
  ): Promise<s.ListGlobalTablesOutput> {
    const body: jsonP.JSONObject = {
      ExclusiveStartGlobalTableName: params["ExclusiveStartGlobalTableName"],
      Limit: params["Limit"],
      RegionName: params["RegionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGlobalTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTables": [toGlobalTable],
        "LastEvaluatedGlobalTableName": "s",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & s.ListTablesInput = {},
  ): Promise<s.ListTablesOutput> {
    const body: jsonP.JSONObject = {
      ExclusiveStartTableName: params["ExclusiveStartTableName"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableNames": ["s"],
        "LastEvaluatedTableName": "s",
      },
    }, await resp.json());
  }

  async listTagsOfResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsOfResourceInput,
  ): Promise<s.ListTagsOfResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsOfResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putItem(
    {abortSignal, ...params}: RequestConfig & s.PutItemInput,
  ): Promise<s.PutItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Item: jsonP.serializeMap(params["Item"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ConditionalOperator: params["ConditionalOperator"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & s.QueryInput,
  ): Promise<s.QueryOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      Select: params["Select"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      ConsistentRead: params["ConsistentRead"],
      KeyConditions: jsonP.serializeMap(params["KeyConditions"], x => fromCondition(x)),
      QueryFilter: jsonP.serializeMap(params["QueryFilter"], x => fromCondition(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ScanIndexForward: params["ScanIndexForward"],
      ExclusiveStartKey: jsonP.serializeMap(params["ExclusiveStartKey"], x => fromAttributeValue(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ProjectionExpression: params["ProjectionExpression"],
      FilterExpression: params["FilterExpression"],
      KeyConditionExpression: params["KeyConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async restoreTableFromBackup(
    {abortSignal, ...params}: RequestConfig & s.RestoreTableFromBackupInput,
  ): Promise<s.RestoreTableFromBackupOutput> {
    const body: jsonP.JSONObject = {
      TargetTableName: params["TargetTableName"],
      BackupArn: params["BackupArn"],
      BillingModeOverride: params["BillingModeOverride"],
      GlobalSecondaryIndexOverride: params["GlobalSecondaryIndexOverride"]?.map(x => fromGlobalSecondaryIndex(x)),
      LocalSecondaryIndexOverride: params["LocalSecondaryIndexOverride"]?.map(x => fromLocalSecondaryIndex(x)),
      ProvisionedThroughputOverride: fromProvisionedThroughput(params["ProvisionedThroughputOverride"]),
      SSESpecificationOverride: fromSSESpecification(params["SSESpecificationOverride"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableFromBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async restoreTableToPointInTime(
    {abortSignal, ...params}: RequestConfig & s.RestoreTableToPointInTimeInput,
  ): Promise<s.RestoreTableToPointInTimeOutput> {
    const body: jsonP.JSONObject = {
      SourceTableArn: params["SourceTableArn"],
      SourceTableName: params["SourceTableName"],
      TargetTableName: params["TargetTableName"],
      UseLatestRestorableTime: params["UseLatestRestorableTime"],
      RestoreDateTime: jsonP.serializeDate_unixTimestamp(params["RestoreDateTime"]),
      BillingModeOverride: params["BillingModeOverride"],
      GlobalSecondaryIndexOverride: params["GlobalSecondaryIndexOverride"]?.map(x => fromGlobalSecondaryIndex(x)),
      LocalSecondaryIndexOverride: params["LocalSecondaryIndexOverride"]?.map(x => fromLocalSecondaryIndex(x)),
      ProvisionedThroughputOverride: fromProvisionedThroughput(params["ProvisionedThroughputOverride"]),
      SSESpecificationOverride: fromSSESpecification(params["SSESpecificationOverride"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableToPointInTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async scan(
    {abortSignal, ...params}: RequestConfig & s.ScanInput,
  ): Promise<s.ScanOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      Select: params["Select"],
      ScanFilter: jsonP.serializeMap(params["ScanFilter"], x => fromCondition(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ExclusiveStartKey: jsonP.serializeMap(params["ExclusiveStartKey"], x => fromAttributeValue(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      TotalSegments: params["TotalSegments"],
      Segment: params["Segment"],
      ProjectionExpression: params["ProjectionExpression"],
      FilterExpression: params["FilterExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
      ConsistentRead: params["ConsistentRead"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Scan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async transactGetItems(
    {abortSignal, ...params}: RequestConfig & s.TransactGetItemsInput,
  ): Promise<s.TransactGetItemsOutput> {
    const body: jsonP.JSONObject = {
      TransactItems: params["TransactItems"]?.map(x => fromTransactGetItem(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransactGetItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConsumedCapacity": [toConsumedCapacity],
        "Responses": [toItemResponse],
      },
    }, await resp.json());
  }

  async transactWriteItems(
    {abortSignal, ...params}: RequestConfig & s.TransactWriteItemsInput,
  ): Promise<s.TransactWriteItemsOutput> {
    const body: jsonP.JSONObject = {
      TransactItems: params["TransactItems"]?.map(x => fromTransactWriteItem(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransactWriteItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConsumedCapacity": [toConsumedCapacity],
        "ItemCollectionMetrics": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toItemCollectionMetrics) : [], x),
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateContinuousBackups(
    {abortSignal, ...params}: RequestConfig & s.UpdateContinuousBackupsInput,
  ): Promise<s.UpdateContinuousBackupsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      PointInTimeRecoverySpecification: fromPointInTimeRecoverySpecification(params["PointInTimeRecoverySpecification"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContinuousBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContinuousBackupsDescription": toContinuousBackupsDescription,
      },
    }, await resp.json());
  }

  async updateContributorInsights(
    {abortSignal, ...params}: RequestConfig & s.UpdateContributorInsightsInput,
  ): Promise<s.UpdateContributorInsightsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      ContributorInsightsAction: params["ContributorInsightsAction"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "IndexName": "s",
        "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContributorInsightsStatus>(x),
      },
    }, await resp.json());
  }

  async updateGlobalTable(
    {abortSignal, ...params}: RequestConfig & s.UpdateGlobalTableInput,
  ): Promise<s.UpdateGlobalTableOutput> {
    const body: jsonP.JSONObject = {
      GlobalTableName: params["GlobalTableName"],
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicaUpdate(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async updateGlobalTableSettings(
    {abortSignal, ...params}: RequestConfig & s.UpdateGlobalTableSettingsInput,
  ): Promise<s.UpdateGlobalTableSettingsOutput> {
    const body: jsonP.JSONObject = {
      GlobalTableName: params["GlobalTableName"],
      GlobalTableBillingMode: params["GlobalTableBillingMode"],
      GlobalTableProvisionedWriteCapacityUnits: params["GlobalTableProvisionedWriteCapacityUnits"],
      GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(params["GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate"]),
      GlobalTableGlobalSecondaryIndexSettingsUpdate: params["GlobalTableGlobalSecondaryIndexSettingsUpdate"]?.map(x => fromGlobalTableGlobalSecondaryIndexSettingsUpdate(x)),
      ReplicaSettingsUpdate: params["ReplicaSettingsUpdate"]?.map(x => fromReplicaSettingsUpdate(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGlobalTableSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableName": "s",
        "ReplicaSettings": [toReplicaSettingsDescription],
      },
    }, await resp.json());
  }

  async updateItem(
    {abortSignal, ...params}: RequestConfig & s.UpdateItemInput,
  ): Promise<s.UpdateItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      AttributeUpdates: jsonP.serializeMap(params["AttributeUpdates"], x => fromAttributeValueUpdate(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      UpdateExpression: params["UpdateExpression"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & s.UpdateTableInput,
  ): Promise<s.UpdateTableOutput> {
    const body: jsonP.JSONObject = {
      AttributeDefinitions: params["AttributeDefinitions"]?.map(x => fromAttributeDefinition(x)),
      TableName: params["TableName"],
      BillingMode: params["BillingMode"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
      GlobalSecondaryIndexUpdates: params["GlobalSecondaryIndexUpdates"]?.map(x => fromGlobalSecondaryIndexUpdate(x)),
      StreamSpecification: fromStreamSpecification(params["StreamSpecification"]),
      SSESpecification: fromSSESpecification(params["SSESpecification"]),
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicationGroupUpdate(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async updateTableReplicaAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.UpdateTableReplicaAutoScalingInput,
  ): Promise<s.UpdateTableReplicaAutoScalingOutput> {
    const body: jsonP.JSONObject = {
      GlobalSecondaryIndexUpdates: params["GlobalSecondaryIndexUpdates"]?.map(x => fromGlobalSecondaryIndexAutoScalingUpdate(x)),
      TableName: params["TableName"],
      ProvisionedWriteCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(params["ProvisionedWriteCapacityAutoScalingUpdate"]),
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicaAutoScalingUpdate(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTableReplicaAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableAutoScalingDescription": toTableAutoScalingDescription,
      },
    }, await resp.json());
  }

  async updateTimeToLive(
    {abortSignal, ...params}: RequestConfig & s.UpdateTimeToLiveInput,
  ): Promise<s.UpdateTimeToLiveOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      TimeToLiveSpecification: fromTimeToLiveSpecification(params["TimeToLiveSpecification"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTimeToLive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeToLiveSpecification": toTimeToLiveSpecification,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableExists(
    params: RequestConfig & s.DescribeTableInput,
  ): Promise<s.DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
        if (resp?.Table?.TableStatus === "ACTIVE") return resp;
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableNotExists(
    params: RequestConfig & s.DescribeTableInput,
  ): Promise<Error | s.DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableNotExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

function fromBatchStatementRequest(input?: s.BatchStatementRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statement: input["Statement"],
    Parameters: input["Parameters"]?.map(x => fromAttributeValue(x)),
    ConsistentRead: input["ConsistentRead"],
  }
}

function fromAttributeValue(input?: s.AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    B: serializeBlob(input["B"]),
    SS: input["SS"],
    NS: input["NS"],
    BS: input["BS"]?.map(x => serializeBlob(x)),
    M: jsonP.serializeMap(input["M"], x => fromAttributeValue(x)),
    L: input["L"]?.map(x => fromAttributeValue(x)),
    NULL: input["NULL"],
    BOOL: input["BOOL"],
  }
}
function toAttributeValue(root: jsonP.JSONValue): s.AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "s",
      "B": "a",
      "SS": ["s"],
      "NS": ["s"],
      "BS": ["a"],
      "M": x => jsonP.readMap(String, toAttributeValue, x),
      "L": [toAttributeValue],
      "NULL": "b",
      "BOOL": "b",
    },
  }, root);
}

function fromKeysAndAttributes(input?: s.KeysAndAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"]?.map(x => jsonP.serializeMap(x, fromAttributeValue)),
    AttributesToGet: input["AttributesToGet"],
    ConsistentRead: input["ConsistentRead"],
    ProjectionExpression: input["ProjectionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
  }
}
function toKeysAndAttributes(root: jsonP.JSONValue): s.KeysAndAttributes {
  return jsonP.readObj({
    required: {
      "Keys": [x => jsonP.readMap(String, toAttributeValue, x)],
    },
    optional: {
      "AttributesToGet": ["s"],
      "ConsistentRead": "b",
      "ProjectionExpression": "s",
      "ExpressionAttributeNames": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromWriteRequest(input?: s.WriteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PutRequest: fromPutRequest(input["PutRequest"]),
    DeleteRequest: fromDeleteRequest(input["DeleteRequest"]),
  }
}
function toWriteRequest(root: jsonP.JSONValue): s.WriteRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "PutRequest": toPutRequest,
      "DeleteRequest": toDeleteRequest,
    },
  }, root);
}

function fromPutRequest(input?: s.PutRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
  }
}
function toPutRequest(root: jsonP.JSONValue): s.PutRequest {
  return jsonP.readObj({
    required: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

function fromDeleteRequest(input?: s.DeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
  }
}
function toDeleteRequest(root: jsonP.JSONValue): s.DeleteRequest {
  return jsonP.readObj({
    required: {
      "Key": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

function fromReplica(input?: s.Replica | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}
function toReplica(root: jsonP.JSONValue): s.Replica {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
    },
  }, root);
}

function fromAttributeDefinition(input?: s.AttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toAttributeDefinition(root: jsonP.JSONValue): s.AttributeDefinition {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalarAttributeType>(x),
    },
    optional: {},
  }, root);
}

function fromKeySchemaElement(input?: s.KeySchemaElement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    KeyType: input["KeyType"],
  }
}
function toKeySchemaElement(root: jsonP.JSONValue): s.KeySchemaElement {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyType>(x),
    },
    optional: {},
  }, root);
}

function fromLocalSecondaryIndex(input?: s.LocalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
  }
}

function fromProjection(input?: s.Projection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProjectionType: input["ProjectionType"],
    NonKeyAttributes: input["NonKeyAttributes"],
  }
}
function toProjection(root: jsonP.JSONValue): s.Projection {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectionType>(x),
      "NonKeyAttributes": ["s"],
    },
  }, root);
}

function fromGlobalSecondaryIndex(input?: s.GlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

function fromProvisionedThroughput(input?: s.ProvisionedThroughput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
    WriteCapacityUnits: input["WriteCapacityUnits"],
  }
}
function toProvisionedThroughput(root: jsonP.JSONValue): s.ProvisionedThroughput {
  return jsonP.readObj({
    required: {
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
    optional: {},
  }, root);
}

function fromStreamSpecification(input?: s.StreamSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamEnabled: input["StreamEnabled"],
    StreamViewType: input["StreamViewType"],
  }
}
function toStreamSpecification(root: jsonP.JSONValue): s.StreamSpecification {
  return jsonP.readObj({
    required: {
      "StreamEnabled": "b",
    },
    optional: {
      "StreamViewType": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamViewType>(x),
    },
  }, root);
}

function fromSSESpecification(input?: s.SSESpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    SSEType: input["SSEType"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
  }
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromExpectedAttributeValue(input?: s.ExpectedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Exists: input["Exists"],
    ComparisonOperator: input["ComparisonOperator"],
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
  }
}

function fromParameterizedStatement(input?: s.ParameterizedStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statement: input["Statement"],
    Parameters: input["Parameters"]?.map(x => fromAttributeValue(x)),
  }
}

function fromCondition(input?: s.Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
    ComparisonOperator: input["ComparisonOperator"],
  }
}

function fromTransactGetItem(input?: s.TransactGetItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Get: fromGet(input["Get"]),
  }
}

function fromGet(input?: s.Get | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ProjectionExpression: input["ProjectionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
  }
}

function fromTransactWriteItem(input?: s.TransactWriteItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConditionCheck: fromConditionCheck(input["ConditionCheck"]),
    Put: fromPut(input["Put"]),
    Delete: fromDelete(input["Delete"]),
    Update: fromUpdate(input["Update"]),
  }
}

function fromConditionCheck(input?: s.ConditionCheck | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

function fromPut(input?: s.Put | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

function fromDelete(input?: s.Delete | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

function fromUpdate(input?: s.Update | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    UpdateExpression: input["UpdateExpression"],
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

function fromPointInTimeRecoverySpecification(input?: s.PointInTimeRecoverySpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PointInTimeRecoveryEnabled: input["PointInTimeRecoveryEnabled"],
  }
}

function fromReplicaUpdate(input?: s.ReplicaUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Create: fromCreateReplicaAction(input["Create"]),
    Delete: fromDeleteReplicaAction(input["Delete"]),
  }
}

function fromCreateReplicaAction(input?: s.CreateReplicaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

function fromDeleteReplicaAction(input?: s.DeleteReplicaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

function fromAutoScalingSettingsUpdate(input?: s.AutoScalingSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumUnits: input["MinimumUnits"],
    MaximumUnits: input["MaximumUnits"],
    AutoScalingDisabled: input["AutoScalingDisabled"],
    AutoScalingRoleArn: input["AutoScalingRoleArn"],
    ScalingPolicyUpdate: fromAutoScalingPolicyUpdate(input["ScalingPolicyUpdate"]),
  }
}

function fromAutoScalingPolicyUpdate(input?: s.AutoScalingPolicyUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
    TargetTrackingScalingPolicyConfiguration: fromAutoScalingTargetTrackingScalingPolicyConfigurationUpdate(input["TargetTrackingScalingPolicyConfiguration"]),
  }
}

function fromAutoScalingTargetTrackingScalingPolicyConfigurationUpdate(input?: s.AutoScalingTargetTrackingScalingPolicyConfigurationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DisableScaleIn: input["DisableScaleIn"],
    ScaleInCooldown: input["ScaleInCooldown"],
    ScaleOutCooldown: input["ScaleOutCooldown"],
    TargetValue: input["TargetValue"],
  }
}

function fromGlobalTableGlobalSecondaryIndexSettingsUpdate(input?: s.GlobalTableGlobalSecondaryIndexSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedWriteCapacityUnits: input["ProvisionedWriteCapacityUnits"],
    ProvisionedWriteCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedWriteCapacityAutoScalingSettingsUpdate"]),
  }
}

function fromReplicaSettingsUpdate(input?: s.ReplicaSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    ReplicaProvisionedReadCapacityUnits: input["ReplicaProvisionedReadCapacityUnits"],
    ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate"]),
    ReplicaGlobalSecondaryIndexSettingsUpdate: input["ReplicaGlobalSecondaryIndexSettingsUpdate"]?.map(x => fromReplicaGlobalSecondaryIndexSettingsUpdate(x)),
  }
}

function fromReplicaGlobalSecondaryIndexSettingsUpdate(input?: s.ReplicaGlobalSecondaryIndexSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedReadCapacityUnits: input["ProvisionedReadCapacityUnits"],
    ProvisionedReadCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedReadCapacityAutoScalingSettingsUpdate"]),
  }
}

function fromAttributeValueUpdate(input?: s.AttributeValueUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Action: input["Action"],
  }
}

function fromGlobalSecondaryIndexUpdate(input?: s.GlobalSecondaryIndexUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Update: fromUpdateGlobalSecondaryIndexAction(input["Update"]),
    Create: fromCreateGlobalSecondaryIndexAction(input["Create"]),
    Delete: fromDeleteGlobalSecondaryIndexAction(input["Delete"]),
  }
}

function fromUpdateGlobalSecondaryIndexAction(input?: s.UpdateGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

function fromCreateGlobalSecondaryIndexAction(input?: s.CreateGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

function fromDeleteGlobalSecondaryIndexAction(input?: s.DeleteGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
  }
}

function fromReplicationGroupUpdate(input?: s.ReplicationGroupUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Create: fromCreateReplicationGroupMemberAction(input["Create"]),
    Update: fromUpdateReplicationGroupMemberAction(input["Update"]),
    Delete: fromDeleteReplicationGroupMemberAction(input["Delete"]),
  }
}

function fromCreateReplicationGroupMemberAction(input?: s.CreateReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromReplicaGlobalSecondaryIndex(x)),
  }
}

function fromProvisionedThroughputOverride(input?: s.ProvisionedThroughputOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
  }
}
function toProvisionedThroughputOverride(root: jsonP.JSONValue): s.ProvisionedThroughputOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadCapacityUnits": "n",
    },
  }, root);
}

function fromReplicaGlobalSecondaryIndex(input?: s.ReplicaGlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
  }
}

function fromUpdateReplicationGroupMemberAction(input?: s.UpdateReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromReplicaGlobalSecondaryIndex(x)),
  }
}

function fromDeleteReplicationGroupMemberAction(input?: s.DeleteReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

function fromGlobalSecondaryIndexAutoScalingUpdate(input?: s.GlobalSecondaryIndexAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedWriteCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedWriteCapacityAutoScalingUpdate"]),
  }
}

function fromReplicaAutoScalingUpdate(input?: s.ReplicaAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    ReplicaGlobalSecondaryIndexUpdates: input["ReplicaGlobalSecondaryIndexUpdates"]?.map(x => fromReplicaGlobalSecondaryIndexAutoScalingUpdate(x)),
    ReplicaProvisionedReadCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ReplicaProvisionedReadCapacityAutoScalingUpdate"]),
  }
}

function fromReplicaGlobalSecondaryIndexAutoScalingUpdate(input?: s.ReplicaGlobalSecondaryIndexAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedReadCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedReadCapacityAutoScalingUpdate"]),
  }
}

function fromTimeToLiveSpecification(input?: s.TimeToLiveSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    AttributeName: input["AttributeName"],
  }
}
function toTimeToLiveSpecification(root: jsonP.JSONValue): s.TimeToLiveSpecification {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
      "AttributeName": "s",
    },
    optional: {},
  }, root);
}

function toBatchStatementResponse(root: jsonP.JSONValue): s.BatchStatementResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Error": toBatchStatementError,
      "TableName": "s",
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
  }, root);
}

function toBatchStatementError(root: jsonP.JSONValue): s.BatchStatementError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchStatementErrorCodeEnum>(x),
      "Message": "s",
    },
  }, root);
}

function toConsumedCapacity(root: jsonP.JSONValue): s.ConsumedCapacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "CapacityUnits": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
      "Table": toCapacity,
      "LocalSecondaryIndexes": x => jsonP.readMap(String, toCapacity, x),
      "GlobalSecondaryIndexes": x => jsonP.readMap(String, toCapacity, x),
    },
  }, root);
}

function toCapacity(root: jsonP.JSONValue): s.Capacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
      "CapacityUnits": "n",
    },
  }, root);
}

function toItemCollectionMetrics(root: jsonP.JSONValue): s.ItemCollectionMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "ItemCollectionKey": x => jsonP.readMap(String, toAttributeValue, x),
      "SizeEstimateRangeGB": ["n"],
    },
  }, root);
}

function toBackupDetails(root: jsonP.JSONValue): s.BackupDetails {
  return jsonP.readObj({
    required: {
      "BackupArn": "s",
      "BackupName": "s",
      "BackupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupStatus>(x),
      "BackupType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupType>(x),
      "BackupCreationDateTime": "d",
    },
    optional: {
      "BackupSizeBytes": "n",
      "BackupExpiryDateTime": "d",
    },
  }, root);
}

function toGlobalTableDescription(root: jsonP.JSONValue): s.GlobalTableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationGroup": [toReplicaDescription],
      "GlobalTableArn": "s",
      "CreationDateTime": "d",
      "GlobalTableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.GlobalTableStatus>(x),
      "GlobalTableName": "s",
    },
  }, root);
}

function toReplicaDescription(root: jsonP.JSONValue): s.ReplicaDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicaStatus>(x),
      "ReplicaStatusDescription": "s",
      "ReplicaStatusPercentProgress": "s",
      "KMSMasterKeyId": "s",
      "ProvisionedThroughputOverride": toProvisionedThroughputOverride,
      "GlobalSecondaryIndexes": [toReplicaGlobalSecondaryIndexDescription],
      "ReplicaInaccessibleDateTime": "d",
    },
  }, root);
}

function toReplicaGlobalSecondaryIndexDescription(root: jsonP.JSONValue): s.ReplicaGlobalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "ProvisionedThroughputOverride": toProvisionedThroughputOverride,
    },
  }, root);
}

function toTableDescription(root: jsonP.JSONValue): s.TableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeDefinitions": [toAttributeDefinition],
      "TableName": "s",
      "KeySchema": [toKeySchemaElement],
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TableStatus>(x),
      "CreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "TableSizeBytes": "n",
      "ItemCount": "n",
      "TableArn": "s",
      "TableId": "s",
      "BillingModeSummary": toBillingModeSummary,
      "LocalSecondaryIndexes": [toLocalSecondaryIndexDescription],
      "GlobalSecondaryIndexes": [toGlobalSecondaryIndexDescription],
      "StreamSpecification": toStreamSpecification,
      "LatestStreamLabel": "s",
      "LatestStreamArn": "s",
      "GlobalTableVersion": "s",
      "Replicas": [toReplicaDescription],
      "RestoreSummary": toRestoreSummary,
      "SSEDescription": toSSEDescription,
      "ArchivalSummary": toArchivalSummary,
    },
  }, root);
}

function toProvisionedThroughputDescription(root: jsonP.JSONValue): s.ProvisionedThroughputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastIncreaseDateTime": "d",
      "LastDecreaseDateTime": "d",
      "NumberOfDecreasesToday": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
  }, root);
}

function toBillingModeSummary(root: jsonP.JSONValue): s.BillingModeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "BillingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.BillingMode>(x),
      "LastUpdateToPayPerRequestDateTime": "d",
    },
  }, root);
}

function toLocalSecondaryIndexDescription(root: jsonP.JSONValue): s.LocalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "IndexSizeBytes": "n",
      "ItemCount": "n",
      "IndexArn": "s",
    },
  }, root);
}

function toGlobalSecondaryIndexDescription(root: jsonP.JSONValue): s.GlobalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IndexStatus>(x),
      "Backfilling": "b",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "IndexSizeBytes": "n",
      "ItemCount": "n",
      "IndexArn": "s",
    },
  }, root);
}

function toRestoreSummary(root: jsonP.JSONValue): s.RestoreSummary {
  return jsonP.readObj({
    required: {
      "RestoreDateTime": "d",
      "RestoreInProgress": "b",
    },
    optional: {
      "SourceBackupArn": "s",
      "SourceTableArn": "s",
    },
  }, root);
}

function toSSEDescription(root: jsonP.JSONValue): s.SSEDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SSEStatus>(x),
      "SSEType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SSEType>(x),
      "KMSMasterKeyArn": "s",
      "InaccessibleEncryptionDateTime": "d",
    },
  }, root);
}

function toArchivalSummary(root: jsonP.JSONValue): s.ArchivalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchivalDateTime": "d",
      "ArchivalReason": "s",
      "ArchivalBackupArn": "s",
    },
  }, root);
}

function toBackupDescription(root: jsonP.JSONValue): s.BackupDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "BackupDetails": toBackupDetails,
      "SourceTableDetails": toSourceTableDetails,
      "SourceTableFeatureDetails": toSourceTableFeatureDetails,
    },
  }, root);
}

function toSourceTableDetails(root: jsonP.JSONValue): s.SourceTableDetails {
  return jsonP.readObj({
    required: {
      "TableName": "s",
      "TableId": "s",
      "KeySchema": [toKeySchemaElement],
      "TableCreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughput,
    },
    optional: {
      "TableArn": "s",
      "TableSizeBytes": "n",
      "ItemCount": "n",
      "BillingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.BillingMode>(x),
    },
  }, root);
}

function toSourceTableFeatureDetails(root: jsonP.JSONValue): s.SourceTableFeatureDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "LocalSecondaryIndexes": [toLocalSecondaryIndexInfo],
      "GlobalSecondaryIndexes": [toGlobalSecondaryIndexInfo],
      "StreamDescription": toStreamSpecification,
      "TimeToLiveDescription": toTimeToLiveDescription,
      "SSEDescription": toSSEDescription,
    },
  }, root);
}

function toLocalSecondaryIndexInfo(root: jsonP.JSONValue): s.LocalSecondaryIndexInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
    },
  }, root);
}

function toGlobalSecondaryIndexInfo(root: jsonP.JSONValue): s.GlobalSecondaryIndexInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "ProvisionedThroughput": toProvisionedThroughput,
    },
  }, root);
}

function toTimeToLiveDescription(root: jsonP.JSONValue): s.TimeToLiveDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimeToLiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeToLiveStatus>(x),
      "AttributeName": "s",
    },
  }, root);
}

function toContinuousBackupsDescription(root: jsonP.JSONValue): s.ContinuousBackupsDescription {
  return jsonP.readObj({
    required: {
      "ContinuousBackupsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContinuousBackupsStatus>(x),
    },
    optional: {
      "PointInTimeRecoveryDescription": toPointInTimeRecoveryDescription,
    },
  }, root);
}

function toPointInTimeRecoveryDescription(root: jsonP.JSONValue): s.PointInTimeRecoveryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "PointInTimeRecoveryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PointInTimeRecoveryStatus>(x),
      "EarliestRestorableDateTime": "d",
      "LatestRestorableDateTime": "d",
    },
  }, root);
}

function toFailureException(root: jsonP.JSONValue): s.FailureException {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExceptionName": "s",
      "ExceptionDescription": "s",
    },
  }, root);
}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {
      "Address": "s",
      "CachePeriodInMinutes": "n",
    },
    optional: {},
  }, root);
}

function toExportDescription(root: jsonP.JSONValue): s.ExportDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExportArn": "s",
      "ExportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportStatus>(x),
      "StartTime": "d",
      "EndTime": "d",
      "ExportManifest": "s",
      "TableArn": "s",
      "TableId": "s",
      "ExportTime": "d",
      "ClientToken": "s",
      "S3Bucket": "s",
      "S3BucketOwner": "s",
      "S3Prefix": "s",
      "S3SseAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3SseAlgorithm>(x),
      "S3SseKmsKeyId": "s",
      "FailureCode": "s",
      "FailureMessage": "s",
      "ExportFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportFormat>(x),
      "BilledSizeBytes": "n",
      "ItemCount": "n",
    },
  }, root);
}

function toReplicaSettingsDescription(root: jsonP.JSONValue): s.ReplicaSettingsDescription {
  return jsonP.readObj({
    required: {
      "RegionName": "s",
    },
    optional: {
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicaStatus>(x),
      "ReplicaBillingModeSummary": toBillingModeSummary,
      "ReplicaProvisionedReadCapacityUnits": "n",
      "ReplicaProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaProvisionedWriteCapacityUnits": "n",
      "ReplicaProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaGlobalSecondaryIndexSettings": [toReplicaGlobalSecondaryIndexSettingsDescription],
    },
  }, root);
}

function toAutoScalingSettingsDescription(root: jsonP.JSONValue): s.AutoScalingSettingsDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinimumUnits": "n",
      "MaximumUnits": "n",
      "AutoScalingDisabled": "b",
      "AutoScalingRoleArn": "s",
      "ScalingPolicies": [toAutoScalingPolicyDescription],
    },
  }, root);
}

function toAutoScalingPolicyDescription(root: jsonP.JSONValue): s.AutoScalingPolicyDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
      "TargetTrackingScalingPolicyConfiguration": toAutoScalingTargetTrackingScalingPolicyConfigurationDescription,
    },
  }, root);
}

function toAutoScalingTargetTrackingScalingPolicyConfigurationDescription(root: jsonP.JSONValue): s.AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
  return jsonP.readObj({
    required: {
      "TargetValue": "n",
    },
    optional: {
      "DisableScaleIn": "b",
      "ScaleInCooldown": "n",
      "ScaleOutCooldown": "n",
    },
  }, root);
}

function toReplicaGlobalSecondaryIndexSettingsDescription(root: jsonP.JSONValue): s.ReplicaGlobalSecondaryIndexSettingsDescription {
  return jsonP.readObj({
    required: {
      "IndexName": "s",
    },
    optional: {
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IndexStatus>(x),
      "ProvisionedReadCapacityUnits": "n",
      "ProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ProvisionedWriteCapacityUnits": "n",
      "ProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
    },
  }, root);
}

function toKinesisDataStreamDestination(root: jsonP.JSONValue): s.KinesisDataStreamDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamArn": "s",
      "DestinationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DestinationStatus>(x),
      "DestinationStatusDescription": "s",
    },
  }, root);
}

function toTableAutoScalingDescription(root: jsonP.JSONValue): s.TableAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TableStatus>(x),
      "Replicas": [toReplicaAutoScalingDescription],
    },
  }, root);
}

function toReplicaAutoScalingDescription(root: jsonP.JSONValue): s.ReplicaAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
      "GlobalSecondaryIndexes": [toReplicaGlobalSecondaryIndexAutoScalingDescription],
      "ReplicaProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicaStatus>(x),
    },
  }, root);
}

function toReplicaGlobalSecondaryIndexAutoScalingDescription(root: jsonP.JSONValue): s.ReplicaGlobalSecondaryIndexAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IndexStatus>(x),
      "ProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
    },
  }, root);
}

function toItemResponse(root: jsonP.JSONValue): s.ItemResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
  }, root);
}

function toBackupSummary(root: jsonP.JSONValue): s.BackupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "TableId": "s",
      "TableArn": "s",
      "BackupArn": "s",
      "BackupName": "s",
      "BackupCreationDateTime": "d",
      "BackupExpiryDateTime": "d",
      "BackupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupStatus>(x),
      "BackupType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupType>(x),
      "BackupSizeBytes": "n",
    },
  }, root);
}

function toContributorInsightsSummary(root: jsonP.JSONValue): s.ContributorInsightsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "IndexName": "s",
      "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContributorInsightsStatus>(x),
    },
  }, root);
}

function toExportSummary(root: jsonP.JSONValue): s.ExportSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExportArn": "s",
      "ExportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportStatus>(x),
    },
  }, root);
}

function toGlobalTable(root: jsonP.JSONValue): s.GlobalTable {
  return jsonP.readObj({
    required: {},
    optional: {
      "GlobalTableName": "s",
      "ReplicationGroup": [toReplica],
    },
  }, root);
}
