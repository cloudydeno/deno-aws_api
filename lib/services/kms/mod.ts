// Autogenerated API client for: AWS Key Management Service

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.140.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export class KMS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KMS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-11-01",
    "endpointPrefix": "kms",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "KMS",
    "serviceFullName": "AWS Key Management Service",
    "serviceId": "KMS",
    "signatureVersion": "v4",
    "targetPrefix": "TrentService",
    "uid": "kms-2014-11-01"
  };

  async cancelKeyDeletion(
    params: s.CancelKeyDeletionRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CancelKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CancelKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async connectCustomKeyStore(
    params: s.ConnectCustomKeyStoreRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ConnectCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createAlias(
    params: s.CreateAliasRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createCustomKeyStore(
    params: s.CreateCustomKeyStoreRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CreateCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreName: params["CustomKeyStoreName"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
      TrustAnchorCertificate: params["TrustAnchorCertificate"],
      KeyStorePassword: params["KeyStorePassword"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStoreId": "s",
      },
    }, await resp.json());
  }

  async createGrant(
    params: s.CreateGrantRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CreateGrantResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GranteePrincipal: params["GranteePrincipal"],
      RetiringPrincipal: params["RetiringPrincipal"],
      Operations: params["Operations"],
      Constraints: fromGrantConstraints(params["Constraints"]),
      GrantTokens: params["GrantTokens"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateGrant",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GrantToken": "s",
        "GrantId": "s",
      },
    }, await resp.json());
  }

  async createKey(
    params: s.CreateKeyRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.CreateKeyResponse> {
    const body: jsonP.JSONObject = {
      Policy: params["Policy"],
      Description: params["Description"],
      KeyUsage: params["KeyUsage"],
      CustomerMasterKeySpec: params["CustomerMasterKeySpec"],
      KeySpec: params["KeySpec"],
      Origin: params["Origin"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      MultiRegion: params["MultiRegion"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async decrypt(
    params: s.DecryptRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DecryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: serializeBlob(params["CiphertextBlob"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      KeyId: params["KeyId"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "Decrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Plaintext": "a",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async deleteAlias(
    params: s.DeleteAliasRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteCustomKeyStore(
    params: s.DeleteCustomKeyStoreRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteImportedKeyMaterial(
    params: s.DeleteImportedKeyMaterialRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteImportedKeyMaterial",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async describeCustomKeyStores(
    params: s.DescribeCustomKeyStoresRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeCustomKeyStoresResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      CustomKeyStoreName: params["CustomKeyStoreName"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeCustomKeyStores",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStores": [toCustomKeyStoresListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async describeKey(
    params: s.DescribeKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async disableKey(
    params: s.DisableKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DisableKey",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async disableKeyRotation(
    params: s.DisableKeyRotationRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DisableKeyRotation",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async disconnectCustomKeyStore(
    params: s.DisconnectCustomKeyStoreRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DisconnectCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async enableKey(
    params: s.EnableKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "EnableKey",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async enableKeyRotation(
    params: s.EnableKeyRotationRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "EnableKeyRotation",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async encrypt(
    params: s.EncryptRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.EncryptResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Plaintext: serializeBlob(params["Plaintext"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "Encrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKey(
    params: s.GenerateDataKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GenerateDataKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      NumberOfBytes: params["NumberOfBytes"],
      KeySpec: params["KeySpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GenerateDataKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "Plaintext": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateDataKeyPair(
    params: s.GenerateDataKeyPairRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GenerateDataKeyPairResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GenerateDataKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PrivateKeyPlaintext": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyPairWithoutPlaintext(
    params: s.GenerateDataKeyPairWithoutPlaintextRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GenerateDataKeyPairWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GenerateDataKeyPairWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyWithoutPlaintext(
    params: s.GenerateDataKeyWithoutPlaintextRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GenerateDataKeyWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      KeySpec: params["KeySpec"],
      NumberOfBytes: params["NumberOfBytes"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GenerateDataKeyWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateRandom(
    params: s.GenerateRandomRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.GenerateRandomResponse> {
    const body: jsonP.JSONObject = {
      NumberOfBytes: params["NumberOfBytes"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GenerateRandom",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Plaintext": "a",
      },
    }, await resp.json());
  }

  async getKeyPolicy(
    params: s.GetKeyPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetKeyPolicyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetKeyPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async getKeyRotationStatus(
    params: s.GetKeyRotationStatusRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetKeyRotationStatusResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetKeyRotationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyRotationEnabled": "b",
      },
    }, await resp.json());
  }

  async getParametersForImport(
    params: s.GetParametersForImportRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetParametersForImportResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      WrappingAlgorithm: params["WrappingAlgorithm"],
      WrappingKeySpec: params["WrappingKeySpec"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetParametersForImport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "ImportToken": "a",
        "PublicKey": "a",
        "ParametersValidTo": "d",
      },
    }, await resp.json());
  }

  async getPublicKey(
    params: s.GetPublicKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetPublicKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetPublicKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "PublicKey": "a",
        "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomerMasterKeySpec>(x),
        "KeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeySpec>(x),
        "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyUsageType>(x),
        "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x)],
        "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x)],
      },
    }, await resp.json());
  }

  async importKeyMaterial(
    params: s.ImportKeyMaterialRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      ImportToken: serializeBlob(params["ImportToken"]),
      EncryptedKeyMaterial: serializeBlob(params["EncryptedKeyMaterial"]),
      ValidTo: jsonP.serializeDate_unixTimestamp(params["ValidTo"]),
      ExpirationModel: params["ExpirationModel"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ImportKeyMaterial",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async listAliases(
    params: s.ListAliasesRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.ListAliasesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListAliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Aliases": [toAliasListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listGrants(
    params: s.ListGrantsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
      GranteePrincipal: params["GranteePrincipal"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeyPolicies(
    params: s.ListKeyPoliciesRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListKeyPoliciesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListKeyPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyNames": ["s"],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeys(
    params: s.ListKeysRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.ListKeysResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Keys": [toKeyListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listResourceTags(
    params: s.ListResourceTagsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListResourceTagsResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListResourceTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listRetirableGrants(
    params: s.ListRetirableGrantsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      RetiringPrincipal: params["RetiringPrincipal"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListRetirableGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async putKeyPolicy(
    params: s.PutKeyPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
      Policy: params["Policy"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutKeyPolicy",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async reEncrypt(
    params: s.ReEncryptRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ReEncryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: serializeBlob(params["CiphertextBlob"]),
      SourceEncryptionContext: params["SourceEncryptionContext"],
      SourceKeyId: params["SourceKeyId"],
      DestinationKeyId: params["DestinationKeyId"],
      DestinationEncryptionContext: params["DestinationEncryptionContext"],
      SourceEncryptionAlgorithm: params["SourceEncryptionAlgorithm"],
      DestinationEncryptionAlgorithm: params["DestinationEncryptionAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ReEncrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "SourceKeyId": "s",
        "KeyId": "s",
        "SourceEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
        "DestinationEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async replicateKey(
    params: s.ReplicateKeyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ReplicateKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      ReplicaRegion: params["ReplicaRegion"],
      Policy: params["Policy"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ReplicateKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicaKeyMetadata": toKeyMetadata,
        "ReplicaPolicy": "s",
        "ReplicaTags": [toTag],
      },
    }, await resp.json());
  }

  async retireGrant(
    params: s.RetireGrantRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GrantToken: params["GrantToken"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "RetireGrant",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async revokeGrant(
    params: s.RevokeGrantRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "RevokeGrant",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async scheduleKeyDeletion(
    params: s.ScheduleKeyDeletionRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ScheduleKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PendingWindowInDays: params["PendingWindowInDays"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ScheduleKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "DeletionDate": "d",
        "KeyState": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyState>(x),
        "PendingWindowInDays": "n",
      },
    }, await resp.json());
  }

  async sign(
    params: s.SignRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.SignResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      GrantTokens: params["GrantTokens"],
      SigningAlgorithm: params["SigningAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "Sign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Signature": "a",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    params: s.TagResourceRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "TagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async untagResource(
    params: s.UntagResourceRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UntagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateAlias(
    params: s.UpdateAliasRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UpdateAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateCustomKeyStore(
    params: s.UpdateCustomKeyStoreRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      NewCustomKeyStoreName: params["NewCustomKeyStoreName"],
      KeyStorePassword: params["KeyStorePassword"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UpdateCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateKeyDescription(
    params: s.UpdateKeyDescriptionRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UpdateKeyDescription",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updatePrimaryRegion(
    params: s.UpdatePrimaryRegionRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PrimaryRegion: params["PrimaryRegion"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UpdatePrimaryRegion",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async verify(
    params: s.VerifyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.VerifyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      Signature: serializeBlob(params["Signature"]),
      SigningAlgorithm: params["SigningAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "Verify",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "SignatureValid": "b",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

}

function fromGrantConstraints(input?: s.GrantConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionContextSubset: input["EncryptionContextSubset"],
    EncryptionContextEquals: input["EncryptionContextEquals"],
  }
}
function toGrantConstraints(root: jsonP.JSONValue): s.GrantConstraints {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionContextSubset": x => jsonP.readMap(String, String, x),
      "EncryptionContextEquals": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TagKey: input["TagKey"],
    TagValue: input["TagValue"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "TagKey": "s",
      "TagValue": "s",
    },
    optional: {},
  }, root);
}

function toKeyMetadata(root: jsonP.JSONValue): s.KeyMetadata {
  return jsonP.readObj({
    required: {
      "KeyId": "s",
    },
    optional: {
      "AWSAccountId": "s",
      "Arn": "s",
      "CreationDate": "d",
      "Enabled": "b",
      "Description": "s",
      "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyUsageType>(x),
      "KeyState": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyState>(x),
      "DeletionDate": "d",
      "ValidTo": "d",
      "Origin": (x: jsonP.JSONValue) => cmnP.readEnum<s.OriginType>(x),
      "CustomKeyStoreId": "s",
      "CloudHsmClusterId": "s",
      "ExpirationModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExpirationModelType>(x),
      "KeyManager": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyManagerType>(x),
      "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomerMasterKeySpec>(x),
      "KeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeySpec>(x),
      "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x)],
      "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x)],
      "MultiRegion": "b",
      "MultiRegionConfiguration": toMultiRegionConfiguration,
      "PendingDeletionWindowInDays": "n",
    },
  }, root);
}

function toMultiRegionConfiguration(root: jsonP.JSONValue): s.MultiRegionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultiRegionKeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiRegionKeyType>(x),
      "PrimaryKey": toMultiRegionKey,
      "ReplicaKeys": [toMultiRegionKey],
    },
  }, root);
}

function toMultiRegionKey(root: jsonP.JSONValue): s.MultiRegionKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Region": "s",
    },
  }, root);
}

function toCustomKeyStoresListEntry(root: jsonP.JSONValue): s.CustomKeyStoresListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomKeyStoreId": "s",
      "CustomKeyStoreName": "s",
      "CloudHsmClusterId": "s",
      "TrustAnchorCertificate": "s",
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionStateType>(x),
      "ConnectionErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionErrorCodeType>(x),
      "CreationDate": "d",
    },
  }, root);
}

function toAliasListEntry(root: jsonP.JSONValue): s.AliasListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasName": "s",
      "AliasArn": "s",
      "TargetKeyId": "s",
      "CreationDate": "d",
      "LastUpdatedDate": "d",
    },
  }, root);
}

function toGrantListEntry(root: jsonP.JSONValue): s.GrantListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "GrantId": "s",
      "Name": "s",
      "CreationDate": "d",
      "GranteePrincipal": "s",
      "RetiringPrincipal": "s",
      "IssuingAccount": "s",
      "Operations": [(x: jsonP.JSONValue) => cmnP.readEnum<s.GrantOperation>(x)],
      "Constraints": toGrantConstraints,
    },
  }, root);
}

function toKeyListEntry(root: jsonP.JSONValue): s.KeyListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "KeyArn": "s",
    },
  }, root);
}
